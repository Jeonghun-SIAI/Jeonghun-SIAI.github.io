<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-21T14:39:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">A test page</title><subtitle>GitHub Page를 익히기 위한 테스트 페이지입니다</subtitle><author><name>Jeonghun Song</name></author><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 3) 월별 사용량 크기가 이상한 data point 제거</title><link href="http://localhost:4000/2023/04/monthlyenergythree.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 3) 월별 사용량 크기가 이상한 data point 제거" /><published>2023-04-23T00:00:00+09:00</published><updated>2023-04-23T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/monthlyenergythree</id><content type="html" xml:base="http://localhost:4000/2023/04/monthlyenergythree.html"><![CDATA[<p>저번 포스팅에서는 건물 월별 에너지 사용량의 ‘추이’가 이상한 data point를 판별하는 방법을 설명했다. 이번 포스팅에서는 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.</p>

<p><br />
상식적으로, 같은 용도의 건물이라면 크기가 큰 건물일수록 에너지 사용량이 큰 경향이 있을 것이다. 이를테면 서울 내 업무용 건물들의 1월 전기 사용량을 연면적 (모든 층의 바닥면적의 합, 단 주차장이나 공용시설 등은 제외) 에 대해 scatter plot하면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergythree/outliers.png" alt="outliers" class="align-center" /></p>

<p>다소 데이터의 흩어짐(분산)이 크긴 하나, 어쨌든 연면적이 클수록 ‘평균적으로는’ 전기 사용량이 커지는 경향이 있다.</p>

<p><br />
그런데, 위 그림의 빨간 점들은 딱 봐도 ‘크기가 이상한’ data point, 소위 말해서 ‘outlier’이다. 건물 연면적을 고려했을 때 전기 사용량의 값이 지나치게 크다.</p>

<p>이는 측정/기재 오류일 수도 있고, 어쩌면 정말로 저만큼 많은 전기를 쓰는 것일 수도 있다. 그러나 만에 하나 정말로 저렇게 많은 전기를 사용한다고 하더라도, 그런 건물은 일반적이지 않으므로 따로 떼어서 별도의 모델링을 하는 것이 맞다. 즉, ‘일반적인’ 건물들에 대한 통계적 연구 수행을 위해서는 위 outlier들은 제거해야 한다.</p>

<p>그럼 outlier는 어떻게 판별하나? 데이터의 size가 그렇게 크지 않고 설명변수가 하나라면, 그냥 그래프를 그려서 눈으로 보고 제거할 수도 있을 것이다. 그러나 데이터 size도 커지고 설명변수도 둘 이상이 되면, 눈으로 보기 매우 힘들다 (이를 테면 반응변수를 에너지 사용량으로 하는 회귀모델에 대해, 설명변수가 건물 연면적 뿐 아니라 건물 층수, 사용연수, 재질 등 여러 가지가 될 수 있다.</p>

<p>그러므로 시각화를 필요로 하지 않으면서 outlier를 판별할 수 있는, 이전 포스팅에서처럼 지표(metric)에 기반해서 판별하는 방법이 필요하다.</p>

<p><br />
여기서 생각해 볼 수 있는 것은, 위 그림에서 outlier들이 있을 때와 없을 때 각 경우에 대해 회귀분석을 했을 때의 직선의 기울기이다. 위 그림 기준으로는 빨간 점들이 없을 때 계산된 직선의 기울기에 비해, 빨간 점들이 있을 때 계산된 직선의 기울기가 더 가파를 것이다. 즉 outlier들이 있을 때 구한 회귀계수와 없을 때 구한 회귀계수 간에 유의미한 차이가 있을 것이다.</p>

<p>반대로, 검정 점들 중 몇 개 정도를 없애고 회귀계수를 계산했다고 하자. 그 결과는 아마, 모든 점들이 있을 때의 회귀계수와 별 차이가 없을 것이다.</p>

<p>그렇다면, 각 data point $i$에 대해, $i$가 포함되어 있을 때 구한 회귀계수와 $i$가 제외될 때 구한 회귀계수 간의 표준화된 차이를 모든 data point들 각각에 대해 구한다면, 그 차이가 큰 data point가 outlier일 것임을 짐작할 수 있다.</p>

<p>이러한 ‘특정 점 $i$의 유무에 따른 회귀계수 간 표준화된 차이’를 Cook’s Distance라 한다. 
$m$월의 전기 사용량을 반응변수로 하는 회귀모델에 대해, Cook’s Distance의 수식은 아래와 같다.</p>

<p>$ D_{i}^{elec,m}=\frac{\left({\hat{\beta}}^{elec,m}-{\hat{\beta}}_{-i}^{elec,m}\right)^{\top}X^{\top}X\left({\hat{\beta}}^{elec,m}-{\hat{\beta}}_{-i}^{elec,m}\right)}{k \cdot MSR^{elec,m}}$</p>

<p>$\hat{\beta}$는 data point $i$를 포함해 모든 data point들이 있을 때 구한 회귀계수이고, $\hat{\beta}_{-i}$는 data point $i$만을 dataset으로부터 뺐을 때 구한 회귀계수이다. $X$는 설명변수 행렬로, $i$번째 행이 $i$번째 data point에 대한 설명변수들로 구성된 행벡터이다 (여기서 설명변수수는 연면적, 층수, 사용연도, 재질, …, 그리고 상수항 표현을 위한 1). 분모의 $k$는 설명변수 개수이고, $MSR$은 잔차의 평균제곱합이다.</p>

<p><br />
이 때, 혹자는 계산시간 관련해서 우려를 표할 수 있다. 만약 data point가 수십만 개면, Cook’s Distance들을 계산하기 위해 수십만 번의 회귀분석을 계산해야 되는 것이 아닐까? 그러면 시간이 너무 오래 걸리지 않을까?</p>

<p>다행히도 그렇지 않다. 단 한 번의 회귀분석과 한 번의 행렬 연산으로, 모든 data point 각각에 대한 Cook’s Distance들을 계산할 수 있다. Cook’s Distance의 다른 식은 아래와 같다.</p>

<p>$D_{i}^{elec,m}=\frac{\hat{\epsilon}_{i}^{elec,m}h_{ii}}{k \cdot MSR^{elec,m}\left(1-h_{ii}\right)^2}$</p>

<p>여기서 $\hat{\epsilon}_{i}^{elec,m}$는 $i$번째 잔차, $h_{ii}$는 hat matrix $X\left(X^{\top} X \right)^{-1}X^{\top}$의 $i$번째 대각성분이다.</p>

<p>(역시 자세한 내용은 <a href="https://product.kyobobook.co.kr/detail/S000002582053">Montgomery의 Introduction to Linear Regression</a>의 7단원을 참고하길 바란다.)</p>

<p><br />
필자가 알기로는 Cook’s D에는 어떤 rule of thumb로써의 수치가 있지는 않은 듯 하다. 사전에 정의한 갯수만큼의 데이터를, Cook’s D가 큰 순서대로 제거하는 것이 현실적인 방법으로 보인다.</p>

<p>단, 주의할 점은, 한 번의 Cook’s D 계산 후 data point 여러 개를 제거하면 안 된다. Cook’s D가 가장 큰 ‘하나의’ point만 제거하고, 다시 모든 point Cook’s D를 계산해서 또 하나를 제거하고 다시 계산하는 과정을 반복해야 한다.</p>

<p>이는 Cook’s D 자체가 ‘하나의’ data point의 유무 간 차이에 대해 정의되기 때문이다.</p>

<p>만약 어떤 dataset에 대해 Cook’s D를 계산했더니 point $i$에 대해 Cook’s D가 가장 크고 $j$에 대해 Cook’s D가 두 번째로 크다고 하자. 이 때 point $j$에 대한 Cook’s D는, point $i$가 dataset에 있다는 가정 하에 계산된다. 그런데 우리는 outlier를 제거해나가야 하므로, Cook’s D가 가장 큰 outlier $i$가 dataset에 있다는 가정 하에 나머지 point들에 대한 outlier 여부를 판단하는 것은 부자연스럽다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[저번 포스팅에서는 건물 월별 에너지 사용량의 ‘추이’가 이상한 data point를 판별하는 방법을 설명했다. 이번 포스팅에서는 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.]]></summary></entry><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 2) 월별 사용 추이가 이상한 data point 제거</title><link href="http://localhost:4000/2023/04/monthlyenergytwo.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 2) 월별 사용 추이가 이상한 data point 제거" /><published>2023-04-22T00:00:00+09:00</published><updated>2023-04-22T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/monthlyenergytwo</id><content type="html" xml:base="http://localhost:4000/2023/04/monthlyenergytwo.html"><![CDATA[<p>이전 포스팅에서, 각 건물의 지번별/월별 전기와 도시가스 사용량 데이터를 소개하였다. 또한 이를 표제부와 결합해 건물 에너지 분석에 활용할 수 있으며, 그 결합 방법 또한 소개하였다.</p>

<p>그렇다면 결합된 데이터를 그대로 쓰면 되는가? 그렇지 않다. 분명히 ‘이상한’ data point들이 존재할 것이기 때문이다. 데이터 기반의 연구개발을 한다면, 이러한 ‘이상한’ data point들을 제거하거나 수정하는 데이터 전처리는 필수이다.</p>

<p>각 건물의 지번별 데이터는 row의 수가 많다. 서울의 경우 데이터 전처리를 해도 만 단위이다. 데이터가 이 정도로 크면, 회귀분석 등을 할 때 모델을 잘 구성했다는 전제 하에 일관성(consistency)에 의해 계수추정량이 실제 값에 가까울 확률이 매우 높다. 그러므로 이 포스팅에서는, ‘이상한’ data point는 전부 삭제한다고 하자.</p>

<p>가장 먼저 떠올릴 전처리는, 누락이 있는 point 제거이다. 이미 이전 포스팅의 마지막 부분에서 SQLite DB로부터 서울 내 건물들 중 ‘전기 사용량 및 연면적 값의 누락이 없는’ point들만 불러왔다. 여기에 더해, 봄~가을의 도시가스 사용 내역이 있는데 겨울(12, 1, 2월)의 도시가스 사용 내역이 없는 point는 ‘이상한’ point로 보고 제거한다 (상식적으로 도시가스를 쓴다면 겨울에 집중적으로 쓰는 것이 정상이므로).</p>

<p><br />
그 외에 `이상하다’의 기준은, 크게 다음의 두 가지로 볼 수 있다.</p>

<p>1) 12개월 간 월별 에너지 사용량의 추이가 이상함 (전기 사용량 내역을 봤더니 봄/가을 사용량이 여름 사용량보다 월등히 높다든지)</p>

<p>2) 에너지 사용량의 크기(magnitude)가 이상함 (건물은 작은데 비슷한 크기의 타 건물들 대비 에너지 사용량이 지나치게 크다든지)</p>

<p>이러한 ‘이상함’의 이유를 정확히는 알 수 없다. 그러나 이러한 point들은 ‘일반적인’ 건물들에 대한 통계적 에너지 모델링에 도움이 되기는커녕 오히려 해가 될 것이므로, 제거해야 한다.</p>

<p>이번 포스팅에서는 건물 월별 에너지 사용량의 `추이’가 이상한 data point를 판별하는 방법을 설명한다.</p>

<p><br />
건물 월별 에너지 사용량의 ‘정상적인’ 추이는 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergytwo/normalpattern.png" alt="normalpattern" class="align-center" /></p>

<p>일반적인 월별 전기 사용량 추이의 경우, 냉방으로 인해 여름의 사용량이 상대적으로 크다. 겨울의 전기 사용량은 봄/가을 대비 약간 크지만 전기난방을 하는 경우 건물에 따라 많이 클 수도 있고, 봄/ 가을과 거의 비슷할 수도 있다. 즉 월별 전기 사용량의 추이는 1~12월 plot 기준으로 중간이 튀어나온 압정 모양 혹은 더블유(W)자 모양을 띤다.</p>

<p>일반적인 월별 가스 사용량 추이의 경우, 난방으로 인해 겨울의 사용량이 매우 크다. 여름의 사용량은 대부분은 매우 작으나, 식당/ 목욕탕 등 비중이 큰 일부 건물에서는 여름에도 봄/ 가을과 비슷한 가스 사용량을 보이기도 한다. 즉 월별 가스 사용량의 추이는 유(U)자 모양을 띤다.</p>

<p><br />
그런데, 이와는 매우 다른 추이를 보이는 data point들이 있다. 예를 들면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergytwo/abnormalpattern.png" alt="abnormalpattern" class="align-center" /></p>

<p>정확히는, 위 그림은 `각 월별 사용량이 연간 사용량에서 차지하는 비중’을 나타낸 그림이다. 각 월별 전기 사용량을 원소로 하는 12차원 열벡터를 $y_{i}$라 할 때, 위 그림은 $y_{i} / \Vert y_{i} \Vert_{1}$이다.
위 그림에서 보이는 월별 사용량 추이는, 일반적인 추이와 거리가 멀다. 그러므로 해당 data point를 삭제해야 한다.</p>

<p><br />
그러면, 이상한 추이를 보이는 data point들은 어떻게 판별할 수 있을까? 월별 비중 그림을 일일이 다 그려서? 데이터 size (data point의 개수) 가 수천개만 되어도 이는 불가능하다. 각 data point 별로 어떤 지표(metric)를 계산 후 그 지표의 크기로 이상한 point를 판별하는 방법이 필요하다.</p>

<p>위에서 언급한 각 월별 사용량 비중을 나타내는 벡터 $y_{i} / \Vert y_{i} \Vert_{1}$를 $\tilde{y}_{i}$라 하자. 그리고 모든 건물들에 대한 $\tilde{y}_{i}$들을 ‘행벡터들을 쌓는 방식으로’ 결합하여 만든 행렬 $\tilde{Y} = [\tilde{y}_{1},\tilde{y}_{2},\cdots, \tilde{y}_{N}]^{\top}$ 을 생각하자.</p>

<p>이 때, $i$번째 data point에 대해 스칼라 값 $\tilde{y}_{i}^{\top} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{y}_{i}$ 를 계산할 수 있다. 이 값이 큰 경우, $\tilde{y}_{i}$는 월별 사용량 비중 벡터들이 만드는 12차원 공간 내에서 다른 data point들로부터 멀리 떨어져 있는 ‘remote’ point임이 알려져 있다.</p>

<p>구체적으로는 $\tilde{y}_{i}^{\top} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{y}_{i}$는 행렬 $\tilde{Y} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{Y}^{\top}$의 대각성분이다. 만약 $\tilde{y}_{i}$가 어떤 회귀모델의 설명변수 벡터인 경우, 이를 hat matrix라고 부른다. Hat matrix의 대각성분은, data point들의 중심으로부터의 표준화된 거리를 의미한다.</p>

<p>(자세한 내용은 <a href="https://product.kyobobook.co.kr/detail/S000002582053">Montgomery의 Introduction to Linear Regression</a>의 7단원을 참고하길 바란다.)</p>

<p><br />
그러면 이 스칼라 값이 구체적으로 얼마 이상이면 remote point라고 볼 수 있을까? Rule of thumb가 되는 기준은 $2p/N$으로, $p$는 $\tilde{y}_{i}$가 설명변수 벡터라 할 때 설명변수의 수이고 (월별 에너지 사용량 case의 경우 12), $N$은 data point 수이다.</p>

<p>정리하면, ‘이상한’ 월별 전기 사용량 추이를 갖는 data point들은 아래 과정을 거쳐 판별한다.</p>

<p>1) 모든 data point들에 대한 월별 전기 사용량 자료를 월별 전기 사용량의 ‘비중’ 데이터로 변환 후 각 행이 월별 전기 사용량인 12열짜리 행렬 $\tilde{Y}$로써 결합</p>

<p>2) 위에서 설명한 행렬 $\tilde{Y} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{Y}^{\top}$를 계산</p>

<p>3) $i$번째 대각성분이 $24/N$ 이상인 경우 ‘이상한 월별 전기 사용량 추이’를 갖는 data point로 보고 삭제
이는 월별 가스에 대해서도 마찬가지로 수행한다.</p>

<p>(이상한 추이를 갖는 data point들 그림도, 위 과정을 통해 판별한 것이다)</p>

<p>다음 포스팅에서는 건물 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[이전 포스팅에서, 각 건물의 지번별/월별 전기와 도시가스 사용량 데이터를 소개하였다. 또한 이를 표제부와 결합해 건물 에너지 분석에 활용할 수 있으며, 그 결합 방법 또한 소개하였다.]]></summary></entry><entry><title type="html">WSL2 Ubuntu 22.04에 CUDA &amp;amp; cuDNN 설치하기</title><link href="http://localhost:4000/2023/04/cudadudnn.html" rel="alternate" type="text/html" title="WSL2 Ubuntu 22.04에 CUDA &amp;amp; cuDNN 설치하기" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/cudadudnn</id><content type="html" xml:base="http://localhost:4000/2023/04/cudadudnn.html"><![CDATA[<p>자신의 NVIDIA 그래픽카드 모델명에 맞는 NVIDIA driver를 <a href="https://www.nvidia.co.kr/Download/index.aspx?lang=kr">다운로드 웹페이지</a> 찾아서 윈도우에서 설치</p>

<p>ubuntu bash에서 $\texttt{nvidia-smi}$ 실행 시, 드라이버 설치 확인 가능</p>

<p><br />
<a href="https://www.tensorflow.org/install/gpu?hl=ko">Tensorflow 웹페이지</a>에서 호환되는 CUDA 버전 확인 (‘소프트웨어 요구사항’ 항목을 보면, Tensorflow의 경우 CUDA 11.2 지원)</p>

<p><br />
<a href="https://developer.nvidia.com/cuda-11.2.0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=WSLUbuntu&amp;target_version=20&amp;target_type=runfilelocal">CUDA Toolkit Downloads 웹페이지</a>에서 Linux - x86_64 - WSL-Ubuntu - 2.0 - runtime (local) 선택 시 보여주는 명령어를 ubuntu bash에 쳐서 CUDA를 다운로드</p>

<p>명령어는 아래와 같음</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run
sudo sh cuda_11.2.0_460.27.04_linux.run
</code></pre></div></div>

<p><br />
혹시 $\texttt{sudo sh cuda_11.2.0_460.27.04_linux.run}$ 입력 시</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed to verify gcc version. See log at /var/log/cuda-installer.log for details.
</code></pre></div></div>
<p>라는 gcc 버전 오류가 뜬다면, gcc를 버전 9로 낮춰야 함,
<a href="https://gooopy.tistory.com/134">이 포스트</a>에서 소개하는 명령어들에서 버전 숫자를 8에서 9로만 바꿔서 입력 (버전 8까지는 apt 다운로드 서버에서 없어진 듯함), 명령어는 아래와 같음</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt -y install gcc-9 g++-9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 9
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 9
</code></pre></div></div>
<p>그리고 다시 $\texttt{sudo sh cuda_11.2.0_460.27.04_linux.run}$ 를 bash에서 실행하면
라이선스 관련 큰 창, 그리고 거기서 accept를 입력하면 설치 옵션 관련 큰 창이 뜰 것임</p>

<p>(미리 terminal 높이를 최대한 높여놓길 권장, 너무 낮으면 안 보임)</p>

<p>선택하고 좀 기다리면 설치됨, 필자의 경우 설치 직후 아래의 메시지가 떴음</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>= Summary =
===========

Driver:   Not Selected
Toolkit:  Installed in /usr/local/cuda-11.2/
Samples:  Installed in /home/ubuntu/, but missing recommended libraries

Please make sure that
 -   PATH includes /usr/local/cuda-11.2/bin
 -   LD_LIBRARY_PATH includes /usr/local/cuda-11.2/lib64, or, add /usr/local/cuda-11.2/lib64 to /etc/ld.so.conf and run ldconfig as root

To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-11.2/bin
***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 460.00 is required for CUDA 11.2 functionality to work.
To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file:
    sudo &lt;CudaInstaller&gt;.run --silent --driver

Logfile is /var/log/cuda-installer.log
</code></pre></div></div>

<p><br />
ubuntu bash에 $\texttt{vi /etc/profile}$ 입력 후 vi 에디터에서 $\texttt{i}$ 누르면 편집 가능</p>

<p>(vi 에디터 명령은 <a href="https://kkalkkalparrot.tistory.com/36">이 포스팅</a> 참고)</p>

<p>etc/profile에 아래 코드 입력 (<a href="https://nirsa.tistory.com/332">이 포스팅 참고</a>)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:/usr/local/cuda-11.2/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.2/lib64
export CUDADIR=/usr/local/cuda-11.2
</code></pre></div></div>

<p>입력 후 Esc 눌러 편집 모드에서 나오고 $\texttt{:w}$ 입력 시 저장됨</p>

<p>그리고 $\texttt{source /etc/profile}$ 입력</p>

<p>CUDA 설치 버전 확인은 bash에서 $\texttt{nvcc -V}$ 실행</p>

<p><br />
cuDNN 설치는 <a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">공식 가이드</a> 참고</p>

<p>가이드의 1.1.3 항목대로 $\texttt{Zlib}$를 다운받기 위해, $\texttt{sudo apt-get install zlib1g}$ 를 bash에서 실행</p>

<p>가이드의 1.2 항목대로 cudNN을 다운로드 <a href="https://developer.nvidia.com/rdp/cudnn-download">(다운로드 링크)</a></p>

<p>다운받으려면 NVIDIA 계정 필요하므로 없을 경우 생성</p>

<p>for CUDA 11.x 에 있는 Local Installer for Linux x86_64 (Tar) 를 우선 윈도우즈에서 다운받고,
다운로드 완료되면 ubuntu shell에서 $\texttt{mtn}$으로 접근, 파일 확인 후 $\texttt{home}$ 내 폴더로 복사해 감</p>

<p>이를테면 $\texttt{D:\Downloads}$ 에 받았다고 하면 ubuntu bash에서 아래 명령 실행</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp "/mnt/d/Downloads/cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz" "/home/ubuntu/workspaces"
</code></pre></div></div>
<p>그리고 복사된 파일의 위치에서, 공식 가이드대로 아래 명령들 실행</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xvf cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz
sudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/include
sudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64
sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn*
</code></pre></div></div>

<p><br />
이후 재부팅한 후 ubuntu에서 tensorflow 쓰는 파이썬 코드 실행 시, 아래와 같은 맥락의 메시지를 본다면 성공임</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I tensorflow/core/common_runtime/gpu/gpu_device.cc:1635] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 2029 MB memory:  -&gt; device: 0, name: NVIDIA GeForce GTX 1650 SUPER, pci bus id: 0000:01:00.0, compute capability: 7.5
</code></pre></div></div>

<p>만약 tensorflow를 사용하지만 GPU를 사용하지는 않을 경우, Python 기준으로 코드 상단에 아래 코드 추가</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
</code></pre></div></div>]]></content><author><name>Jeonghun Song</name></author><category term="etc" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[자신의 NVIDIA 그래픽카드 모델명에 맞는 NVIDIA driver를 다운로드 웹페이지 찾아서 윈도우에서 설치]]></summary></entry><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 1) 모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화</title><link href="http://localhost:4000/2023/04/monthlyenergyone.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 1) 모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/monthlyenergyone</id><content type="html" xml:base="http://localhost:4000/2023/04/monthlyenergyone.html"><![CDATA[<p>필자에게 있어 각별한 데이터셋이 있다. (비주거용) 건축물 별 월별 에너지 사용량 데이터셋이다. 각지번 주소 단위의 개별 비주거용 건물별로 특정 월에 소비한 전기와 가스의 양을 kWh 단위로 기록한 데이터셋이다.</p>

<p>어떤 건물의 1년 12개월 간 월별 전기 사용량과 가스 사용량은, 대부분 아래 그림과 같은 형태를 띤다.</p>

<p><img src="/assets/images/monthlyenergyone/typicalpattern.png" alt="typicalpattern" class="align-center" /></p>

<p>전기 사용량은 7월/ 8월 즉 여름에 크고, 가스 사용량은 1월/ 2월/ 12월 즉 겨울에 큰 걸 볼 수 있다.</p>

<p>이러한 개별 건물의 월별 에너지 사용량 데이터는, <a href="https://open.eais.go.kr/main/main.do">국토교통부의 건축데이터 민간개방 시스템</a>에서 제공한다.</p>

<p><img src="/assets/images/monthlyenergyone/webpage_monthlyenergy.png" alt="webpage_monthlyenergy" class="align-center" /></p>

<p>각각이 수십(가스)~수백(전기) MB의 텍스트 파일이며, 구분자는 $|$ 이다. 이를 엑셀로 열어보면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergyone/monthly_raw.png" alt="monthly_raw" class="align-center" /></p>

<p>위 그림은 2022년 1월 전기 사용량에 대한 데이터셋으로, E~J열이 건물 주소, Q열이 2022년 1월의 에너지 사용량이다.</p>

<p>필자는 박사과정 시절에 위 데이터셋을 이용해 공공건축물 신재생에너지 의무화 정책이 민간건물로까지 확대될 경우의 영향을 분석하고 및 도시 단위의 대규모 적용 시 영향을 예측하는 기법에 대한 연구를 수행해 박사학위를 받았고, 이 연구를 소재로 <a href="https://doi.org/10.1016/j.energy.2019.116132">Energy</a>와 <a href="https://doi.org/10.1016/j.apenergy.2020.115489">Applied Energy</a>에 논문도 게재했다.</p>

<p>또한 최근에는, 위 데이터셋을 또 이용해 개별 건축물 내 월별 에너지 사용량의 결합확률분포를 모델링하는 연구를 수행하고 외부 발표를 하기도 했다 (<a href="https://rnd.gmdsa.org/building-energy-prediction/">MDSA 기사글</a>).</p>

<p><img src="/assets/images/monthlyenergyone/mdsaseminar.png" alt="mdsaseminar" class="align-center" /></p>

<p>다만, 이 데이터셋을 제대로 활용하려면 몇 가지 사전 작업을 거쳐야 했다. 먼저 모든 월의 전기/도시가스 사용량들을 통합하고, 각 건축물 지번 별 속성 (각 건물별 연면적/ 용도/ 층수/ 건축연수/ 재질 등) 정보를 담은 데이터셋인 표제부와 결합을 해야 했다. 그리고 누락 데이터, 모양이 이상한 데이터, outlier 등을 제거해야 했다.</p>

<p>이번 포스팅은 에너지 사용량 데이터와 표제부를 Python의 pandas를 이용해 결합하고 SQL DB로 저장했던 과정에 대한 기록이다.</p>

<p>지번별 월별 에너지 사용량 데이터는 각 월별로 흩어져 있는데, 먼저 공통된 연도의 월별 사용량 자료들을 Python의 pandas를 이용해 하나로 합쳤다. 2022년의 1~12월 전기 사용량과 가스 사용량 데이터들을 하나로 합치는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">settings</span>

<span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="s">'elec_202201'</span><span class="p">,</span><span class="s">'elec_202202'</span><span class="p">,</span><span class="s">'elec_202203'</span><span class="p">,</span><span class="s">'elec_202204'</span><span class="p">,</span><span class="s">'elec_202205'</span><span class="p">,</span><span class="s">'elec_202206'</span><span class="p">,</span><span class="s">'elec_202207'</span><span class="p">,</span><span class="s">'elec_202208'</span><span class="p">,</span><span class="s">'elec_202209'</span><span class="p">,</span><span class="s">'elec_202210'</span><span class="p">,</span><span class="s">'elec_202211'</span><span class="p">,</span><span class="s">'elec_202212'</span><span class="p">,</span>
            <span class="s">'gas_202201'</span><span class="p">,</span><span class="s">'gas_202202'</span><span class="p">,</span><span class="s">'gas_202203'</span><span class="p">,</span><span class="s">'gas_202204'</span><span class="p">,</span><span class="s">'gas_202205'</span><span class="p">,</span><span class="s">'gas_202206'</span><span class="p">,</span><span class="s">'gas_202207'</span><span class="p">,</span><span class="s">'gas_202208'</span><span class="p">,</span><span class="s">'gas_202209'</span><span class="p">,</span><span class="s">'gas_202210'</span><span class="p">,</span><span class="s">'gas_202211'</span><span class="p">,</span><span class="s">'gas_202212'</span><span class="p">]</span>

<span class="n">colname</span> <span class="o">=</span> <span class="p">[</span><span class="s">'useYm'</span><span class="p">,</span><span class="s">'rnum'</span><span class="p">,</span><span class="s">'sigunguCd'</span><span class="p">,</span><span class="s">'bjdongCd'</span><span class="p">,</span><span class="s">'sido'</span><span class="p">,</span><span class="s">'sigungu'</span><span class="p">,</span><span class="s">'bjdong'</span><span class="p">,</span><span class="s">'platGbCd'</span><span class="p">,</span><span class="s">'bun'</span><span class="p">,</span><span class="s">'ji'</span><span class="p">,</span><span class="s">'naRoadCd'</span><span class="p">,</span><span class="s">'naRoad'</span><span class="p">,</span><span class="s">'naUgrndCd'</span><span class="p">,</span><span class="s">'naUgrnd'</span><span class="p">,</span><span class="s">'naMainBun'</span><span class="p">,</span><span class="s">'naSubBun'</span><span class="p">,</span><span class="s">'useQty'</span><span class="p">]</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">ENERGY_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">{}.txt'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span><span class="n">sep</span><span class="o">=</span><span class="s">'|'</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'cp949'</span><span class="p">,)</span>
    
    <span class="n">df_temp</span><span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">()</span>
    
    <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sido'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigungu'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"bjdong"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"bun"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">"-"</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"ji"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"번지|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'sigunguCd'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'bjdongCd'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'bun'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'ji'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="c1"># 한 개 column만을 outer join 기준으로 하기 위해 코드까지 같이 넣음
</span>    <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="s">'-0'</span><span class="p">,</span><span class="s">''</span><span class="p">)</span> <span class="c1"># ji가 0인 경우 데이터에는 0으로 되어 있으나, 주소에 -0 이 나타나지 않게끔
</span>    <span class="n">df_temp</span><span class="p">[</span><span class="s">'{}'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'useQty'</span><span class="p">]</span>
    <span class="n">df_temp</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'address'</span><span class="p">])</span>  <span class="c1"># 주소가 중복인 항들은 전부 제거 (중복인 항들은 에너지 사용량이 모두 동일 수치인 것 확인함)
</span>        
    <span class="nf">if</span><span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df_temp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">df</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"outer"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"address"</span><span class="p">)</span> <span class="c1"># 한 월에 대해서라도 사용량 있는 주소는 모두 포함하므로 outer
</span>    
    <span class="k">del</span> <span class="n">data</span><span class="p">,</span> <span class="n">df_temp</span>
    
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    
<span class="c1"># 모든 월에 대해 join되었으므로 주소텍스트와 주소코드를 나눔    
</span><span class="n">df</span><span class="p">[</span><span class="s">'addresstxt'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 표제부에서 사용하는 주소 string과 같음
</span><span class="n">df</span><span class="p">[</span><span class="s">'sigunguCd'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'bjdongCd'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'bun'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'ji'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">del</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s">'addresstxt'</span><span class="p">,</span><span class="s">'sigunguCd'</span><span class="p">,</span><span class="s">'bjdongCd'</span><span class="p">,</span><span class="s">'bun'</span><span class="p">,</span><span class="s">'ji'</span><span class="p">,</span><span class="s">'elec_202201'</span><span class="p">,</span><span class="s">'elec_202202'</span><span class="p">,</span><span class="s">'elec_202203'</span><span class="p">,</span><span class="s">'elec_202204'</span><span class="p">,</span><span class="s">'elec_202205'</span><span class="p">,</span><span class="s">'elec_202206'</span><span class="p">,</span><span class="s">'elec_202207'</span><span class="p">,</span><span class="s">'elec_202208'</span><span class="p">,</span><span class="s">'elec_202209'</span><span class="p">,</span><span class="s">'elec_202210'</span><span class="p">,</span><span class="s">'elec_202211'</span><span class="p">,</span><span class="s">'elec_202212'</span><span class="p">,</span><span class="s">'gas_202201'</span><span class="p">,</span><span class="s">'gas_202202'</span><span class="p">,</span><span class="s">'gas_202203'</span><span class="p">,</span><span class="s">'gas_202204'</span><span class="p">,</span><span class="s">'gas_202205'</span><span class="p">,</span><span class="s">'gas_202206'</span><span class="p">,</span><span class="s">'gas_202207'</span><span class="p">,</span><span class="s">'gas_202208'</span><span class="p">,</span><span class="s">'gas_202209'</span><span class="p">,</span><span class="s">'gas_202210'</span><span class="p">,</span><span class="s">'gas_202211'</span><span class="p">,</span><span class="s">'gas_202212'</span><span class="p">]]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> <span class="c1"># 주소가 중복인 항들은 전부 제거 (중복인 항들은 에너지 사용량이 모두 동일 수치인 것 확인함)
</span>    
<span class="n">df</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>
</code></pre></div></div>

<p>filelist에 각 파일명을 미리 적어놓고, colname에 각 열 이름을 코드 내에서 어떻게 명시할 지 적어놓았다 (각 열에 대한 설명은, 같이 다운받을 수 있는 데이터셋_정의서 파일에 있다). 그리고 모든 데이터들을 반복문을 이용해 순서대로 불러온다.</p>

<p>파일 내에 건물 주소명이 기본적으로 시/구/번/지가 쪼개져 있는데, 표제부에서는 주소명이 합쳐져 있으므로 표제부 주소와 결합할 것을 상정하고 표제부와 같은 포맷이 되게, address 칼럼을 새로 만든다. address 같은 행들은 조사 결과 모두 같은 에너지 사용량 값들을 갖고 있어서, 단순 중복으로 간주하고 $\texttt{drop_duplicates}$로 삭제하였다.</p>

<p>이렇게 address 칼럼을 각 데이터셋에 대해 만들고, 모든 데이터셋을 address 기준으로 outer join해 합친 데이터셋이 df가 되도록 하였다. Outer join을 한 이유는 한 개 데이터셋에라도 있는 건물은 우선 포함시키기 위함이다. 그리고 df에서 필요한 칼럼들만 남긴 후 csv 파일로 저장하였다. 2022년의 모든 월의 전기/가스 사용량들을 통합한 csv 파일을 열어보면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergyone/everymonth.png" alt="everymonth" class="align-center" /></p>

<p>어떤 건물들은 가스 사용량이 모든 월에 대해 없는데, 이는 해당 건물이 도시가스를 공급받지 않기 때문이다 (해당 건물 내 일부 부대시설(음식점 등)이 LPG 가스를 사용하거나 할 수는 있다).</p>

<p>다음으로, 모든 월의 에너지 사용량 통합 데이터를 표제부와 합치고 SQL DB로 저장한다.
표제부의 스크린샷은 아래와 같다 (건축데이터 민간개방 시스템 웹사이트에서 직접 캡쳐함).</p>

<p><img src="/assets/images/monthlyenergyone/pyoje_web_1.png" alt="pyoje_web_1" class="align-center" />
<img src="/assets/images/monthlyenergyone/pyoje_web_2.png" alt="pyoje_web_2" class="align-center" />
<img src="/assets/images/monthlyenergyone/pyoje_web_3.png" alt="pyoje_web_3" class="align-center" /></p>

<p>대한민국 내 모든 건물들에 대한 표제부를 한 번에 받을 수 있으며, 이는 수 GB의 텍스트 파일이다. 각 열의 설명은 같이 다운받을 수 있는 데이터구조 파일에 있다 (그런데 실제 데이터의 순서와 다른 경우도 있어서, 결국 직접 확인해야 했다…). 이 파일의 표제부 데이터를 위에서 만든 csv 파일 내 에너지 사용량 데이터와 합치고 SQL DB로 저장하는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">settings</span>

<span class="c1"># 각 column의 의미는 pyojedata 폴더의 데이터구조.xls 참고
</span><span class="n">colname</span> <span class="o">=</span> <span class="p">[</span><span class="s">'column_01'</span><span class="p">,</span> <span class="s">'column_02'</span><span class="p">,</span> <span class="s">'column_03'</span><span class="p">,</span> <span class="s">'column_04'</span><span class="p">,</span> <span class="s">'column_05'</span><span class="p">,</span> <span class="s">'addresstxt'</span><span class="p">,</span> <span class="s">'column_07'</span><span class="p">,</span> <span class="s">'bldgname'</span><span class="p">,</span> <span class="s">'sigunguCd'</span><span class="p">,</span> <span class="s">'bjdongCd'</span><span class="p">,</span> <span class="s">'column_11'</span><span class="p">,</span> <span class="s">'bun'</span><span class="p">,</span> <span class="s">'ji'</span><span class="p">,</span> <span class="s">'column_14'</span><span class="p">,</span> <span class="s">'column_15'</span><span class="p">,</span> <span class="s">'column_16'</span><span class="p">,</span> <span class="s">'column_17'</span><span class="p">,</span> <span class="s">'column_18'</span><span class="p">,</span> <span class="s">'column_19'</span><span class="p">,</span> <span class="s">'column_20'</span><span class="p">,</span> <span class="s">'column_21'</span><span class="p">,</span> <span class="s">'column_22'</span><span class="p">,</span> <span class="s">'column_23'</span><span class="p">,</span> <span class="s">'column_24'</span><span class="p">,</span> <span class="s">'column_25'</span><span class="p">,</span> <span class="s">'sitearea'</span><span class="p">,</span> <span class="s">'buildingarea'</span><span class="p">,</span> <span class="s">'coverageratio'</span><span class="p">,</span> <span class="s">'floorarea'</span><span class="p">,</span> <span class="s">'netfloorarea'</span><span class="p">,</span> <span class="s">'voltolotratio'</span><span class="p">,</span> <span class="s">'structureCd'</span><span class="p">,</span> <span class="s">'structure'</span><span class="p">,</span> <span class="s">'structuresub'</span><span class="p">,</span> <span class="s">'principaluseCd'</span><span class="p">,</span> <span class="s">'principaluse'</span><span class="p">,</span> <span class="s">'subuse'</span><span class="p">,</span> <span class="s">'roofCd'</span><span class="p">,</span> <span class="s">'roof'</span><span class="p">,</span> <span class="s">'roofsub'</span><span class="p">,</span> <span class="s">'num_household'</span><span class="p">,</span> <span class="s">'num_gagu'</span><span class="p">,</span> <span class="s">'column_43'</span><span class="p">,</span> <span class="s">'num_level'</span><span class="p">,</span> <span class="s">'num_level_below'</span><span class="p">,</span> <span class="s">'column_46'</span><span class="p">,</span> <span class="s">'column_47'</span><span class="p">,</span> <span class="s">'column_48'</span><span class="p">,</span> <span class="s">'column_49'</span><span class="p">,</span> <span class="s">'totalfloorarea'</span><span class="p">,</span> <span class="s">'column_51'</span><span class="p">,</span> <span class="s">'column_52'</span><span class="p">,</span> <span class="s">'column_53'</span><span class="p">,</span> <span class="s">'column_54'</span><span class="p">,</span> <span class="s">'column_55'</span><span class="p">,</span> <span class="s">'column_56'</span><span class="p">,</span> <span class="s">'column_57'</span><span class="p">,</span> <span class="s">'column_58'</span><span class="p">,</span> <span class="s">'column_59'</span><span class="p">,</span> <span class="s">'column_60'</span><span class="p">,</span> <span class="s">'approvaldate'</span><span class="p">,</span> <span class="s">'column_62'</span><span class="p">,</span> <span class="s">'column_63'</span><span class="p">,</span> <span class="s">'column_64'</span><span class="p">,</span> <span class="s">'column_65'</span><span class="p">,</span> <span class="s">'column_66'</span><span class="p">,</span> <span class="s">'column_67'</span><span class="p">,</span> <span class="s">'efficiencygrade'</span><span class="p">,</span> <span class="s">'efficiencyrate'</span><span class="p">,</span> <span class="s">'efficiencyscore'</span><span class="p">,</span> <span class="s">'greengrade'</span><span class="p">,</span> <span class="s">'greenscore'</span><span class="p">,</span> <span class="s">'column_73'</span><span class="p">,</span> <span class="s">'column_74'</span><span class="p">,</span> <span class="s">'column_75'</span><span class="p">,</span> <span class="s">'column_76'</span><span class="p">,</span> <span class="s">'column_77'</span><span class="p">]</span>

<span class="c1"># 표제부 불러오기
</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">PYOJE_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">pyojetable.txt'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">'|'</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'CP949'</span><span class="p">)</span>

<span class="c1"># 미리 netfloorarea에 대해 내림차순 정렬해서, 추후 같은 번지에 여러 건물이 있을 경우 중복제거 후 용도가 netfloorarea가 가장 큰 항목의 용도가 되게 함
</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s">'netfloorarea'</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># 중복주소들에 대해 값을 합칠 항목들 (연면적, 세대수 등) 을 합치기
</span><span class="n">data_tosum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s">"addresstxt"</span><span class="p">,</span><span class="s">"sitearea"</span><span class="p">,</span><span class="s">"buildingarea"</span><span class="p">,</span><span class="s">"floorarea"</span><span class="p">,</span><span class="s">"netfloorarea"</span><span class="p">,</span><span class="s">"num_household"</span><span class="p">,</span><span class="s">"num_gagu"</span><span class="p">]]</span>
<span class="n">data_tosum</span> <span class="o">=</span> <span class="n">data_tosum</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="s">'addresstxt'</span><span class="p">).</span><span class="nf">sum</span><span class="p">()</span> 

<span class="c1"># 중복주소들에 대해 값을 합치지 않을 항목들은 하나만 남김
</span><span class="n">data_todrop</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s">"addresstxt"</span><span class="p">,</span><span class="s">"structureCd"</span><span class="p">,</span><span class="s">"structure"</span><span class="p">,</span><span class="s">"structuresub"</span><span class="p">,</span><span class="s">"principaluseCd"</span><span class="p">,</span><span class="s">"principaluse"</span><span class="p">,</span><span class="s">"subuse"</span><span class="p">,</span><span class="s">"roofCd"</span><span class="p">,</span><span class="s">"roof"</span><span class="p">,</span><span class="s">"approvaldate"</span><span class="p">,</span><span class="s">"coverageratio"</span><span class="p">,</span><span class="s">"voltolotratio"</span><span class="p">,</span><span class="s">"num_level"</span><span class="p">]]</span>
<span class="n">data_todrop</span> <span class="o">=</span> <span class="n">data_todrop</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> 

<span class="c1"># 표제부 항목들을 outer join으로 합치기
</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">data_tosum</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">data_todrop</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"outer"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"addresstxt"</span><span class="p">)</span>

<span class="k">del</span> <span class="n">data_tosum</span><span class="p">,</span> <span class="n">data_todrop</span>

<span class="c1"># 월별 에너지 사용량 데이터 불러오기
</span><span class="n">energydata</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">)</span>

<span class="c1"># 표제부 항목들과 월별 에너지 사용량 데이터를 left join으로 합치기 (건물 속성 정보가 있는 경우에만)
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">data</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">energydata</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"left"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"addresstxt"</span><span class="p">)</span>

<span class="k">del</span> <span class="n">data</span><span class="p">,</span> <span class="n">energydata</span>

<span class="c1"># pandas df에서 생기는 기본 axis column 필요없으므로 삭제
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">drop</span><span class="p">([</span><span class="s">'Unnamed: 0'</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="s">'columns'</span><span class="p">)</span>

<span class="c1"># addresstxt가 null인 row들 없애기 (SQL에서 addresstxt에 대한 not null 제약 만족하도록)
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s">'addresstxt'</span><span class="p">])</span> 

<span class="c1"># addresstxt가 중복인 경우 하나만 남기고 없애기 (SQL에서 addresstxt에 대한 primary key 제약 만족하도록_
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> 
        
<span class="c1"># netfloorarea(용적률산정용연면적, 열인덱스 4)가 floorarea(연면적, 열인덱스 3)보다 큰 경우 잘못된 데이터이므로 수정: 
# 대지면적 * 용적률 이 계산되면서 그 값이 연면적보다 작으면 그 값을 쓰고,
# 대지면적 혹은 용적률이 누락되어 0이 나오거나 그 값이 연면적보다 크면 연면적을 씀
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">resultdata</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span> <span class="c1"># 연면적 &lt; 용적률산정면적 이면
</span>        <span class="k">if</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span> <span class="o">&lt;</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
            


<span class="c1"># CSV 파일로 저장
</span><span class="n">resultdata</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022_pyoje.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>

<span class="c1"># SQLite query 실행
</span><span class="kn">import</span> <span class="n">sqlite3</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">'db_monthlyenergy_pyoje.db'</span><span class="p">)</span>

<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">cursor</span><span class="p">()</span> 

<span class="k">with</span> <span class="n">conn</span><span class="p">:</span> 
    
    <span class="n">sql_create</span> <span class="o">=</span> <span class="s">"""
    create table monthlyenergy_2022_pyoje
    (addresstxt text primary key not null,
     sitearea numeric,
     buildingarea numeric,
     floorarea numeric,
     netfloorarea numeric,
     voltolotratio numeric,        
     principaluse text, 
     subuse text,
     principaluseCd integer,
     coverageratio numeric,
     num_household integer, 
     num_gagu integer, 
     structureCd integer,
     structure text,
     structuresub text,
     roofCd integer,
     roof text,
     roofsub text,
     num_level integer,
     approvaldate text,
     sigunguCd integer,
     bjdongCd integer,
     bun integer,
     ji integer,
     elec_01 numeric,
     elec_02 numeric,
     elec_03 numeric,
     elec_04 numeric,
     elec_05 numeric,
     elec_06 numeric,
     elec_07 numeric,
     elec_08 numeric,
     elec_09 numeric,
     elec_10 numeric,
     elec_11 numeric,
     elec_12 numeric,
     gas_01 numeric,
     gas_02 numeric,
     gas_03 numeric,
     gas_04 numeric,
     gas_05 numeric,
     gas_06 numeric,
     gas_07 numeric,
     gas_08 numeric,
     gas_09 numeric,
     gas_10 numeric,
     gas_11 numeric,
     gas_12 numeric
     )
    """</span>
    
    <span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">sql_create</span><span class="p">)</span>
    
<span class="n">resultdata</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="s">'monthlyenergy_2022_pyoje'</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">'replace'</span><span class="p">)</span>
</code></pre></div></div>

<p>에너지 사용량 데이터에서 중복 주소를 제거했기 때문에, 표제부에서도 중복주소는 제거해야 한다 (이 경우 주소가 primary key가 된다).</p>

<p>이 때 같은 지번주소 내에 여러 건물들이 있는 경우가 있는데, 대지면적이나 연면적 (모든 층의 바닥면적들의 합) 등의 칼럼들에 대해서는 모든 건물들의 값을 다 더하면 된다 (이는 코드 내 $\texttt{data_tosum}$ 변수 정의에서 $\texttt{groupby}$와 $\texttt{sum}$으로 구현함). 그러나, 건물용도 (근린생활/ 업무/ 판매/ 의료 등) 또는 층수 등은 합칠 수 없는데, 미리 $\texttt{sort_values}$ 함수를 이용해 연면적 기준으로 내림차순 정렬을 해 놓음으로써 주소 중복 제거 시 건물용도나 층수 등이 가장 연면적이 큰 건물 기준으로 결정되게 했다 (코드 내 $\texttt{data_todrop}$ 변수 정의에서 $\texttt{drop_duplicates}$로 구현함). 참고로 표제부의 여러 칼럼들 중 필요한 칼럼들만 가져오는 것도 여기에 반영되어 있다.</p>

<p>표제부의 주소 중복 제거를 처리한 후, 에너지사용량 csv 파일을 불러오고, 표제부와 에너지사용량을 주소 기준으로 outer join으로 합친다. 그 결과물인 resultdata dataframe을 SQL table로 만드는 create table 쿼리를 sqlite3 패키지와 to_sql 함수를 이용해 실행했다. (이 때 $\texttt{sqlite3.connect()}$ 안에 DB 이름 쓸 때 $\texttt{.db}$ 까먹는 실수를 하기 쉬운데 주의해야 함)</p>

<p>서울 소재 건물들에 대해 구성한 SQLite DB의 스크린샷들은 아래와 같다.</p>

<p><img src="/assets/images/monthlyenergyone/sql_1.png" alt="sql_1" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_2.png" alt="sql_2" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_3.png" alt="sql_3" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_4.png" alt="sql_4" class="align-center" /></p>

<p>서울 소재 건물들에 대한 DB 구성은 아래 코드를 통해 전체 SQLite DB로부터 서울 내 건물들 중 전기 사용량 및 연면적 값의 누락이 없는 행들만으로 table을 만들어 이를 별도의 DB 및 table로 저장하여 수행하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="c1"># SQLite DB로부터 서울 소재이며 월별 전기 및 용적률산정연면적 누락이 없는 데이터들만 df로 불러오기
</span>
<span class="n">your_query</span> <span class="o">=</span> <span class="s">"""
select * from monthlyenergy_2022_pyoje
where addresstxt like '서울특별시%'
and elec_01 not null
and elec_02 not null
and elec_03 not null
and elec_04 not null
and elec_05 not null
and elec_06 not null
and elec_07 not null
and elec_08 not null
and elec_09 not null
and elec_10 not null
and elec_11 not null
and elec_12 not null
and netfloorarea not null
and netfloorarea &gt; 0
"""</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">sqlite3</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">"db_monthlyenergy_pyoje.db"</span><span class="p">)</span> <span class="c1"># .db 까먹지 말 것
</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">cursor</span><span class="p">()</span>

<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>

    <span class="n">df_result</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">your_query</span><span class="p">).</span><span class="nf">fetchall</span><span class="p">())</span>
    <span class="n">df_result</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">.</span><span class="n">description</span><span class="p">]</span>  <span class="c1"># add column names to the table
</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>    

<span class="n">conn_export</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">"db_monthlyenergy_seoul.db"</span><span class="p">)</span>
<span class="n">df_result</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="s">'seoul_2022'</span><span class="p">,</span> <span class="n">conn_export</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">'append'</span><span class="p">)</span> <span class="c1"># 별도의 SQLite DB로 저장
</span>
<span class="n">df_result</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="s">'seoul_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>
</code></pre></div></div>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[필자에게 있어 각별한 데이터셋이 있다. (비주거용) 건축물 별 월별 에너지 사용량 데이터셋이다. 각지번 주소 단위의 개별 비주거용 건물별로 특정 월에 소비한 전기와 가스의 양을 kWh 단위로 기록한 데이터셋이다.]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 5) TD3, SAC를 통한 continuous control 도출</title><link href="http://localhost:4000/2023/04/reinforcefive.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 5) TD3, SAC를 통한 continuous control 도출" /><published>2023-04-19T00:00:00+09:00</published><updated>2023-04-19T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/reinforcefive</id><content type="html" xml:base="http://localhost:4000/2023/04/reinforcefive.html"><![CDATA[<p>저번 포스팅에서는 continuous control을 위한 기본적인 심층강화학습 방법, Deep Deterministic Policy Gradient (DDPG) 를 적용해 보았다. 놀랍게도(?) 이 시리즈에서 다루는 마이크로그리드 문제에서는, DDPG가 Deep Q-learning (discrete action 3개) 대비 더 나은 결과를 보이지 못했다.</p>

<p>Continuous control 학습에 대해 더 진보된 방법을 쓴다면 어떨까? 진보된 방법들의 대표 사례들로, <a href="https://arxiv.org/abs/1802.09477">Twin Delayed Deep Deterministic policy gradient (TD3)</a>와 <a href="https://arxiv.org/abs/1812.05905">Soft Actor-Critic (SAC)</a>이 있다.</p>

<p><br /></p>
<h2 id="td3">TD3</h2>

<p>TD3가 DDPG와 비교해 갖는 차이점은 대략 아래와 같다 (항상 그렇지만 상세한 내용은 논문 원문을 참고하자).</p>

<ul>
  <li>critic 신경망 한 개가 아닌 두 개를 사용함. 그리고 $Q(s_{t+1},a_{t+1})$을 두 개의 target critic 신경망 각각에 대해 계산하고 그 중 ‘더 작은 값’을 사용함. 마찬가지로 actor 훈련시의 목적함수 내 $Q(s_{t},a_{t})$ 또한 두 critic 신경망 각각에 대해 계산하고 그 중 ‘더 작은 값’을 사용함. 이를 통해 Q-learning 특유의 overestimation 문제를 경감할 수 있음.</li>
  <li>$a_{t+1}$을 결정 시 actor의 결과를 그대로 쓰는 게 아니라, clipped noise를 추가하여 smoothing regularization 효과를 얻음.</li>
  <li>Critic이 두 번 업데이트될 동안 actor는 한 번 업데이트됨, 이러한 `delayed’ policy update를 통해 value estimation의 variance를 줄임.</li>
</ul>

<p>TD3 훈련 코드는 아래와 같다. 코드 내 주석은 지난 포스팅의 DDPG 코드 대비 다른 부분에 대해서만 추가하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="n">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Conv1D</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">actor_lr</span> <span class="o">=</span> <span class="mf">0.0001</span> 
<span class="n">critic_lr</span> <span class="o">=</span> <span class="mf">0.0002</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
<span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">clippednoise_std</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># clipped noise를 생성하는 평균이 0인 정규분포의 표준편차
</span><span class="n">clippednoise_interval</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># clipped noise의 구간 설정
</span><span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)</span>
<span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)</span> 

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)</span>
<span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)</span>

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span>

<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Critic</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>          
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_action</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_qval</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_qval</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>    
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_action</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_action</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">):</span>       
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span>

<span class="n">critic_one_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">critic_two_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> <span class="c1"># Critic NN을 2개 사용함
</span><span class="n">critic_two_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> <span class="c1"># 두 번째 critic NN의 target net
</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">actor_learning</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_target</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>



<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">epsilon</span> <span class="ow">and</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
   
    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="o">-</span><span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span>
    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span>   
    
    <span class="c1">#p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span>
    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span>
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span>
    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span>



<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">clippednoise_std</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="o">-</span><span class="n">clippednoise_interval</span><span class="p">,</span> <span class="n">clippednoise_interval</span><span class="p">)</span>
    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="nf">actor_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">).</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span> <span class="c1"># clipped noise 추가 (smoothing 효과 얻음)
</span>    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">actions_by_target</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># clipped noise를 추가하더라도 action이 [-1,1] 범위에 들게 제한
</span>    
    <span class="n">Q_values_one_by_target</span> <span class="o">=</span> <span class="nf">critic_one_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_two_by_target</span> <span class="o">=</span> <span class="nf">critic_two_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span> <span class="c1"># 두 번째 critic net을 사용해서 nextstate에 대한 Q-value 계산
</span>    <span class="n">Q_values_min_by_target</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one_by_target</span><span class="p">,</span> <span class="n">Q_values_two_by_target</span><span class="p">)</span> <span class="c1"># 두 Q-value들 중 작은 값을 사용 (over-estimation 문제 완화)
</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">stop_gradient</span><span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="n">Q_values_min_by_target</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
        <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">loss_critic_one</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Q_values_one</span><span class="p">))</span> 
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_one</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span> 
    <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
        <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">loss_critic_two</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">))</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_two</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">actorupdate</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>    
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
            <span class="n">actions_by_learner</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">)</span>
            <span class="n">loss_actor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="o">-</span><span class="n">Q_values_min</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_actor</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">actor_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
        
        <span class="n">actor_weights</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_actor_weights</span> <span class="o">=</span> <span class="n">actor_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">actor_weights</span><span class="p">)):</span>
            <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_actor_weights</span><span class="p">)</span>
        
        <span class="n">critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">critic_one_weights</span><span class="p">)):</span>
            <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_one_weights</span><span class="p">)</span>   
        <span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_two_weights</span><span class="p">)</span>



<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bool_fortrain</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> <span class="c1"># 시작시점
</span>    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span>
        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>  
        <span class="n">epsilon</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">epoch</span> <span class="o">/</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>     

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> 
                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="n">bool_fortrain</span><span class="p">)</span>
                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bool_fortrain</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">bool_fortrain</span>
                
                
    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> 
        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>
        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span>
            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span>
            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span>
            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">actor_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'actor_trainedmodel_td3.h5'</span><span class="p">)</span>
            <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_one_trainedmodel_td3.h5'</span><span class="p">)</span>
            <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_two_trainedmodel_td3.h5'</span><span class="p">)</span>
                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>
<h2 id="sac">SAC</h2>

<p>SAC에서는 `stochastic’ actor를 가정한다. 즉 actor는 특정 확률분포로부터 action을 도출한다. $a_{t} \sim \pi_{\phi}(a|s_{t})$ 인 것이다. 보통 Actor의 직접적인 출력은 정규분포의 평균값 그리고 표준편차의 로그값이고, 이로부터 정의되는 정규분포로부터 샘플을 뽑거나 (training) 평균값을 (validation) 뽑는다. 만약 bounded action인 경우 tanh kernel을 추가해서 action을 결정한다. Stochastic actor를 쓰기 때문에, DQN/ DDPG/ TD3에서 그랬던 것처럼 hand-crafted noise를 따로 추가하지 않아도 자동으로 훈련 과정에서 exploration이 된다는 장점이 있다.</p>

<p>그리고 SAC에서는 신경망들을 훈련 시 `최대화’ 대상 목적함수에 entropy term $-\alpha \text{log} \pi_{\phi}(a|s_{t}) $ 이 추가된다 (로그확률값은 actor를 call 할 때 받아옴). 정보이론에서 Entropy는 음의 확률에 로그확률을 곱한 값이고 목적함수는 평균을 의미하므로 앞에 확률값이 생략된 것으로 보면 위 term은 entropy를 의미한다. Entropy가 클수록 해당 확률분포가 균등분포에 가까워지므로, 결과적으로 exploration을 장려하게 된다.</p>

<p>$\alpha$는 temperature parameter로, 클수록 entropy의 최대화에 가중치를 많이 줘서 균등분포에 더 가까워진다. SAC에서는 $\alpha$를 사전에 고정된 값으로 결정하지 않고, $\alpha$가 minimum expected entropy 조건 하의 return 최대화 문제의 dual problem의 Lagrangian multiplier임에 착안해 그 값을 변경해 나간다. 그러므로 $\alpha$의 초기값은 사용자가 결정하지만, 그 값은 훈련을 거치면서 지속적으로 수정된다. (역시 상세 내용은 논문 원문을 참고하자.)</p>

<p>SAC 훈련 코드는 아래와 같다 <a href="https://github.com/shakti365/soft-actor-critic">(코드 작성에 참고한 포스팅).</a> 코드 내 주석은 지난 포스팅의 DDPG 코드 대비 다른 부분에 대해서만 추가하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="n">tensorflow_probability</span> <span class="k">as</span> <span class="n">tfp</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="n">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Conv1D</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">alpha_lr</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># temperature parameter에 대한 learning rate
</span><span class="n">actor_lr</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">critic_lr</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">alpha_initial</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># temperature parameter의 초기값
</span><span class="n">target_entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="nf">constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># 1은 DoF of action
</span><span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># SAC가 reward scale에 민감하므로 잘 선택해야 함: reward가 너무 낮으면 너무 exploration만 해버리고, reward가 너무 높으면 처음엔 학습이 빨리 되는 것 같아 보이지만 poor local minima로 수렴함이 알려짐
</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>
<span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>  

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>
<span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span> 

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span>

<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Critic</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>         
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_action</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_qval</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_qval</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>       
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_action_mean</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span> <span class="c1"># 정규분포의 평균
</span>        <span class="n">self</span><span class="p">.</span><span class="n">output_action_stddev</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span> <span class="c1"># 정규분포의 표준편차
</span>        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_action_mean</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">output_action_stddev</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>        
        <span class="n">mu</span><span class="p">,</span> <span class="n">logsigma</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span> <span class="c1"># 정규분포의 평균, 로그표준편차
</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">logsigma</span><span class="p">)</span> <span class="c1"># 로그표준편차를 표준편차로 변환
</span>        <span class="n">dist</span> <span class="o">=</span> <span class="n">tfp</span><span class="p">.</span><span class="n">distributions</span><span class="p">.</span><span class="nc">Normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="c1"># 정규분포 정의
</span>        <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="c1"># Training 시
</span>            <span class="n">action_temp</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="nf">sample</span><span class="p">()</span> <span class="c1"># 정규분포로부터 임의로 샘플 뽑아서 action 결정 
</span>        <span class="k">else</span><span class="p">:</span> <span class="c1"># Validation 시
</span>            <span class="n">action_temp</span> <span class="o">=</span> <span class="n">mu</span> <span class="c1"># Validation 시에는 mean action으로 (deterministic action)
</span>        <span class="n">action</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">action_temp</span><span class="p">)</span> <span class="c1"># tanh activation function을 이용한 bounded action 구현
</span>        <span class="n">logprob_temp</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="nf">log_prob</span><span class="p">(</span><span class="n">action_temp</span><span class="p">)</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">logprob_temp</span> <span class="o">-</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_sum</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">action</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-16</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                         <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># log-probability 반환
</span>        <span class="k">return</span> <span class="n">action</span><span class="p">,</span> <span class="n">logprob</span>
        

<span class="n">critic_one_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">critic_two_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_two_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span> 

<span class="n">actor_learning</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_target</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">alpha</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Variable</span><span class="p">(</span><span class="n">alpha_initial</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># temperature parameter 정의
</span><span class="n">alpha_optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">alpha_lr</span><span class="p">)</span>

<span class="n">actor_weight_temp</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
<span class="n">critic_one_weight_temp</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
<span class="n">critic_two_weight_temp</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>


<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="n">action</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">.</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
        
    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="o">-</span><span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span>
    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span>
        
    <span class="c1"># p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span>
    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
            <span class="c1"># p_curtail = (energy_batt + p_net_beforebatt*eff_batt - capa_batt)/eff_batt 
</span>    <span class="k">else</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span>
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span>
    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span>



<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">actions_by_target</span><span class="p">,</span> <span class="n">logprobs_actions_target</span> <span class="o">=</span> <span class="nf">actor_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">)</span><span class="c1"># action 뿐 아니라 로그확률도 불러옴, 로그확률은 entropy term에 사용됨
</span>    
    <span class="n">Q_values_one_by_target</span> <span class="o">=</span> <span class="nf">critic_one_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_two_by_target</span> <span class="o">=</span> <span class="nf">critic_two_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_min_by_target</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one_by_target</span><span class="p">,</span> <span class="n">Q_values_two_by_target</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">stop_gradient</span><span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">Q_values_min_by_target</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">logprobs_actions_target</span><span class="p">))</span> <span class="c1"># entropy term이 추가됨됨
</span>    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1">#
</span>        <span class="n">loss_critic_one</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Q_values_one</span><span class="p">))</span> 
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_one</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">loss_critic_two</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Q_values_two</span><span class="p">))</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_two</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">actorupdate</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>    
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
            <span class="n">actions_by_learner</span><span class="p">,</span> <span class="n">logprobs_actions</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">)</span>
            <span class="n">loss_actor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">logprobs_actions</span> <span class="o">-</span> <span class="n">Q_values_min</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_actor</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">actor_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
        
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> <span class="c1"># temperature parameter의 업데이트
</span>            <span class="n">actions_by_learner</span><span class="p">,</span> <span class="n">logprobs_actions</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">loss_alpha</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">logprobs_actions</span><span class="o">+</span><span class="n">target_entropy</span><span class="p">))</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_alpha</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span><span class="p">])</span>
        <span class="n">alpha_optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]))</span>
        
        <span class="n">actor_weights</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_actor_weights</span> <span class="o">=</span> <span class="n">actor_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">actor_weights</span><span class="p">)):</span>
            <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_actor_weights</span><span class="p">)</span>
        
        <span class="n">critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">critic_one_weights</span><span class="p">)):</span>
            <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_one_weights</span><span class="p">)</span>    
        <span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_two_weights</span><span class="p">)</span>    



<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bool_fortrain</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span>
        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>      
        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>     

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> 
                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="n">bool_fortrain</span><span class="p">)</span>
                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bool_fortrain</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">bool_fortrain</span>                                   
                <span class="n">actor_weight_temp</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                <span class="n">critic_one_weight_temp</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                <span class="n">critic_two_temp</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                    
    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>
        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span>
            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span>
            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span>   
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span>
            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">actor_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'actor_trainedmodel_sac.h5'</span><span class="p">)</span>
            <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_one_trainedmodel_sac.h5'</span><span class="p">)</span>
            <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_two_trainedmodel_sac.h5'</span><span class="p">)</span>
                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'Temperature parameter 값은 {}입니다.'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">.</span><span class="nf">numpy</span><span class="p">()))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>SAC 훈련에서 주의할 점은, 가끔 $\alpha$가 NaN이 되기도 한다는 것이다. 솔직히 아직은 이유를 모르겠다… 사실 이 부분은 100% 이해를 한 게 아니라서 위 reference page에서 한 방식을 그대로 쓴 것이다. 아무튼 NaN이 되면 더 이상 훈련이 되지 않으니, learning rate를 더 줄이거나 한 후 처음부터 다시 훈련을 시켜야 한다.</p>

<p><br /></p>

<h2 id="결과">결과</h2>

<p>결과를 보면, TD3에서도 여전히 DDPG처럼 일부송전/일부수전 이 있으며, 낮에 송전하는 기간에 쭉 최대송전에 가깝게 하지 않고 송전량을 줄였다가 다시 늘리는 패턴이 보인다. 한편 SAC의 경우 최대송전과 최대수전까지 가는 경우가 거의 없다.</p>

<p>(그림)</p>

<p>TD3와 SAC로 훈련 시 validation case에 대한 누적 비용은 각각 85유로, 118유로이다. 이는 DDPG (125유로) 보다는 조금 나은 결과지만, 여전히 Deep Q-learning (50유로) 에 뒤진다.</p>

<p>해당 마이크로그리드 case에서는 LP solution에서의 action이 엄밀히는 continuous지만 거의 discrete에 가까운 모습이기 때문에, action을 state의 continuous function으로 근사하는 DDPG/ TD3/ SAC보다는 discrete function으로 근사하는 DQN이 더 나은 것으로 추정된다. 심지어 이는 시뮬레이션에서 계산되는 누적비용 측면에서만 생각한 것이며, 계산 시간까지 고려하면 DQN의 계산 효율 (computational efficiency) 이 훨씬 높다.
(계산 시간을 비교해 보여주는 그래프 또는 표)</p>

<p>실제로 에너지기술연구원에서 히트펌프 제어기를 심층강화학습으로 훈련시킨 연구에서도, SAC 기반 continuous control 대신 DQN으로 discrete control을 한 것으로 알려져 있다 (히트펌프의 경우 여러 대를 설치 후 매 시간별로 몇 대나 가동할 것이냐를 결정하는 discrete control이 가능하기도 하다).</p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/L9Ye1gALFAk" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p><br /></p>

<h2 id="나가며">나가며</h2>

<p>데이터 사이언스에서 ‘Data Generating Process (DGP)에 맞는 방법을 써라’ 라는 격언이 있는데, 이번 사례도 이와 유사한 교훈을 주는 사례인 것 같다.</p>

<p>미래를 모두 안다는 가정 하에 선형계획법으로 얻은 optimal solution에서의 action이 discrete action과 상당히 유사함을, 강화학습 계산 전이 미리 알 수 있었다. 그렇다면 이 문제에 있어 더 맞는 강화학습 방법은 discrete control 방법이며, 굳이 continuous control 방법을 시도해도 discrete 대비 더 나은 결과를 얻지 못하는 것이 놀랍지 않은 것이다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[저번 포스팅에서는 continuous control을 위한 기본적인 심층강화학습 방법, Deep Deterministic Policy Gradient (DDPG) 를 적용해 보았다. 놀랍게도(?) 이 시리즈에서 다루는 마이크로그리드 문제에서는, DDPG가 Deep Q-learning (discrete action 3개) 대비 더 나은 결과를 보이지 못했다.]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 4) DDPG를 통한 continuous control 도출</title><link href="http://localhost:4000/2023/04/reinforcefour.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 4) DDPG를 통한 continuous control 도출" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/reinforcefour</id><content type="html" xml:base="http://localhost:4000/2023/04/reinforcefour.html"><![CDATA[<p>저번 포스팅에서는 마이크로그리드에 discrete action 기반의 심층강화학습을 적용해 과거 시점의데이터 기반으로 control을 결정하는 방법을 알아보았다. 그러나 실제로는 continuous action이므로, continuous action을 다루는 심층강화학습 기법을 적용해본다. 이번에는 continuous control의 기본적인 방법인 <a href="https://arxiv.org/abs/1509.02971">Deep Deterministic Policy Gradient (DDPG)</a>를 적용한다.</p>

<p><br />
Continuous action인 경우 가능한 action의 수가 사실상 무한대이므로, Deep Q-learning에서처럼 state를 입력받아 각 action 별 Q-value를 모두 계산하는 신경망을 구성할 수는 없다.</p>

<p>대신에, 두 개의 신경망을 구성하되 하나는 state를 입력받고 continuous action의 값을 출력하고, 다른 하나는 state와 action을 입력받아 그 state-action pair의 Q-value를 출력하도록 한다. 두 신경망 중 전자를 actor (action을 결정함), 후자를 critic (value를 평가함) 이라 부른다. 이 때 actor는 state를 받고 deterministic한 action을 출력하는 policy로 볼 수 있다. 그래서 이 방법에는 Deep Deterministic Policy Gradient (DDPG) 라는 이름이 붙었다.</p>

<p>특히 이 case의 action은 하한이 -1.1, 상한이 1.1로 정해진 bounded action이다. 이를 구현하기 위해, actor의 output layer에 tanh activation function을 걸어준다.</p>

<p>(원래 actor와 critic과는 별개로 target network, nextstate에 대한 값을 target net에서 추출, 처음엔 복제본으로 시작, slowly updated, 안정성 향상)</p>

<p>훈련 시 critic의 목적함수는 이전 포스팅의 DQN처럼 $\hat{Q}(s_{t},a_{t})$와 $r_{t+1} + \gamma \text{max}_{a_{t+1}} \hat{Q}(s_{t+1},a_{t+1})$ 간 차이의 평균제곱합이다. 한편 actor의 목적함수는 $-\hat{Q}(s_{t},a_{t})$, 즉 음의 Q-value이다. Actor는 Q-value를 최대화하는 action을 도출해야 하기 때문이다. (보다 더 상세한 내용은 논문 원문을 참고하길 바란다)</p>

<p><br />
이제 DDPG를 적용하여 continuous controller를 훈련하는 코드를 보자 <a href="https://antonai.blog/reinforcement-learning-in-continuous-action-spaces-part-1-ddpg/">(해당 코드 작성에 참고한 DDPG 코딩 설명 포스트).</a> 코드 내 주석은 지난 포스팅의 DQN 코드 대비 다른 부분에 대해서만 추가하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="n">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Conv1D</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">actor_lr</span> <span class="o">=</span> <span class="mf">0.0005</span> <span class="c1"># actor NN의 learning rate
</span><span class="n">critic_lr</span> <span class="o">=</span> <span class="mf">0.001</span> <span class="c1"># critic NN의 learning rate
</span><span class="n">tau</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># target NN 업데이트 속도 조절 계수
</span><span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)</span> 
<span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)</span> 

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)</span>
<span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)</span>

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span>

<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span> <span class="c1"># Q-value를 추정하는 NN (action이 continuous)
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Critic</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span> <span class="c1"># tf.Keras.Model 상속받는 이유는 main코드에서 get_weights, set_weights 등을 매번 model 메서드를 불러오지 않고도 편하게 쓰기 위함          
</span>        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_action</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># action 값 (state 뿐 아니라 action도 input임)
</span>        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_qval</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_qval</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">):</span> <span class="c1"># state 뿐 아니라 action도 input임        
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">))</span> <span class="c1"># output은 입력된 state-action pair에 대한 Q-value '단일값'
</span>
<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span> <span class="c1"># (Continuous) Action을 결정하는 policy NN
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>        
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_action</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span> <span class="c1"># Node 갯수는 action의 자유도이며, tanh activation은 action(충/방전) 이 [-1,1] 범위의 bounded action임을 반영함
</span>        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_action</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">):</span> <span class="c1"># state가 input임        
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span>

<span class="n">critic_one_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> 
<span class="n">critic_one_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> <span class="c1"># target net
</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span> <span class="c1"># target net의 가중치를 learning net의 가중치와 같게 초기화
</span>
<span class="n">actor_learning</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_target</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span> <span class="c1"># target net
</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span> <span class="c1"># target net의 가중치를 learning net의 가중치와 같게 초기화
</span>


<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> 
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span> 
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span> 
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span> 
        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">epsilon</span> <span class="ow">and</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="c1"># exploration during training
</span>        <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># exploration 시 -1~+1 사이의 실수를 균등분포에서 추출
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># exploitation
</span>        <span class="n">action</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># action net의 output은 tensor이므로, 이를 numpy 변환 후 [0][0]으로 불러와야 int 변수가 됨
</span>    
    <span class="c1"># Unscaling
</span>    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span> <span class="c1"># 여기서 action은 전기 '수전'에 대해 양수라고 가정, action은 [-1,1] 구간의 실수이므로 prate_h2를 곱해 [-1.1,1.1] 구간의 실수가 되도록 함
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="o">-</span><span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span> <span class="c1"># action은 전기 '송전'에 대해 음수
</span>    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span> 
    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span> 
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span> 
        
    <span class="c1">#p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span> 
    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span> 
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
            <span class="c1"># p_curtail = (energy_batt + p_net_beforebatt*eff_batt - capa_batt)/eff_batt 
</span>    <span class="k">else</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span> 
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span> 
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span> 
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span> 
    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span> 
    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span>



<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="nf">actor_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">).</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># nextstate에 대한 action은 target net으로 도출
</span>    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">actions_by_target</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># [-1,1] 범위로 제한
</span>    
    <span class="n">Q_values_one_by_target</span> <span class="o">=</span> <span class="nf">critic_one_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span> <span class="c1"># nextstate에 대한 Q-value는 target net으로 도출
</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">stop_gradient</span><span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="n">Q_values_one_by_target</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> <span class="c1"># critic net 업데이트를 위한 자동미분 (actor net 업데이트와 별개로 둠)        
</span>        <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># critic_one_learning을 gradient descent로 훈련시키려면, GradientTape 구문 내에서 현재 state-action에 대한 Q_value Tensor를 critic_one_learning으로 다시 불러와야 함
</span>        <span class="n">loss_critic_one</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Q_values_one</span><span class="p">))</span> <span class="c1"># 평균제곱오차 계산
</span>    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_one</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span> 
    <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
     
    <span class="k">if</span> <span class="n">actorupdate</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>    
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> <span class="c1"># actor net 업데이트를 위한 자동미분 (critic net 업데이트와 별개로 둠)  
</span>            <span class="n">actions_by_learner</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span> <span class="c1"># actor_learning을 gradient descent로 훈련시키려면, GradientTape 구문 내에서 현재 state에 대한 action Tensor를 actor_learning으로 다시 불러와야 함
</span>            <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span> <span class="c1"># actor_learning으로 다시 불러온 action 기반으로 Q-value 계산
</span>            <span class="n">loss_actor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="o">-</span><span class="n">Q_values_one</span><span class="p">)</span> <span class="c1"># 음의 Q-value 최소화, 즉 Q-value를 최대화하도록 actor를 업데이트함
</span>        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_actor</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">actor_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
        
        <span class="n">actor_weights</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">weights</span> <span class="c1"># 원래 net의 weight 불러옴 (연산을 위해)
</span>        <span class="n">target_actor_weights</span> <span class="o">=</span> <span class="n">actor_target</span><span class="p">.</span><span class="n">weights</span> <span class="c1"># target net의 weight 불러옴
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">actor_weights</span><span class="p">)):</span> <span class="c1"># Target net 가중치 업데이트
</span>            <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_actor_weights</span><span class="p">)</span> <span class="c1"># 업데이트된 가중치로 설정
</span>        
        <span class="n">critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">weights</span> <span class="c1"># 원래 net의 weight 불러옴 (연산을 위해)        
</span>        <span class="n">target_critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_target</span><span class="p">.</span><span class="n">weights</span> <span class="c1"># target net의 weight 불러옴
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">critic_one_weights</span><span class="p">)):</span>  <span class="c1"># Target net 가중치 업데이트
</span>            <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>           
        <span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_one_weights</span><span class="p">)</span> <span class="c1"># 업데이트된 가중치로 설정  
</span>


<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bool_fortrain</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> 
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> 
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span> 
        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>  
        <span class="n">epsilon</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">epoch</span> <span class="o">/</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span> 
        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>     

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> 
                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="n">bool_fortrain</span><span class="p">)</span>
                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bool_fortrain</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">bool_fortrain</span> <span class="c1"># 한 번은 critic만, 한 번은 actor &amp; target까지 전부 업데이트하는 과정을 교대로 진행
</span>                
                
    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> <span class="c1"># 시작시점   
</span>        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>
        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span> 
            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span> 
            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span>    
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_ddpg.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span>
            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">actor_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'actor_trainedmodel_ddpg.h5'</span><span class="p">)</span>
            <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_one_trainedmodel_ddpg.h5'</span><span class="p">)</span>
                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_ddpg.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_ddpg.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_ddpg.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>(Critic 신경망 구성을 클래스로 정의, input에 action도 추가됨)</p>

<p>(Actor 신경망 구성을 클래스로 정의, 마지막 layer의 activation function이 tanh)</p>

<p>(Actor와 Critic, 그리고 ‘Target’ Actor와 Critic 정의. 여기서 Target 신경망은 원래 신경망의 복제본으로, ~~)</p>

<p>(Replay buffer, 이건 DQN과 동일함)</p>

<p>(시스템 시뮬레이션, Action으로는 Exploration을 위해 epsilon의 확률로 uniform distribution [-1,1] 로부터 추출된 값을 선택하고 나머지 확률로 Actor의 결과를 선택, 이 action 값에 1.1을 곱한 게 계통으로부터 받거나 계통으로 보내는 전력)</p>

<p>(Critic 훈련, 이 때 다음 시점의 action과 Q-value를 target 신경망으로 도출함에 주의)</p>

<p>(Actor 훈련, 이 때 tf.Gradient 안에서 action을 다시 도출해야 Gradient tape가 적용됨에 주의)</p>

<p>(Target 신경망 업데이트)</p>

<p>(training과 validation을 반복문으로 수행, DQN과 동일하게 첫 epoch는 replay buffer를 채우고 나머지 99 epoch 동안 24시간마다 training_step 실행)</p>

<p><br />
DDPG 훈련 결과, validation case에서의 누적 비용은 125유로이다. 놀랍게도(?) continuous control (DDPG) 의 결과가 3-action discrete control (DQN) 의 결과인 50유로보다 나쁘다. 어떻게 된 걸까?</p>

<p>아래 그림으로 action을 비교해 보자.</p>

<p>태양광 발전량이 많아 낮에 송전하는 기간의 밤 시간대에 LP와 DQN에선 action의 값이 0, 즉 idle이다. 그러나 DDPG에서는 수전을 한다. 반대로 태양광 발전량이 적어 낮에 수전하는 기간의 밤 시간대에도 LP와 DQN에선 action이 idle인데 DDPG에서는 일부 송전을 한다. 즉 LP와 DQN에서는 action이 수 시간 연속으로 idle인 기간에 DDPG에서는 송전 혹은 수전을 행한다. 그런데 이것이 sub-optimal control인 것으로 보인다.</p>

<p>(그림 -&gt; 원으로 표시해서 같이 보여주기)</p>

<p>이는 state를 input으로 하는 nonlinear continuous function을 근사했기 때문으로 보인다. Continuous function 근사 시, 대부분의 state에 대해 값이 0, -1, +1 셋 중 하나이고 그 외 일부 state에 대해서만 값이 -1~0 또는 0~1에 사이의 값을 출력하는 function을 (LP solution에서의 action처럼) 만들어내기는 어려울 것이다.</p>

<p>즉, 미래를 모두 안다고 가정했을 때의 ideal control은 DDPG로 도출한 control보다는 DQN으로 도출한 control에 더 가까운 형태를 띠기 때문에, DQN의 결과가 DDPG 대비 더 좋은 것으로 보인다.</p>

<p><br />
그러나 누군가는 이렇게 반박할 수 있다. “DDPG는 outdated 기법이다, TD3나 Soft Actor-Critic처럼 더 진보된 continuous control 방법들이 나왔다, 그걸 쓰면 다를 것이다.”
과연 어떨까? 다음 포스팅에서 확인해 보겠다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[저번 포스팅에서는 마이크로그리드에 discrete action 기반의 심층강화학습을 적용해 과거 시점의데이터 기반으로 control을 결정하는 방법을 알아보았다. 그러나 실제로는 continuous action이므로, continuous action을 다루는 심층강화학습 기법을 적용해본다. 이번에는 continuous control의 기본적인 방법인 Deep Deterministic Policy Gradient (DDPG)를 적용한다.]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 3) Deep Q-learning을 통한 discrete control 도출</title><link href="http://localhost:4000/2023/04/reinforcethree.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 3) Deep Q-learning을 통한 discrete control 도출" /><published>2023-04-17T00:00:00+09:00</published><updated>2023-04-17T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/reinforcethree</id><content type="html" xml:base="http://localhost:4000/2023/04/reinforcethree.html"><![CDATA[<p>이전 포스팅에서도 언급했듯, 이 문제에서 state는 직전 24시간 동안의 태양광 발전량과 부하 및 직전 1시간의 배터리 내 에너지양이고, action은 1.1kW 수전/ 1.1kW 송전/ idle 3가지이다. (action 인덱스는 0,1,2라 하자). 이 때 심층신경망은 state를 입력받아 3개 action 각각의 Q-value의 추정치 $\hat{Q}(s_{t},0), \hat{Q} (s_{t},1), \hat{Q} (s_{t},2)$ 를 출력으로 계산한다. 이 심층신경망은 매 훈련 주기마다 튜플 $(s_{t},a_{t},s_{t+1},r_{t+1})$ 의 batch를 받아서 업데이트된다.</p>

<p><br />
심층신경망 구성은 아래 그림과 같다.</p>

<p><img src="/assets/images/reinforcethree/nn.png" alt="nn" class="align-center" /></p>

<p>직전 24시간의 태양광 발전량은 첫 번째 Conv1D 층에, 직전 24시간의 부하는 두 번째 Conv1D 층에, 그리고 직전 1시간의 배터리 내 에너지양은 위 두 Conv1D층과 연결되는 Dense층에 바로 연결된다. 그리고 Dense층이 하나 더 있고, 이 층을 거쳐서 최종적으로 3개의 output node가 각 action별 Q-value를 출력한다.</p>

<p>해당 심층신경망 훈련을 위한 training set은 특정 2년 (17,520시간) 동안의 시간별 태양광발전량과 부하 자료이다. 해당 모델이 직전 24시간의 정보를 state로 사용하므로 control은 $t=25,26,\cdots, 17520$ 에 대해 정해진다. Validation set은 별도의 특정 1년 (8,760시간) 동안의 시간별 태양광 발전량과 부하 자료이다.</p>

<p>Training set에 대해서는 epsilon-greedy policy를, validation set에 대해서는 greedy policy를 적용해 action을 결정한다. 매 시간별로 에너지 흐름을 계산하고, 매 24시간 주기로 심층신경망 훈련을 gradient descent로 수행한다. 이를 training set의 17,520-24 시간에 대해 수행하면 1 epoch이다.</p>

<p><br />
이제 훈련 concept는 대략 이해가 될 것이니, 코드를 보자.</p>

<p>(이 코드는 본인이 직접 작성하였다. 마이크로그리드 케이스에 대한 학위논문에서 저자가 사용한 코드의 Github 링크를 제공하나, 각 모듈별로 코드 파일들을 지나치게 분리해 놓아 사용이 여의치 않았다. 이에 필자가 ‘모든 기능들을 한 파일에 넣은 공부용’ 코드를 따로 만들었다. 다만 코드 작성 시 <a href="https://product.kyobobook.co.kr/detail/S000001810262">핸즈온 머신러닝</a>의 강화학습 chapter의 Cartpole 예제에 대한 Deep Q-Network 코드를 많이 참고하였음을 밝힌다.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">lr</span><span class="o">=</span><span class="mf">0.005</span><span class="p">)</span> <span class="c1"># learning rate 너무 높으면 발산할 수 있음에 주의
</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
<span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)</span> <span class="c1"># [0,1] 구간 내로 scaled된 데이터임, unscaling은 play_one_step 함수 내에서 이루어짐
</span><span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)</span> 

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)</span> <span class="c1"># [0,1] 구간 내로 scaled된 데이터임, unscaling은 play_one_step 함수 내에서 이루어짐
</span><span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)</span>

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="c1"># 수전/송전 상한
</span><span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span> <span class="c1"># 수소-전기 변환효율
</span>
<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span> <span class="c1"># 배터리 용량 (겉보기용량 말고 SOC 상하한 고려한 실용량이라 가정)
</span><span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="c1"># 배터리 충방전 효율
</span><span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># epoch의 시작에서 배터리 내 에너지량 (최대저장가능량 대비 상대비율, Qval NN에는 이 상대비율이 입력되며, play_one_step 함수 내에서의 에너지시스템 밸런스 수식에서는 실제 에너지값으로 변환됨
</span>
<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="n">n_outputs</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">input_load</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 과거 24시간의 부하, shape의 두번째 숫자는 채널 수 (컬러사진의 RGB 등), 채널 수를 정의해야 Conv1D가 작동함
</span><span class="n">input_pv</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 과거 24시간의 태양광발전량
</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">input_load</span><span class="p">)</span>
<span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">input_pv</span><span class="p">)</span>
<span class="n">concat_conv</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">concat_conv</span><span class="p">)</span>
<span class="n">flatten_conv</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Flatten</span><span class="p">()(</span><span class="n">hidden_conv_concat</span><span class="p">)</span> <span class="c1"># Dense층 직전에 Conv층을 Flatten해야 함
</span><span class="n">input_others</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># 직전 시간의 배터리 내 에너지량
</span><span class="n">concat_all</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">([</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">input_others</span><span class="p">])</span> 
<span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">"relu"</span><span class="p">)(</span><span class="n">concat_all</span><span class="p">)</span>
<span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">"relu"</span><span class="p">)(</span><span class="n">hidden_dense_1</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="nc">Dense</span><span class="p">(</span><span class="n">n_outputs</span><span class="p">)(</span><span class="n">hidden_dense_2</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">output</span><span class="p">])</span>



<span class="k">def</span> <span class="nf">e_greedy_policy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">epsilon</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span> <span class="c1"># epsilon-greedy policy
</span>    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span> <span class="c1"># exploration
</span>        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># action을 랜덤하게 선택
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># exploitation
</span>        <span class="n">input_load</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Conv1D의 input이므로 채널 수 1 명시
</span>        <span class="n">input_pv</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">input_others</span> <span class="o">=</span><span class="n">state</span><span class="p">[(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Dense층의 input이므로 채널 수는 필요 없음
</span>        <span class="n">Q_values</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span> <span class="c1"># 각 action 별 Q-value 도출
</span>        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">argmax</span><span class="p">(</span><span class="n">Q_values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># 가장 큰 Q-value에 대응하는 action 선택      
</span>        <span class="c1"># 주의: for loop 안에서 DNN에 input을 입력해 output 계산 시 model()로 해야지, model.predict()로 하면 안 됨! 메모리 누수가 발생함 (model.predict는 대량의 input data를 'model.predict를 한 번만 호출해서' 처리하는 데 특화됨, https://www.tensorflow.org/api_docs/python/tf/keras/Model#predict 참고)
</span>


<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span> <span class="c1"># replay buffer 정의의
</span>
<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span> <span class="c1"># batch_size만큼의 경험들의 state들, action들, reward들, nextstate들의 리스트들을 반환
</span>    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span> <span class="c1"># replay buffer 내 경험들 중 랜덤하게 batch_size만큼의 경험들을 지정 (인덱스 불러옴)
</span>    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span> <span class="c1"># 위에서 불러온 인덱스를 이용해 batch_size 만큼의 경험들을 batch 리스트에 담음
</span>    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span> <span class="c1"># 하나의 array 안에 batch 내 각 경험별 값들이 들어감 
</span>        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span> <span class="c1"># 총 4개의 array를 반환, 각각은 (batch 내 sample경험들의) state들, action들, reward들, nextstate들의 리스트임
</span>    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="n">action</span> <span class="o">=</span> <span class="nf">e_greedy_policy</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">epsilon</span><span class="p">)</span> <span class="c1"># epsilon-greedy policy에 따라 action 도출
</span>    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 수소로 생산된 전기 수전
</span>        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span>
    <span class="k">elif</span> <span class="n">action</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># 수소 생산용 전기 송전
</span>        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="n">prate_h2</span>
       

    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span> <span class="c1"># 현재 시간의 부하 (action 결정 기준이 아님!), 입력자료가 [0,1]로 scaled된 걸 unscaling
</span>    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span> <span class="c1"># 현재 시간의 발전량 (action 결정 기준이 아님!), 입력자료가 [0,1]로 scaled된 걸 unscaling  
</span>    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span> <span class="c1"># 입력자료가 [0,1]로 scaled된 걸 unscaling
</span>    
    <span class="c1">#p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span> <span class="c1"># 태양광 생산, 부하 충족, H2 보내거나 받은 후 수용가 입장에서 전기에너지가 남으면 양수, 부족하면 음수
</span>    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 전기에너지가 남으므로 배터리에 저장하고, 만약 배터리도 꽉 찬다면 curtail함
</span>        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span> <span class="c1"># 배터리에 잔여 충전 가능한 에너지가 위에서 남은 에너지(에서 변환손실 제한 에너지) 이상일 경우
</span>            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># 남은 에너지를 배터리에 다 충전하면 꽉 차고도 남아서, curtail해야 함
</span>            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
            <span class="c1">#p_curtail = (energy_batt + p_net_beforebatt*eff_batt - capa_batt)/eff_batt # 괄호 안은 배터리 내부 기준이며, 수용가 모선 기준 양을 구하려면 eff_batt로 나눠줘야 함
</span>    <span class="k">else</span><span class="p">:</span> <span class="c1"># 전기에너지가 부족하므로 배터리 에너지를 써야 함, 배터리 에너지로도 부족하면 loss임
</span>        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span> <span class="c1"># 배터리 에너지로 충당 가능한 경우
</span>            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span> <span class="c1"># p_net_beforebatt가 음수이므로 마이너스값이 부족한 에너지'량'이고 그걸 '빼'므로 결과적으로 플러스
</span>        <span class="k">else</span><span class="p">:</span> <span class="c1"># 부족해 loss 발생
</span>            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span>
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span> <span class="c1"># 배터리 내 저장량을 [0,1] 범위로 scaling함
</span>    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span> <span class="c1"># replay buffer에는 scaled reward를 넣으며, tuple을 append함에 주의
</span>    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="c1"># scaled 배터리 내 저장량, unscaled reward, action index 반환
</span>


<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>

    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
      
    <span class="n">next_Q_values</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">))</span> <span class="c1"># Q-learning을 위해, 'next'state에서의 각 action 별 Q-value 추정치들 반환
</span>    <span class="n">max_next_Q_values</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">next_Q_values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 각 경험별로 nextstate에 대한 Q-value가 더 높은 행동의 Q-value 사용
</span>    <span class="n">target_Q_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="n">max_next_Q_values</span><span class="p">)</span> <span class="c1"># Q-value를 reward와 nextstate에 대한 Q-value(discounted)의 합으로 표현
</span>    <span class="n">target_Q_values</span> <span class="o">=</span> <span class="n">target_Q_values</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 뒤의 Q_values와 차원 맞춰줌
</span>    <span class="n">mask</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">one_hot</span><span class="p">(</span><span class="n">actions</span><span class="p">,</span> <span class="n">n_outputs</span><span class="p">)</span> <span class="c1"># 각 경험 별 action을 one-hot encoding 형태로 만들어줌 (각 행이 경험)
</span>    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> <span class="c1"># 자동 미분
</span>        <span class="n">all_Q_values</span> <span class="o">=</span> <span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span> 
        <span class="n">Q_values</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_sum</span><span class="p">(</span><span class="n">all_Q_values</span> <span class="o">*</span> <span class="n">mask</span><span class="p">,</span> <span class="c1"># mask를 곱해서, 각 경험별로 그 state에서 취하지 않은 action에 대해서는 Q-value에 0이 곱해지도록 함
</span>                                 <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># 각 행 별 합을 구함, 위의 masking 덕분에 그 state에서 취한 action에 대한 Q-value가 됨, keepdims를 True로 설정해 2차원 행렬 형태 유지
</span>        <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">target_Q_values</span><span class="p">,</span><span class="n">Q_values</span><span class="p">))</span> <span class="c1"># 평균제곱오차 계산
</span>    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span> <span class="c1"># loss 함수를 model의 trainable variables 전체에 대해 미분
</span>    <span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">model</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span> <span class="c1"># Adam optimizer로 parameter update 수행, zip으로 gradient와 parameter pair를 맞춰줌
</span>


<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>

<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span> 
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># 맨 첫 번째 epoch에서는 훈련을 시작하지 않고 buffer를 채움, 두 번째 epoch부터는 buffer에 sample들이 채워졌으므로 훈련함
</span>        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> <span class="c1"># 시작시점
</span>    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  <span class="c1"># 배터리 내 에너지의 초기값
</span>    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span> <span class="c1"># 데이터 내의 마지막 시점이 nextstate에만 포함될 때까지 (대신 termination state는 따로 없음)
</span>        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">epoch</span> <span class="o">/</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span> <span class="c1"># epsilon을 1에서 시작해 조금씩 선형적으로 줄임, 이 경우 초반에는 거의 다 exploration이므로 한 epoch가 매우 빨리 계산되나, 중반을 넘어가면 거의 exploitation이며 이 때 매 step마다 DNN을 call하므로 느려짐
</span>        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># energy_batt가 반복 갱신됨
</span>        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 다음 시간으로  
</span>
        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> <span class="c1"># 훈련 주기
</span>                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span> <span class="c1"># DNN 훈련을 위한 Gradient Descent 수행
</span>                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># return (각 시점별 수익의 총 합) 초기화
</span>        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> <span class="c1"># 시작시점   
</span>        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span> <span class="c1"># 배터리 내 에너지의 초기값
</span>        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span> <span class="c1"># 데이터 내의 마지막 시점이 nextstate에만 포함될 때까지 (대신 termination state는 따로 없음)
</span>            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># energy_batt가 반복 갱신됨
</span>            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span> <span class="c1"># 누적보상 계산
</span>            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c1"># 다음 시간으로    
</span>        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span> <span class="c1"># 각 epoch별 총 수익 로그 저장
</span>        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_dqn.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span> <span class="c1"># Validation set에서의 총 수익의 최대값값 갱신시마다 저장 (unlearn하게 되더라도 중간에 best performance였던 모델을 남김김)
</span>            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'trainedmodel_dqn.h5'</span><span class="p">)</span> <span class="c1"># 모델 가중치 저장
</span>                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_dqn.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># Validation case에서의 시간별 action 로그 저장
</span>                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_dqn.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># Validation case에서의 시간별 배터리 내 저장된 에너지 로그 저장
</span>                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_dqn.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span> <span class="c1"># 각 epoch별 소요시간 로그 장장
</span>            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>코드의 주요 부분은 다음과 같다.</p>

<p>(하이퍼파라미터들 설정 -&gt; 훈련이 안 될 경우 바꿔줌, 이를테면 learning rate를 너무 크게 하면 발산하므로 충분히 작게 해야 함)</p>

<p>(시스템 파라미터 및 데이터)</p>

<p>(심층신경망 정의)</p>

<p>(epsilon-greedy policy 수행: epsilon의 확률로 0,1,2 중 하나의 action을 완전 랜덤하게, 1-epsilon의 확률로 심층신경망의 계산 결과 중 가장 큰 값에 대응하는 action을 선택. 이 때 model.predict()가 아니라 model()을 써야 함에 주의. model.predict()를 쓰면 메모리 누수가 발생한다.)</p>

<p>(훈련 동안 $(s_{t},a_{t},s_{t+1},r_{t+1})$ 튜플들을 저장하는 replay buffer 정의)</p>

<p>(시스템 모델, 즉 매 시간별로 state를 알고 action을 결정했을 때 에너지시스템 내의 에너지 흐름을 계산하고, 그 결과인 손익 및 배터리 내 에너지 저장량을 계산함, 훈련 시 이를 replay buffer에도 저장함. 데이터가 미리 0~1 사이로 스케일링되어 있으므로 에너지 흐름 계산을 위해서는 unscaling해주며, replay buffer에 대한 tuple은 다시 scaled된 값으로 둠에 주의)</p>

<p>(심층신경망 훈련을 Gradient descent로 진행. 목적함수는 $\hat{Q}(s_{t},a_{t})$와 $r_{t+1} + \gamma \text{max}_{a_{t+1}} \hat{Q}(s_{t+1},a_{t+1})$ 간 차이의 평균제곱합임, input이 0~1 사이로 스케일된 데이터임에 주의)</p>

<p>(training과 validation을 반복문으로 수행, Exploration은 DQN에서는 e-greedy (epsilon 값을 1부터 시작해서 일정 수준까지 낮춤, 매 시간마다 train하면 1epoch 시간이 너무 길어지고 overfitting 우려도 있어, 매 24시간마다 훈련함, 첫 epoch는 replay buffer를 채우고 나머지 99 epoch 동안 훈련함, 1epoch 계산 시간이 긴 이유: 매 step별로 action 결정시마다 Qnet 또는 actor로 계산해야 하기 때문 (이를 8760x2-24번 해야 하므로), 심지어 validation set에 대한 metric 계산 시에도 마찬가지이므로 (여기서 또 8760-24번)</p>

<p><br />
훈련을 수행하면, validation case 기준으로 불과 몇 epoch만에 누적 비용이 200유로 이하로 줄어든다 (random control에서 누적비용이 2500~2700유로였음). 그리고 99 epoch 훈련 동안 validation case에 대해 가장 좋은 결과를 보인 모델의 경우 누적 비용이 27유로이다. Random control 대비해서, 이상적인 선형계획처럼 미래를 알 때의) control 시의 비용 -50유로에 근접했다. 과거 24시간 정보만 갖고 control한 것 치고는 훌륭해 보인다.</p>

<p>Action인 계통 수전/송전 패턴이 선형계획과 DQN에서 각각 어떻게 결정되었는지를 아래 그림과 같이 보자.</p>

<p>(그림)</p>

<p>대체로 비슷한 편임, LP 솔루션 기준으로 수전하는 시간대에 DQN 솔루션에서도 수전하고, LP에서 송전하는 시간대에 DQN에서도 송전하고, LP에서 idle인 시간대에 DQN에서도 idle임, LP는 continuous임에도 최대송전/최대수전/idle인 경우도 많다는 점이 특기할 만함. 그래도 송전/수전/idle의 지속시간은 차이가 있고, 이 3개 값이 아닌 다른 값인 경우도 분명히 존재함, 즉 최대량이 아닌 양으로 송전/수전하는 경우가 있음.</p>

<p><br />
그렇다면 discrete action으로 단순화하지 않고, -1.1에서 +1.1 사이의 실수로 action을 도출하는 continuous control을 위한 심층강화학습 기법을 쓰면, 이런 최대량이 아닌 송전/수전까지 반영한 controller를 훈련함으로써 validation case에 대해 더 낮은 비용을 달성하는 것도 가능할 것으로 기대된다.</p>

<p>다음 포스팅에서는 continuous control을 위한 심층강화학습 중 가장 기본적이면서 중요한 방법인 Deep Deterministic Policy Gradient (DDPG) 를 적용하는 방법 및 결과를 설명한다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[이전 포스팅에서도 언급했듯, 이 문제에서 state는 직전 24시간 동안의 태양광 발전량과 부하 및 직전 1시간의 배터리 내 에너지양이고, action은 1.1kW 수전/ 1.1kW 송전/ idle 3가지이다. (action 인덱스는 0,1,2라 하자). 이 때 심층신경망은 state를 입력받아 3개 action 각각의 Q-value의 추정치 $\hat{Q}(s_{t},0), \hat{Q} (s_{t},1), \hat{Q} (s_{t},2)$ 를 출력으로 계산한다. 이 심층신경망은 매 훈련 주기마다 튜플 $(s_{t},a_{t},s_{t+1},r_{t+1})$ 의 batch를 받아서 업데이트된다.]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 2) Q-learning 개념</title><link href="http://localhost:4000/2023/04/reinforcetwo.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 2) Q-learning 개념" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/reinforcetwo</id><content type="html" xml:base="http://localhost:4000/2023/04/reinforcetwo.html"><![CDATA[<p>지난 포스팅에서 태양광 기반 마이크로그리드의 누적 비용을 최소화하는 최적 control 문제를 소개했다. 이번 포스팅에서는 ‘매 시점별로 과거의 자료만을 갖고’ control하는 데 필요한 강화학습의 이론적 내용을 최대한 간단히 소개한다 (강화학습에 대한 상세 내용은 <a href="https://www.andrew.cmu.edu/course/10-703/textbook/BartoSutton.pdf">Sutton의 Introduction</a> 참고 바람)</p>

<p><br />
먼저 Q-learning을 간단히 되짚고 넘어가자. 어떤 환경에서 시점 t에 상태 $s_{t}$에 있고, 이 때 action $a_{t}$를 수행하면 보상 $r_{t+1}$을 받으면서 상태 $s_{t+1}$로 전이된다고 하자. 해당 학위논문의 에너지시스템 사례에서는 상태는 $t-N, t-(N-1), …, t-1$ 시점들의 태양광발전량과 부하 및 $t-1$시점의 배터리 내 에너지량들의 벡터로 두었고, action은 $p_{\text{import}}[t]-p_{\text{export}}[t]$이다. 보상은 계통으로 송전시의 수익 (양의 보상) 또는 계통으로부터 수전하거나 loss of load가 발생할 때의 비용 (음의 보상) 이다.</p>

<p>참고로 ESS의 충/방전은 계통 수전/송전 값이 결정되면 에너지 밸런스를 맞추도록 자동으로 결정된다고 가정한다. 이런 식으로 action의 자유도(degree of freedom)을 줄여야 실제 계산이 용이해진다.</p>

<p><br />
이 때 ‘미래의 보상들을 합친 누적 보상의 기대값’ $Q(s_{t},a_{t})$는 다음과 같다.</p>

<p>$ Q(s_{t},a_{t}) = \mathbb{E} [r_{t+1} + \gamma r_{t+2} + \gamma^2 r_{t+3} + \cdots] $</p>

<p>$\gamma$는 1보다는 작되 1에 가까운 양수로 discount factor이다. 이걸 곱하는 이유는 곱하지 않으면, 특정 시점에 반드시 끝나는 게 아닌 한 누적비용이 무한대가 되기 때문이다. Discount factor를 곱해줘야 누적비용이 유한한 값이 된다.</p>

<p>그런데 시점 $t+1$에 대해서도 미래 누적 보상의 기대값 $Q(s_{t+1},a_{t+1})$이 정의되므로, 위 식은 아래와 같이 쓸 수 있다.</p>

<p>$ Q(s_{t},a_{t}) = \mathbb{E} [r_{t+1} + \gamma Q(s_{t+1},a_{t+1}) ] $</p>

<p>이 관계를 이용해서, 각 state-action pair $(s_{t},a_{t})$에 대해 $\hat{Q}(s_{t},a_{t})$를 iterative하게 계산한다. 실제로는 $Q(s_{t},a_{t})$의 정확한 값을 모르니까 모든 state-action pair들에 대해 0으로 초기화하고, 시점 $t$에서 action을 결정해서 $t+1$로 넘어갈 때마다 아래와 같이 업데이트 한다.</p>

<p>$ \hat{Q}(s_{t},a_{t}) \leftarrow (1-\alpha) \hat{Q}(s_{t},a_{t}) + \alpha [r_{t+1} + \gamma \text{max}_{a_{t+1}} \hat{Q}(s_{t+1},a_{t+1})] $</p>

<p>여기서 $\alpha$는 작은 양수로, learning rate이다. 우변의 max는 상태 $s_{t+1}$에서 누적보상을 최대화하는 행동을 선택한다는 가정이 반영된 결과이다. 시뮬레이션을 계속 함에 따라 보상 $r_{t+1}$ 정보가 계속 반영되면서, $\hat{Q}(s_{t},a_{t})$이 점차 실제 $Q(s_{t},a_{t})$에 가까워짐이 알려져 있다. 이를 Q-learning이라 한다.</p>

<p>실제 수전량은 -1.1에서 +1.1 사이의 실수이지만 (마이너스값은 송전), 문제를 간단히 하기 위해 세 가지의 discrete action들로 구성된 action set을 가정한다. 1.1kW로 수전, 1.1kW로 송전, 수전도 송전도 하지 않음 (idle)이다. 각 action의 인덱스를 0,1,2라 하자.</p>

<p>그러면 매 시점별로 $\hat{Q}(s_{t},0)$, $\hat{Q}(s_{t},1)$, $\hat{Q}(s_{t},2)$ 중에서 최대값에 대응하는 action을 선택하면, 누적보상을 최대화하는 control이 될 것이다.</p>

<p><br />
그러나 ‘항상 $\hat{Q}$의 최대값에 대응하는 action 선택 (greedy policy)’ 은 controller 훈련을 끝낸 후 ‘validation 및 실 사용 시’에는 맞지만, ‘훈련 중’에는 조금 다르다.</p>

<p>학습 초기에 아무 것도 학습하지 않은 controller가, 여러 가지의 action</p>

<p>(탐색에 대한 epsilon-greedy policy 설명)</p>

<p><br />
지금까지 설명한 방법은 $s_{t}$가 discrete이고 그 수가 많지 않을 경우 각 state-action pair별 $\hat{Q}$값들을 담는 table을 만들어 그대로 적용할 수 있다. 이를테면 Gridworld 문제에서는 격자 수가 한정되어 있으므로 각 격자-이동(상하좌우) 별로 $\hat{Q}$값들을 따로 계산할 수 있다.</p>

<p>하지만 많은 경우 state가 continuous이거나, discrete라도 그 수가 매우 많다. 이 포스팅 시리즈에서 다루는 마이크로그리드 케이스에서도 마찬가지이다. State (직전 $N$시간 동안의 시간별 부하와 태양광 발전량, 그리고 배터리에 저장된 에너지)가 $2N+1$차원의 continuous vector이기 때문이다. 이런 경우 ‘모든 state 각각에 대해’ $\hat{Q}$를 계산한다는 것은 사실상 불가능하다.</p>

<p>만약 state-action pair와 Q값 간의 관계가 어떤 domain knowledge에 의해 명확하게 정의될 수 있다면, 해당 정의를 통해 $\hat{Q}$를 쉽게 계산할 수 있을 것이다. 그러나 이 케이스를 포함한 많은 경우, state-action과 Q값 간의 관계식을 어떤 explicit한 식으로 나타낼 수 있을 것이라 기대되지 않는다.</p>

<p>그렇다면, state를 입력으로 받고 각 action 별 $\hat{Q}$값을 출력으로 하는 심층신경망 (Deep Neural Network, DNN) 모델을 훈련하는 것이 현실적인 방법이다. 심층신경망은 계산비용은 매우 높지만, node 수가 충분하면 어떤 비선형 함수도 근사할 수 있기 때문에 nonlinear function approximator로 기능한다는 점을 이용하는 것이다.</p>

<p><img src="/assets/images/reinforcetwo/reinforcement_deep.png" alt="reinforcement_deep" class="align-center" /></p>

<p>이 심층신경망 모델은 매 훈련 주기 (꼭 매 시간은 아닐 수 있음) 마다 튜플 $(s_{t},a_{t},s_{t+1},r_{t+1})$ 의 batch를 받아서 업데이트된다. 업데이트 시 최소화 대상 목적함수는 $\hat{Q}(s_{t},a_{t})$와 $r_{t+1} + \gamma \text{max}_{a_{t+1}} \hat{Q}(s_{t+1},a_{t+1})$ 간 차이의 제곱이다. 이를 Deep Q-Network (DQN) 이라 한다.</p>

<p>다음 포스팅에서는 마이크로그리드 문제에 Deep Q-Network를 적용하는 과정과 결과에 대해 상세히 설명한다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[지난 포스팅에서 태양광 기반 마이크로그리드의 누적 비용을 최소화하는 최적 control 문제를 소개했다. 이번 포스팅에서는 ‘매 시점별로 과거의 자료만을 갖고’ control하는 데 필요한 강화학습의 이론적 내용을 최대한 간단히 소개한다 (강화학습에 대한 상세 내용은 Sutton의 Introduction 참고 바람)]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 1) 문제의식 및 케이스 소개</title><link href="http://localhost:4000/2023/04/reinforceone.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 1) 문제의식 및 케이스 소개" /><published>2023-04-15T00:00:00+09:00</published><updated>2023-04-15T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/reinforceone</id><content type="html" xml:base="http://localhost:4000/2023/04/reinforceone.html"><![CDATA[<p>에너지 시스템에서 재생에너지의 비중이 높아질수록, 당장 몇 시간 뒤의 발전량이 얼마일지도 모르고 그 불확실성도 큰 상황에서 지금 얼마만큼의 에너지를 저장하고 얼마만큼의 에너지를 계통으로부터 받을지 등을 `잘’ 결정하는 것이 어려워진다. 그렇지만 이를 ‘잘’ 결정해야, 장기적인 에너지 공급 비용 및 화석연료 사용량 등을 줄일 수 있다.</p>

<p>그런데 선형계획법 등 전통적인 최적화 기반 에너지시스템 스케줄링 관련 연구들에서는, 미래의 발전량과 부하를 정확히 알 경우의 control을 도출한다는 한계점이 있다 (실제로는 미래를 정확히 알 수 없음에도). 최적화문제의 변수들이 각 시간별 수전/ 충전/ 방전 등이라 할 때, 해당 문제의 제약조건들로 모든 시간에 대한 에너지 밸런스 제약이 포함된 상태에서 최적화를 수행하기 때문이다.</p>

<p>예시를 하나 들자. 벨기에 Liege 대학의 박사학위 논문 <a href="https://orbi.uliege.be/handle/2268/214216">‘Contributions to deep reinforcement learning and its applications in smartgrids’</a> 에서 연구대상으로 삼은 가상의 마이크로그리드 시스템은 아래와 같다.</p>

<p>Peak 2kW 수준의 전기부하가 있으며, 이 부하에 전력을 공급하는 수단으로는 Peak 12kW급 태양광 패널, 실용량 15kWh급 배터리 (충방전 효율은 80%), 그리고 부하에 연결된 계통이 있다.</p>

<p>(시스템 도식 그림)</p>

<p>이 문제에서는 특이하게도 계통 사이에 오갈 수 있는 전력이 1.1kW로 제한되어 있고, 이 계통을 통해 중앙형 수소연료전지 시스템으로부터 전기를 받거나, 역으로 전기를 보내서 중앙에서 그린수소를 생산하도록 할 수 있다. 이때 계통으로부터 전력을 받는 데 드는 비용은 해당 전기에너지 생산에 필요한 양만큼의 수소의 가격, 계통으로 잉여전력을 보낼 때의 수익은 해당 전기에너지로 만들 수 있는 양만큼의 수소의 가격이다. (이 논문의 가정에서는 수소 에너지 기준으로 1kWh 당 0.1유로이며 수소-전기 간 변환효율은 65%이므로, 보낼 때의 수익은 약 0.065유로/kWh, 받을 때의 비용은 약 0.154유로/kWh이다)</p>

<p>만약 태양광발전은 안 되고 배터리도 완방되어 있고 계통으로부터 1.1kW를 수전받음에도 부하를 충당하지 못할 경우, loss of load에 대한 큰 비용 2.0유로/kWh가 발생한다 (물리적인 피해는 없다고 가정하고 대신 이를 큰 비용으로 환산함). 그러므로 특정 시간에 잉여전력이 많더라도 이를 전부 송전해서 수소 가격만큼의 수익을 내려다가, 나중에 태양광 발전량이 부족해지면 큰 손실을 볼 수도 있으니 배터리 내 에너지 저장량을 적절히 유지해야 한다. 만약 잉여태양광전력이 너무 많아서 배터리 완충 + 계통으로 1.1kW 송전 시에도 전력이 남으면 이는 curtail(출력제한)되며 따로 수익을 내지는 않는다.</p>

<p>이 때 시간이 1, 2, …, T일 때, 모든 시간의 비용의 합을 최소화하는 계통으로부터의 수전/송전, 에너지저장장치의 충전/방전량을 결정하고자 한다. 최적화 문제는 아래와 같다.</p>

<p>Minimize $ \sum_{t=1}^{T} 0.154 p_{\text{import}}[t] - \sum_{t=1}^{T} 0.065 p_{\text{export}}[t] + \sum_{t=1}^{T} 2 p_{\text{loss}}[t] $</p>

<p>Subject to</p>

<p>$ p_{\text{load}}[t] = p_{\text{pv}}[t] + p_{\text{import}}[t] - p_{\text{export}}[t] + p_{\text{disch}}[t] - p_{ch}[t] + p_{\text{loss}}[t] - p_{\text{curtail}}[t]  \quad \forall t$</p>

<p>$ e_{\text{batt}}[t] = e_{\text{batt}}[t-1] + 0.8 p_{\text{ch}}[t] - p_{\text{disch}}/0.8 \quad \forall t,\,\, e_{\text{batt}}[0]=0  $</p>

<p>$ p_{\text{import}}[t] \leq 1.1, \,\, p_{\text{export}}[t] \leq 1.1 \quad \forall t$</p>

<p>위에서 load는 부하, pv는 태양광, import는 계통으로부터의 수전, export는 계통으로의 송전, disch는 배터리 방전, ch는 배터리 충전, loss는 전력 부족 시 loss of load, curtail은 전력 초과 시 출력제한, batt는 배터리이다. $p$는 전력, $e$는 저장된 에너지, $\mu$는 효율이다. $p_{\text{load}}[t]$와 $p_{\text{pv}}[t]$는 input data로써 주어져 있고, 나머지 nonnegative 변수들의 값을 결정한다.</p>

<p>(참고로 보통은 battery의 c-rate까지 고려해야 하겠으나, 해당 논문에서는 배터리가 순간적인 발전량 전부를 유입시킬 수 있다고 가정했으므로 c-rate는 고려하지 않았다.)</p>

<p>위 선형계획 문제를 Python에서 cvxopt 패키지와 glpk solver로 구성하고 푸는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">glpk</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span> <span class="c1"># 수소-전기 변환효율
</span>
<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span> <span class="c1"># 배터리 용량 (겉보기용량이 아닌, SOC 상하한 고려한 실용량이라 가정)
</span><span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="c1"># 배터리 충방전 효율
</span><span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># 수소에너지의 가격 (Euro/kWh)
</span><span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># loss of load penalty (Euro/kWh)
</span><span class="n">maxrate_h2</span> <span class="o">=</span> <span class="mf">1.1</span> <span class="c1"># 계통으로부터의 송전/ 계통으로의 수전 의 상한 (kW)
</span>

<span class="n">data_load</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"load_test.txt"</span><span class="p">)</span>
<span class="n">data_pv</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"pv_test.txt"</span><span class="p">)</span>
<span class="n">p_load</span> <span class="o">=</span> <span class="n">data_load</span><span class="p">[</span><span class="mi">24</span><span class="p">:]</span> <span class="o">*</span> <span class="n">load_peak</span>
<span class="n">p_pv</span> <span class="o">=</span> <span class="n">data_pv</span><span class="p">[</span><span class="mi">24</span><span class="p">:]</span> <span class="o">*</span> <span class="n">pv_peak</span>
<span class="n">t</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">p_load</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">spmatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">),</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_ones</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_batt</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span> <span class="o">-</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>


<span class="n">Aeq_balance</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)]])</span>
<span class="n">beq_balance</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">p_load</span><span class="o">-</span><span class="n">p_pv</span><span class="p">,</span><span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">)</span>

<span class="n">Aeq_batterydynamic</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="o">-</span><span class="n">eff_batt</span><span class="o">*</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">eff_batt</span><span class="p">],[</span><span class="nf">block_batt</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)]])</span>
<span class="n">beq_batterydynamic</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">lowerbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)]])</span> 
<span class="n">upperbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="n">maxrate_h2</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">maxrate_h2</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="n">capa_batt</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)]])</span> 

<span class="n">A_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="n">lowerbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">A_upperbound</span> <span class="o">=</span> <span class="nf">block_eye</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">b_upperbound</span> <span class="o">=</span> <span class="n">upperbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">c</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="n">price_h2</span><span class="o">*</span><span class="n">eff_h2</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="o">-</span><span class="n">price_h2</span><span class="o">/</span><span class="n">eff_h2</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="o">-</span><span class="n">cost_loss</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)]])</span>

<span class="n">Aeq</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">Aeq_balance</span><span class="p">,</span><span class="n">Aeq_batterydynamic</span><span class="p">])</span>
<span class="n">beq</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">beq_balance</span><span class="p">,</span><span class="n">beq_batterydynamic</span><span class="p">])</span>

<span class="n">A</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">A_lowerbound</span><span class="p">,</span> <span class="n">A_upperbound</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">b_lowerbound</span><span class="p">,</span> <span class="n">b_upperbound</span><span class="p">])</span>


<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">x</span><span class="o">=</span><span class="n">glpk</span><span class="p">.</span><span class="nf">lp</span><span class="p">(</span><span class="o">-</span><span class="n">c</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="n">beq</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="p">{</span> <span class="s">'msg_lev'</span><span class="p">:</span> <span class="s">'GLP_MSG_ON'</span><span class="p">})</span>
<span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="n">profit</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">print</span><span class="p">(</span><span class="n">profit</span><span class="p">)</span>
</code></pre></div></div>

<p>최적화 문제를 풀면 아래와 같은 최적 스케줄링을 구할 수 있다.</p>

<p>(그림)</p>

<p>특정 1년의 1월 2일~12월 31일에 대해 최적화 수행 시, 비용은 -50유로, 즉 누적해서 50유로의 수익을 낸다 (이는 다음 포스팅에서부터 소개할 강화학습에 대한 validation case이며, 왜 1월 2일부터인지는 다음 포스팅에서 설명함).</p>

<p>여기서 t=1일 때의 $p_{\text{export}}[1]$와 $p_{\text{import}}[1]$을 결정하는 데 $p_{\text{pv}}[1], p_{\text{pv}}[2], \cdots, p_{\text{pv}}[T]$ 즉 모든 시간의 태양광 발전량 값들 및 $p_{\text{load}}[1], p_{\text{load}}[2], \cdots, p_{\text{load}}[T]$ 즉 모든 시간의 부하 값들이 정보로 쓰인다. 즉 ‘미래를 정확히 아는 상황’ 이 된다. 그러나 이는 이상적인 가정에 의한 비현실적 결과다. $p_{\text{export}}[1]$와 $p_{\text{import}}[1]$을 결정하는 데 실제로 쓰이는 정보는 과거의 정보 즉 $p_{\text{pv}}[1], \cdots, p_{\text{pv}}[k-1], p_{\text{load}}[1], \cdots, p_{\text{load}}[k-1]$로 한정되어야 한다. 그러면 어떻게 해야 과거 정보만으로 ‘미래의 누적비용까지 고려한’ 최적의 control을 계산해낼 수 있을까?</p>

<p><br />
강화학습이라는 말은 아마 알파고의 학습 원리 등으로 들어보았을 것이다 (실제로 학습해 본 사람들은 아마 Cartpole이나 Gridworld 문제들 정도는 풀어봤을 수도 있다). 강화학습은 환경의 상태가 주어질 때 특정 행동을 함으로써 얻는 당장의 보상 뿐 아니라 미래 보상의 누적합의 기대값을 최대화할 수 있도록 행동을 정하는 policy를 도출하는 방법이다.</p>

<p><img src="/assets/images/reinforceone/reinforcement_basic.png" alt="reinforcement_basic" class="align-center" /></p>

<p>상태를 특정 N시간 전까지의 부하와 태양광 발전량, 행동을 제어로 보면 위에서 소개한 case에도 강화학습을 적용할 수 있다. 실제로 해당 학위논문에서는 계통으로부터의 송전/수전을 action으로 두고 Deep Q-learning을 적용하여 이러한 controller를 훈련했다. 물론 이 controller를 사용할 경우의 누적 비용은 선형계획법 결과대로 제어할 경우의 비용보다는 클 것이다. 그렇지만 적어도 random control보다는 훨씬 나은 성과를 낼 수 있을 것이다.</p>

<p>실제로 해당 학위논문의 에너지시스템 사례에 대해 수전을 플러스, 송전을 마이너스라 할 때 [-1.1,+1.1] 구간에 대한 uniform distribution을 가정해 all random으로 control을 한다면, validation case에서 비용은 대략 2500~2700유로 정도이다. 그러나 DQN으로 훈련시킨 controller를 쓰면 27유로로, LP 결과인 -50유로에 상당히 근접한 economic control이 된다.</p>

<p>다음 편에서는 해당 학위논문에 DQN을 적용한 사례를 상세히 소개한다.</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[에너지 시스템에서 재생에너지의 비중이 높아질수록, 당장 몇 시간 뒤의 발전량이 얼마일지도 모르고 그 불확실성도 큰 상황에서 지금 얼마만큼의 에너지를 저장하고 얼마만큼의 에너지를 계통으로부터 받을지 등을 `잘’ 결정하는 것이 어려워진다. 그렇지만 이를 ‘잘’ 결정해야, 장기적인 에너지 공급 비용 및 화석연료 사용량 등을 줄일 수 있다.]]></summary></entry><entry><title type="html">정수선형계획법 기반 분산에너지시스템 최적화 설명 - 4) 태양광과 배터리의 용량 정하기</title><link href="http://localhost:4000/2023/04/linprogfour.html" rel="alternate" type="text/html" title="정수선형계획법 기반 분산에너지시스템 최적화 설명 - 4) 태양광과 배터리의 용량 정하기" /><published>2023-04-14T00:00:00+09:00</published><updated>2023-04-14T00:00:00+09:00</updated><id>http://localhost:4000/2023/04/linprogfour</id><content type="html" xml:base="http://localhost:4000/2023/04/linprogfour.html"><![CDATA[<p>지난 포스팅에서는 `주어진 용량의’ 배터리가 건물에 설치된 경우의 시간별 최소비용 충/방전 스케줄을 구하기 위한 선형계획법 문제 수식 구성 및 코딩을 설명했다.</p>

<p>그런데, 실제로는 그 용량도 결정해야 한다. 그래서 이번 포스팅에서는 용량까지 결정하는 문제를 설명한다. 더불어, 건물에 배터리 뿐 아니라 태양광 패널도 설치해서 태양광+배터리 연계 시스템을 구축 시 각각의 용량을 결정하는 경우를 상정한다.</p>

<p><img src="/assets/images/linprogfour/system_pvbatt.png" alt="system_pvbatt" class="align-center" /></p>

<p><br />
이 때, 태양광과 배터리 용량까지 고려한 `최소비용’은 무엇을 의미할까? 태양광과 배터리에 들어가는 비용은 대략적으로 보면 초기투자비(설비비, 설치비 등), 그리고 설비의 수명이 다 할 때까지 매년 발생하는 유지보수비이다. 태양광과 배터리는 따로 연료를 필요로 하지는 않으므로 연료비는 없다. 한편 계통으로부터의 수전으로도 전기부하를 충족하므로, 전기요금은 매 시간별로 계속 발생한다.</p>

<p>그러므로, 이 문제는 `태양광과 배터리 시스템의 초기투자비, 시스템 수명 동안의 설비 유지보수비, 시스템 수명 동안의 전기요금’ 의 합을 최소화하는 변수 결정 문제가 된다. 예를 들어 시스템 운영 기간은 태양광의 수명 20년과 같고, 배터리의 수명은 10년이며 운영 시작 10년 후 같은 용량으로 재설치한다고 가정하자. 이 때, 대략적인 비용 구조는 아래와 같다 (실제 프로젝트에서는 더 상세할 수 있음).</p>

<div class="notice--info">

0년차: 태양광 초기투자비 + 배터리 초기투자비
<br />
1년차: 1년차의 1년치 전기요금 + 태양광 유지보수비 + 배터리 유지보수비
<br />
2년차: 2년차의 1년치 전기요금 + 태양광 유지보수비 + 배터리 유지보수비
<br />
$\vdots$
<br />
10년차: 10년차의 1년치 전기요금 + 태양광 유지보수비 + 배터리 유지보수비 + 배터리 재투자비
<br />
11년차: 11년차의 1년치 전기요금 + 태양광 유지보수비 + 배터리 유지보수비
<br />
$\vdots$
<br />
20년차: 20년차의 1년치 전기요금 + 태양광 유지보수비 + 배터리 유지보수비

</div>

<p><br />
위 비용들을 그냥 다 더하면 될까? 보통은 그렇지 않다. 시간에 따른 화폐가치 하락을 고려해야 하기 때문이다. 은행에서 이자율 3%의 예금을 든다면, 1년 후의 103만원은 현재의 100만원과 같은 가치로 볼 수 있는 것처럼 말이다. 혹시 아래 그림 같은 도식을 본 적 이 있는가?</p>

<p>(현가 설명 도식)</p>

<p>이런 도식을 봤다면 ‘총 현재가치’ (Net Present Value, NPV) 를 들어봤을 것이다. 그렇지 않더라도, 아마 ‘할인율을 $r$이라 할 때, $n$년 뒤의 화폐가치 기준 돈의 액수 $C$는 현재의 화폐가치로 환산하면 $c (1+r)^{-n}$이다’ 라는 내용을 어디서 비슷하게라도 들어봤을 것이다.</p>

<p>그러므로 $n$년차의 비용들을 현재가치(present value)로 환산하려면 $(1+r)^{-n}$을 곱해줘야 한다.</p>

<p><br />
위 내용들을 반영한 목적함수 ‘총 현재가치’ (Net Present Value, NPV) 는 하기와 같다.</p>

<p>$ c_{\text{pv}}^{\text{init}} s_{\text{pv}} + c_{\text{batt}}^{\text{init}} s_{\text{batt}} \left( 1 + \frac{1}{(1+r)^{10}} \right) + \sum_{n=1}^{20} \frac{ c_{\text{pv}}^{\text{mtn}} s_{\text{pv}} + c_{\text{batt}}^{\text{mtn}} s_{\text{batt}} + \sum_{t=1}^{8760} c_{\text{grid}}[t] p_{\text{grid}}[n,t] }{(1+r)^n} $</p>

<p>여기서 $s_{\text{pv}}$는 태양광(PhotoVoltaic)의 kW 단위 용량, $s_{\text{batt}}$는 배터리의 kWh 단위 용량, $c_{\text{pv}}^{\text{init}}$와 $c_{\text{batt}}^{\text{init}}$는 각각 태양광 1kW와 배터리 1kWh당 초기투자비 (initial), $c_{\text{pv}}^{\text{mtn}}$와 $c_{\text{batt}}^{\text{mtn}}$는 각각 태양광 1kW와 배터리 1kWh당 유지보수비 (maintenance), $p_{\text{grid}}[n,t]$는 $n$년차의 $t$번째 시간에서 전력계통으로부터 수전한 전기 양, $c_{\text{grid}}[t]$는 수전 전력의 1년 내 $t$번째 시간에서의 kWh당 전기요금이다 (일반용 건물의 전기요금이 시간대별로 달랐던 것을 기억하자).</p>

<p>여기서는 소개글이므로 편의상, 매년 유지보수비용은 일정하며 현재와 10년 뒤 배터리 초기투자 단가는 같다고 두었다 (이 역시 실제 프로젝트에서는 더 상세할 수 있음).</p>

<p><br />
한편 위 수식에서는 건물의 전기 사용량 요금은 반영했으나, ‘기본’ 요금은 반영하지 않았다. 기본요금은 해당 건물의 수전 에너지 총량과는 무관하게, 해당 건물의 최대 수요, 즉 해당 건물이 계통에 부담시키는 ‘peak’ 부하에 대해 매겨지는 요금으로 이해할 수 있다. <a href="https://cyber.kepco.co.kr/ckepco/front/jsp/CY/H/C/CYHCHP00203.jsp">(한전 설명 링크)</a> 지난 포스팅에서 예시로 든 <a href="https://cyber.kepco.co.kr/ckepco/front/jsp/CY/E/E/CYEEHP00102.jsp#">일반(을) 고압A 선택II 요금제</a>의 경우 기본요금이 8,320원/kW이다.</p>

<p><img src="/assets/images/linprogtwo/eleccosttable.png" alt="eleccosttable" class="align-center" /></p>

<p>해당 건물에 최대수요계가 설치되어 있지 않다면 계약전력을 기준으로 적용하고, 계약전력이 바뀔 일은 어지간해선 없다 (건물 개축이나 대규모 전자기기 설비 도입으로 수전 설비를 증설하거나 하지 않는 한). 그러므로 계약전력 기준 적용 시에는 어떤 경우에도 기본요금이 같다. 이 경우 상수인 기본요금을 굳이 목적함수에 포함시킬 필요는 없다. (마치 $x^2$를 최소화하는 $x$값이나, $x^2+1$을 최소화하는 $x$값이나 똑같이 0인 것과 같다)</p>

<p>하지만 해당 건물에 최대수요계가 설치되어 있다면 직전 12개월 중 가장 큰 최대수요전력 기반으로 기본요금을 적용한다. 매년 전기부하 사용 추이가 비슷하다고 가정하면, $n$년차의 기본요금은 대략적으로 $n$년차의 $p_{\text{grid}}[n,t]$ 중 $t$에 대한 최대값에 비례한다고 볼 수 있다. 이 경우 더 이상 기본요금은 상수가 아닌, 변수 $p_{\text{grid}}[n,t]$의 함수가 된다. 그러므로 기본요금을 목적함수에 포함되어야 한다.</p>

<p>그러므로 kW당 기본요금을 $c_{\text{grid}}^{\text{base}}$라 하면, 목적함수의 세 번째 항의 분자에 $ c_{\text{grid}}^{\text{base}} \text{max}{ p_{\text{grid}}[n,t] }$ 가 추가되어야 한다. (단, $\text{max} [p_{\text{grid}}[n,t]]$의 값을 최적화 계산에서 실제로 구하려면 새로운 변수 $q$를 도입한 추가적인 제약조건이 필요하며, 이는 포스팅 하단에서 따로 설명한다.)</p>

<p><br />
위에서 목적함수가 포함하는 시점들은 연도 $n=1,2,\cdots,20$, 그리고 각 연도 내의 시간 $t=1,2,\cdots,8760$이다. 그러므로, 에너지 밸런스 식도 아래와 같이 표현된다.</p>

<p>$ p_{\text{load}}[n,t] = p_{\text{grid}}[n,t] - p_{\text{ch}}[n,t] + p_{\text{disch}}[n,t] + s_{\text{pv}} p_{\text{pv}}[n,t]$
시간 인덱스 $t$ 뿐 아니라 연도 인덱스 $n$이 추가되었다. 여기서 맨 마지막에 추가된 항 $s_{\text{pv}} p_{\text{pv}}[n,t]$은 태양광 발전량이다. $p_{\text{pv}}[n,t]$는 `태양광 1kW’가 $n$년도의 $t$번째 시간에 발전하는 전력이고, 여기에 용량 $s_{\text{pv}}$를 곱한 것이다. 용량 $s_{\text{pv}}$는 아직 값이 결정되지 않은, 최적화 문제를 풀어 결정해야 하는 변수임에 유의한다. 용량의 계수는$p_{\text{pv}}[n,t]$이다 (시간별 태양광 발전량 자료를 input으로 받는다).</p>

<p>나머지 제약조건들도 연도 인덱스 $n$을 추가하고, 배터리 용량 $S_{batt}$를 추가해 표현하면 아래와 같다.</p>

<p>$ e_{\text{batt}}[n,t] = e_{\text{batt}}[n,t-1] + \mu p_{\text{ch}}[n,t] - p_{\text{disch}}[n,t]/\mu  \quad \forall n,t$</p>

<p>$ 0 \leq e_{\text{batt}}[n,t] \leq s_{\text{batt}}  \quad \forall n,t$</p>

<p>$ 0 \leq p_{\text{ch}}[n,t] \leq \gamma s_{\text{batt}}, \quad 0 \leq p_{\text{disch}}[n,t] \leq \gamma s_{\text{batt}}  \quad \forall n,t$</p>

<p>$ e_{\text{batt}}[1,0] = 0$</p>

<p>여기서 $\mu$는 배터리 충/방전 효율, $\gamma$는 c-rate이다. 배터리 내 저장된 에너지는 배터리의 용량 $ s_{\text{batt}}$을 초과할 수 없음, 그리고 충/방전 전력은 배터리 용량에 c-rate를 곱한 값을 초과할 수 없음이 수식으로 표현되었다.</p>

<p>(실제로는 배터리의 겉보기 용량과 SOC도 고려해야 하지만, 여기서는 논의를 간편하게 하기 위해 배터리 용량이 SOC 상/하한을 고려한 실질적 용량이라고 가정한다.)</p>

<p><br />
그리고, 위에서 기본요금이 $\text{max} P_{\text{grid}}[n,t]$에 비례하는데 이는 새로운 변수 $q[n]$을 도입해서 추가제약을 세워 구해야 한다고 했었다. 해당 제약은 아래와 같다.</p>

<p>$ p_{\text{grid}}[n,t] \leq q[n] \quad \forall n$</p>

<p>위 식에 의해 $q[n]$는 $ p_{\text{grid}}[n,t]$ 중 가장 큰 값보다도 크거나 같다. $q[n]$에 양의 계수를 곱한 값이 목적함수에 추가되면, $q[n]$는 가능한 한 최소화된다 (그래야 목적함수가 최소화되므로). 결과적으로 $q[n]$는 $ p_{\text{grid}}[n,t]$의 최대값과 같게 된다.</p>

<p><br />
이쯤 되면 눈치챈 사람도 있겠지만, 용량 결정 문제가 되면서 문제의 scale이 매우 커졌다. 최적화 문제에서 고려하는 시점의 수가 저번 포스팅 (하루 동안의 스케줄링만 결정) 에서는 24개였으나, 이번 포스팅에서는 $20 \times 8,760=175,200$개가 되었다. 즉 $p_{\text{grid}}[n,t]$ 항이 175,200개, $p_{\text{ch}}[n,t]$ 항이 175,200개, $p_{\text{disch}}[n,t]$ 항이 175,200개, $e_{\text{batt}}[n,t]$ 항이 175,201개이다. 여기에 $q[n]$ 항 20개, $s_{\text{pv}}$와 $s_{\text{batt}}$도 추가되었다.</p>

<p>이렇게 큰 scale의 문제를 다루는 경우 두 가지 이슈가 생긴다.</p>

<p>첫 번째 이슈는, 계산 시간이 매우 길어진다는 것이다. 필자의 경험 상, 변수가 수십만 개가 되면 Python cvxopt의 경우 계산시간이 수십 분 이상으로 늘어날 수 있고 MATLAB optimization toolbox 등을 써도 분 단위는 걸린다. Input 변수들의 값을 바꿔보면서 계산을 여러 번 돌리는 parametric study를 하고자 할 경우 이는 중요한 이슈일 수 있다. 그래도 계산 시간 이슈는 해결책이 있다고 치자 (비싼 워크스테이션을 쓰든, 상용 solver의 cloud 서비스를 쓰든, 내가 자는 동안에도 컴퓨터를 돌리든…).</p>

<p>두 번째 이슈는, 20년이라는 긴 기간 동안의 `시간별’ 전기부하 데이터와 태양광 발전량 데이터를 구하기 쉽지 않다는 것이다. 기상청 시간별 일사량 및 건물의 스마트미터 계측 모두, 아직은 그만큼 역사가 오래되지 않았기 때문이다. 심지어 일부 기상대에서는 아직도 시간별 일사량 자체를 제공하지 않기도 한다. 이런 경우 없는 데이터를 만들어낸다는 해결책은 마땅치 않은 경우가 대부분이다.</p>

<p><br />
이러한 이슈들 때문에, 많은 연구들에서는 대상 건물의 1년치 시간별 전기부하 자료를 구하고 이 부하가 20년간 똑같이 반복된다고 가정한다. 그리고 태양광 발전량에 대해서도 1년치 시간별 발전량을 구하고 이 발전 패턴이 20년간 똑같이 반복된다고 가정하는 경우도 많다.</p>

<p>물론 현실은 그렇지 않지만, 이러한 가정 하의 계산으로도 `대략적인’ 최적 용량을 구하는 데 큰 문제는 없다. 어차피 목적함수 계산 시 모든 시간에 대한 총 합을 보는데, 각 시간별로는 오차가 있겠지만 그 오차들을 다 더하면 오차들의 합은 실제와 크게 다르지 않을 것이란 기대가 있기 때문이다. (표본평균의 분산은 표본의 크기가 커질수록 작아지듯)</p>

<p>1년치 자료만을 사용한다면, 각 변수 뒤에 붙던 $[n,t]$는 $[t]$로 바꿀 수 있다. 그리고 변수의 수는 $p_{\text{grid}}[n,t]$ 항이 8,760개, $p_{\text{ch}}[n,t]$ 항이 8,760개, $p_{\text{disch}}[n,t]$ 항이 8,760개, $e_{\text{batt}}[n,t]$ 항이 8,761개, 기본요금 계산을 위해 도입한 $q$, 용량 변수 $s_{\text{pv}}$와 $s_{\text{batt}}$로, 총 35,044개이다.</p>

<p><br />
마지막으로, 현실성을 위해 아래와 같은 제약을 추가할 수 있다.</p>

<p>$e_{\text{batt}}[0] = e_{\text{batt}}[8760]$
이는 1년치 자료만을 사용하는 최적화 문제가 `같은 1년의 반복을 가정’함에 착안해, 해당 1년의 시작 직전 시간의 배터리 내 에너지 저장량과 끝 시간의 배터리 내 에너지 저장량을 같게 만드는 것이다. 2년차에서 0번째 시간은 1년차의 8760번째 시간과 같기 때문이다.</p>

<p><br />
지금까지의 내용을 반영해, 1년치 자료를 입력으로 받아서 태양광과 배터리 용량을 결정하는 최적화 문제를 구성하고 풀어내는 Python 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">from</span> <span class="n">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">glpk</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">p_load</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"load_hourly.txt"</span><span class="p">)</span>
<span class="n">p_pv</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"pv_hourly.txt"</span><span class="p">)</span> <span class="c1"># 1kW 패널의 시간별 발전량
</span><span class="n">eleccost</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"eleccost_hourly.txt"</span><span class="p">)</span>
<span class="n">eleccost_demandcharge</span> <span class="o">=</span> <span class="mi">8320</span> <span class="c1"># kW당 기본요금
</span><span class="n">taxrate</span> <span class="o">=</span> <span class="mf">1.137</span>

<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.94</span>
<span class="n">c_rate_batt</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">r</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 화폐가치 하락에 대한 할인율
</span>
<span class="n">initialcost_pv</span> <span class="o">=</span> <span class="mi">1400000</span> <span class="c1"># 태양광 1kW당 초기투자비
</span><span class="n">initialcost_batt</span> <span class="o">=</span> <span class="mi">600000</span> <span class="c1"># 배터리 1kWh당 초기투자비 (SOC 고려한 실용량 가정)
</span><span class="n">mtncost_pv</span> <span class="o">=</span> <span class="n">initialcost_pv</span> <span class="o">*</span> <span class="mf">0.02</span> <span class="c1"># 태양광 1kW당 유지보수비 (매년 발생) 
</span><span class="n">mtncost_batt</span> <span class="o">=</span> <span class="n">initialcost_batt</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1"># 배터리 1kWh당 유지보수비 (매년 발생)
</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">8760</span>

<span class="k">def</span> <span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">spmatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">),</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_ones</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_batt</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span> <span class="o">-</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>


<span class="n">Aeq_balance</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="nf">matrix</span><span class="p">(</span><span class="n">p_pv</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>  <span class="p">])</span>
<span class="n">beq_balance</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">p_load</span><span class="p">,</span><span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">)</span>

<span class="n">Aeq_batteryenergy</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="o">-</span><span class="n">eff_batt</span><span class="o">*</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="mi">1</span><span class="o">/</span><span class="n">eff_batt</span><span class="o">*</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_batt</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span>
<span class="n">beq_batteryenergy</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">Aeq_batteryenergy_lasthour</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">])],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span>
<span class="n">beq_batteryenergy_lasthour</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

<span class="n">Aeq</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">Aeq_balance</span><span class="p">,</span><span class="n">Aeq_batteryenergy</span><span class="p">,</span> <span class="n">Aeq_batteryenergy_lasthour</span> <span class="p">])</span>
<span class="n">beq</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">beq_balance</span><span class="p">,</span><span class="n">beq_batteryenergy</span><span class="p">,</span> <span class="n">beq_batteryenergy_lasthour</span><span class="p">])</span>


<span class="n">A_maximumstored</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">)],[</span><span class="o">-</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumstored</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumcharge</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">)],[</span><span class="o">-</span><span class="n">c_rate_batt</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumcharge</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumdischarge</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">)],[</span><span class="o">-</span><span class="n">c_rate_batt</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumdischarge</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumgrid</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="o">-</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">)]])</span>
<span class="n">b_maximumgrid</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">lowerbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span>
<span class="n">A_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="n">lowerbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">upperbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span> 
<span class="n">A_upperbound</span> <span class="o">=</span> <span class="nf">block_eye</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b_upperbound</span> <span class="o">=</span> <span class="n">upperbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">A</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">A_maximumstored</span><span class="p">,</span> <span class="n">A_maximumcharge</span><span class="p">,</span> <span class="n">A_maximumdischarge</span><span class="p">,</span> <span class="n">A_maximumgrid</span><span class="p">,</span> <span class="n">A_lowerbound</span><span class="p">,</span> <span class="n">A_upperbound</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">b_maximumstored</span><span class="p">,</span> <span class="n">b_maximumcharge</span><span class="p">,</span> <span class="n">b_maximumdischarge</span><span class="p">,</span> <span class="n">b_maximumgrid</span><span class="p">,</span> <span class="n">b_lowerbound</span><span class="p">,</span> <span class="n">b_upperbound</span><span class="p">])</span>

<span class="n">npvfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)))</span> <span class="c1"># 초항이 (1+r)^{-1}, 마지막항이 (1+r)^{20}인 등비수열의 합
</span><span class="n">costfun_pv</span> <span class="o">=</span> <span class="n">initialcost_pv</span> <span class="o">+</span> <span class="n">mtncost_pv</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 초기투자비 + 매년 유지보수비(npvfactor를 곱해 현가화)
</span><span class="n">costfun_batt</span> <span class="o">=</span> <span class="n">initialcost_batt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">mtncost_batt</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 초기투자비 + 10년 후 재투자비(현가화) + 매년 유지보수비 (현가화)
</span><span class="n">costfun_elec</span> <span class="o">=</span> <span class="n">taxrate</span> <span class="o">*</span> <span class="n">eleccost</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 전기 사용량 요금 (현가화)
</span><span class="n">costfun_elec_demand</span> <span class="o">=</span> <span class="n">taxrate</span> <span class="o">*</span> <span class="n">eleccost_demandcharge</span> <span class="o">*</span> <span class="mi">12</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 전기 기본요금 (현가화), 매 월별이므로 12 곱함
</span>
<span class="n">c</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="nf">matrix</span><span class="p">(</span><span class="n">costfun_elec</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_elec_demand</span><span class="p">])],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_pv</span><span class="p">])],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_batt</span><span class="p">])]])</span> 

<span class="n">x</span> <span class="o">=</span> <span class="n">glpk</span><span class="p">.</span><span class="nf">lp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="n">beq</span><span class="p">,</span><span class="n">options</span><span class="o">=</span><span class="p">{</span> <span class="s">'msg_lev'</span><span class="p">:</span> <span class="s">'GLP_MSG_ON'</span><span class="p">})</span>
<span class="n">totalcost</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">capa_pv</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="n">capa_batt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">p_grid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">])</span>

<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">73</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">p_load</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">72</span><span class="p">])</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">73</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">p_grid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">72</span><span class="p">]</span><span class="o">+</span><span class="n">p_pv</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">72</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">capa_pv</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">xlim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">73</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>(계산 결과)</p>]]></content><author><name>Jeonghun Song</name></author><category term="Energy" /><category term="python" /><category term="BeautifulSoup" /><summary type="html"><![CDATA[지난 포스팅에서는 `주어진 용량의’ 배터리가 건물에 설치된 경우의 시간별 최소비용 충/방전 스케줄을 구하기 위한 선형계획법 문제 수식 구성 및 코딩을 설명했다.]]></summary></entry></feed>