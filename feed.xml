<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-06-30T23:19:35+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">에너지엔데이터연구소</title><subtitle>에너지 데이터를 수리모델링에 활용해 최적 에너지 시스템/ 정책/ 시장 등에 관한 유익한 결과물들을 도출하여, 스마트한 에너지 전환에 기여하고자 하는 데이터 사이언티스트입니다.</subtitle><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><entry><title type="html">선형계획법 기반 분산에너지시스템 최적화 - 9) 출력 조정 관련 제약들</title><link href="http://localhost:4000/linprognine.html" rel="alternate" type="text/html" title="선형계획법 기반 분산에너지시스템 최적화 - 9) 출력 조정 관련 제약들" /><published>2023-04-28T00:00:00+09:00</published><updated>2023-04-28T00:00:00+09:00</updated><id>http://localhost:4000/linprognine</id><content type="html" xml:base="http://localhost:4000/linprognine.html"><![CDATA[<p>에너지 전환기 이전의 전통적 발전 포트폴리오에서도, 연료비가 저렴하고 탄소 배출이 적은 원자력’만’을 쓰지 않고 석탄/ 가스(LNG)/ 중유/ 양수발전 등을 결합해 구성했다. 이는 시간별로 전기 부하가 달라지며, 전원별로 ‘부하 변동에 대응하는 출력 조정 능력’이 다르기 때문이다.</p>

<p><img src="/assets/images/linprognine/portfolio.png" alt="portfolio" class="align-center" />
<em>시간대별 발전 포트폴리오. 일정 출력을 유지하는 기저설비, 특정 시간대에만 가동되는 첨두설비로 구성됨.<br />(출처: 전력거래소)</em></p>

<p>위 그림에서 보듯, 24시간 내내 거의 일정하게 운전하여 기저부하(base load)를 담당하는 데는 연료비가 상대적으로 저렴한 원자력, 석탄화력을 사용하고, 낮에만 발전하여 첨두부하(peak load)를 담당하는 데는 부하변동에 대한 응답성이 좋은 LNG/ 중유/ 양수발전 등을 사용한다.</p>

<p>이 때, 부하 변동에 대한 응답성이 좋다는 것은 아래와 같이 구체화할 수 있다.</p>

<p>1) 시간당 변화시킬 수 있는 출력 범위가 넓다.</p>

<p>2) 기동/정지 상태의 전환을 비교적 빈번하게 할 수 있다.</p>

<p>3) 연료비와는 별도로 시동 (정지에서 기동상태로 전환) 시 발생하는 비용이 크지 않다.</p>

<p>중/대형 발전설비들은 대개 이러한 ‘응답성’이 아주 좋지는 않다. 그러므로 시간별 수요/공급을 고려하는 선형계획법을 중/대형 발전설비 대상으로 적용 시, 이러한 ‘응답성’ 또한 제약조건으로 추가해야 한다. (이를테면 시/구 단위 지역난방 시스템을 대상으로 할 경우, 이러한 제약이 중요하다.)</p>

<p>사실 이는 중/대형 발전설비에만 국한되지 않는다. 이를테면 연료전지의 경우에도 소규모 설치가 가능한 발전 설비이지만, 부하 응답성이 기본적으로 나쁘다. 그래서 정격출력이 반강제되고, 정지 후 재기동 및 기동 유지에 장시간을 요구한다.</p>

<p>이 포스팅에서는 ‘응답성’을 나타내는 출력 조정 관련 제약들을 설명한다.</p>

<p><br /></p>

<h2 id="ramp-rate--duck-curve">Ramp rate (+ duck curve)</h2>

<p>차를 몰 때 악셀을 밟아도 1초당 늘릴 수 있는 속력에는 한계가 있다. 또한 급브레이크를 밟아도 1초당 줄일 수 있는 속력에는 한계가 있다. 무리해서 급브레이크를 계속 밟으면 차량 수명에 악영향을 끼치기도 한다.</p>

<p>마찬가지로 발전기의 출력 또한 갑자기 크게 늘리거나 줄이는 것에는 한계가 있고 그 한계를 무리해서 넘으면 수명에 악영향을 끼친다. 그래서, 단위 시간 동안의 출력 증가/ 감소 각각에 대해 최대값을 설정하며, 이를  ramp rate라 한다.</p>

<p>해당 최대값들을 정격출력 $s$로 나눈 값을 각각 $\delta_{up}$, $\delta_{down}$이라 할 때, ramp rate 제약은 아래와 같다.</p>

<p>$ -\delta_{down} s \leq p_{gen}[t] - p_{gen}[t-1] \leq \delta_{up} s $</p>

<p>즉 시간 $t-1$ 대비 시간 $t$에서 출력을 증가시키더라도 그 증가분은 $\delta_{up} s$를 초과할 수 없다. 반대로 시간 $t$에서 출력을 감소시키더라도 그 감소분은 $ \delta_{down} s$를 초과할 수 없다.</p>

<p><br />
한편 계통 내에 태양광 발전의 비중이 증가하면서, ramp rate가 큰 발전 설비에 대한 수요가 증가할 전망이다.</p>

<p>이는 아래 그림과 같이, 태양광 비중이 증가할수록 낮 시간의 ‘태양광 발전량을 제한 순 부하 (net load)’가 작아지면서, 아침의 단위 시간 당 부하 감소량/ 오후의 단위 시간 당 부하 증가량이 커지기 때문이다.</p>

<p><img src="/assets/images/linprognine/duckcurve.jpg" alt="duckcurve" class="align-center" />
<em>시간에 따라 태양광 발전 비중 증가 가정 시, 태양광 발전량을 제한 순 부하의 변화. 이를 duck curve라 부른다.<br />(출처: https://www.synergy.net.au/Blog/2021/10/Everything-you-need-to-know-about-the-Duck-Curve)</em></p>

<p>이러한 부하의 급격한 변동은 화력발전 설비들의 급격한 출력 변동으로 이어지고, 이는 시스템 불안정성을 야기한다. 그러므로 이에 대응할 수 있도록 ramp rate가 큰 발전 설비/ 전기 저장 설비/ 잉여전력을 활용하는 섹터커플링/ 다른 시간의 전기 부하 이전 등 ‘유연성 자원’ 확보의 필요성이 증가하고 있다.</p>

<p>Ramp rate에 대한 제약을 응용해서, 만약 시점 $t$에서의 화력발전의 합을 $p_{\text{gen}}[t]$라 할 때, $p_{\text{gen}}[t] - p_{\text{gen}}[t-1]$ 의 상한값과 하한값을 설정할 수 있다. 이러한 제약은 화력발전의 출력 변동을 허용 선 이하로 제한할 경우의 적정 태양광 보급 안/ 유연성 자원 요구량 산출 등의 정책 연구에 활용할 수 있다.</p>

<p><br /></p>

<h2 id="최소-기동유지시간정지유지시간">최소 기동유지시간/정지유지시간</h2>

<p>어떤 기계든, 지나치게 껐다 켰다를 빨리 반복하면 해당 기계 수명에 악영향을 미칠 것이다. 이는 발전기도 마찬가지로, 빈번하게 기동-정지 전환 시 기기 수명에 악영향을 미친다.</p>

<p>이 때문에, 발전기가 정지 상태에서 기동 상태로 전환하면, 일정 시간 동안 기동 상태를 유지해 줘야 한다. 또한 기동 상태에서 정지 상태로 전환하면, 일정 시간 동안 정지 상태를 유지해 줘야 한다.</p>

<p>특히 규모가 크고 기저설비에 가깝게 설계된 경우, 이런 최소 기동유지시간/정지유지시간이 수 시간 이상일 수 있다.</p>

<p><br />
어떤 발전설비가 정지상태에서 기동상태로 전환 시 ‘최소한 3시간은’ 기동상태를 유지해야 한다고 가정하자.</p>

<p>해당 발전설비가 시점 $t-1$에서 정지상태였다가 시점 $t$에서 기동상태로 전환된 경우, 위 조건에 의해 최소한 시점 $t+1, t+2$에서는 기동상태를 유지해야 한다. 즉 $u[t-1]=0$이면서 $u[t]=1$이라면, 반드시 $u[t+1]=u[t+2]=1$이어야 한다.</p>

<p>위 제약조건을 수식으로 표현하면 아래와 같다.</p>

<p>$ 3 (u[t]-u[t-1]) \leq u[t]+u[t+1]+u[t+2]  $</p>

<p>$u[t]=1$이고 $u[t-1]=0$인 경우 좌변은 3이 되는데, 우변에는 이진수 3개만 있으므로 반드시 셋 다 1이 되어야 한다. 그러므로 $u[t+1]=u[t+2]=1$이어야만 식이 성립한다. 이외의 경우에는 좌변이 0 또는 -3이 되므로, $u[t+1]$과 $u[t+2]$가 어떤 값을 가져도 식이 성립한다.</p>

<p><br />
이번에는 해당 발전설비가 기동상태에서 정지상태로 전환 시 ‘최소한 2시간은’ 정지상태를 유지해야 한다고 가정하자.</p>

<p>한편 해당 발전설비가 시점 $t-1$에서 기동상태였다가 시점 $t$에서 정지상태로 전환된 경우, 위 조건에 의해 최소한 시점 $t+1$에서는 정지상태를 유지해야 한다. 즉 $u[t-1]=1$이면서 $u[t]=0$이라면, 반드시 $u[t+1]=0$이어야 한다.</p>

<p>위 제약조건을 수식으로 표현하면 아래와 같다.</p>

<p>$ 2 (u[t-1]-u[t]) \leq 2 - (u[t]+u[t+1])  $</p>

<p>$u[t]=0$이고 $u[t-1]=1$인 경우 좌변은 2가 되는데, 우변에서 $u[t]=u[t+1]=0$이어야만 식이 성립한다. 이외의 경우에는 좌변이 0 또는 -2가 되므로, $u[t+1]$이 어떤 값을 가져도 식이 성립한다.</p>

<p><br /></p>

<h2 id="시동-비용-start-up-cost">시동 비용 (start-up cost)</h2>

<p>일정 규모 이상의 발전기를 정지 상태에서 기동 상태로 전환, 즉 ‘시동’ 시, 무시할 수 없는 수준의 시동비용이 발생하기도 한다. 이는 전력 생산을 위한 연료 비용과는 별개의 비용으로 반영하여야 한다.</p>

<p>시점 $t$에서 시동을 한다는 것은 $u[t-1]=0$이면서 $u[t]=1$임을 의미한다. 즉 시동 여부를 의미하는 새로운 이진수 $v[t]$를 도입해서, $u[t-1]=0$이면서 $u[t]=1$일 때는 반드시 $v[t]=1$이 되도록 제약을 걸고, $v[t]$에 시동비용 계수를 곱한 항을 목적함수에 추가해야 한다.</p>

<p>필요한 제약식은 아래와 같다.</p>

<p>$u[t] - u[t-1] \leq v[t]$</p>

<p>$u[t]=1$이고 $u[t-1]=0$인 경우 좌변은 1이 되는데, $v[t]$는 이진수이므로 반드시 $v[t]=1$이어야 식이 성립한다. 이외의 경우에는 좌변이 0 또는 -1이므로 $v[t]$가 0이어도 상관이 없으며, 목적함수를 최소화하기 위해 $v[t]=0$이 될 것이다.</p>

<div class="notice--info">

선형계획법 기반 분산에너지시스템 최적화<br /><br />

1) <a href="/linprogone.html">최소비용 시스템과 시간별 자료의 중요성</a><br />
2) <a href="/linprogtwo.html">배터리의 충/방전 스케줄 결정: 수식</a> <br />
3) <a href="/linprogthree.html">배터리의 충/방전 스케줄 결정: Python 코드 및 결과</a> <br />
4) <a href="/linprogfour.html">태양광과 배터리의 '용량' 결정 (코드 및 결과 포함)</a> <br />
5) <a href="/linprogfive.html">정수 (integer) 변수 도입으로 현실 설명력 증대</a> <br />
6) <a href="/linprogsix.html">공동주택의 '누진제' 전기요금 (단일계약) 수식</a> <br />
7) <a href="/linprogseven.html"> 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</a> <br />
8) <a href="/linprogeight.html"> '부분'부하 성능 관련 제약들</a> <br />
9) <b> 출력 조정 관련 제약들</b>

</div>

<p><br />
(선형계획법 시리즈의 지식들은, 필자가 2012년부터 <a href="http://www.besico.co.kr/">(주)블루이코노미전략연구원 (대표: 오시덕 박사)</a>과 함께 선형계획법 기반으로 신재생 및 열병합 에너지 시스템 경제성분석/ 최적 에너지시스템 도출 Tool 개발/ 에너지 정책 효과 분석 관련 프로젝트들을 여러 건 수행하며 축적한 ‘기본 지식’에 해당하는 부분임을 밝힌다.)</p>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="optimalsystem" /><category term="선형계획법" /><category term="부하패턴" /><category term="경제성분석" /><category term="Python" /><summary type="html"><![CDATA[에너지 전환기 이전의 전통적 발전 포트폴리오에서도, 연료비가 저렴하고 탄소 배출이 적은 원자력’만’을 쓰지 않고 석탄/ 가스(LNG)/ 중유/ 양수발전 등을 결합해 구성했다. 이는 시간별로 전기 부하가 달라지며, 전원별로 ‘부하 변동에 대응하는 출력 조정 능력’이 다르기 때문이다.]]></summary></entry><entry><title type="html">선형계획법 기반 분산에너지시스템 최적화 - 8) ‘부분’부하 관련 제약들</title><link href="http://localhost:4000/linprogeight.html" rel="alternate" type="text/html" title="선형계획법 기반 분산에너지시스템 최적화 - 8) ‘부분’부하 관련 제약들" /><published>2023-04-27T00:00:00+09:00</published><updated>2023-04-27T00:00:00+09:00</updated><id>http://localhost:4000/linprogeight</id><content type="html" xml:base="http://localhost:4000/linprogeight.html"><![CDATA[<p>지난 포스팅에서는 설비의 효율과 COP(성능계수)를 상수로 가정했지만, 실제로는 부하율에 따라 효율과 COP가 달라진다. 이를테면 열병합발전기의 경우, 최대 출력(정격 출력)으로 운전할 때 비해 더 낮은 출력으로 ‘부분부하’운전 시 발전효율이 저하됨이 알려져 있다.</p>

<p><img src="/assets/images/linprogeight/chp_eff.png" alt="chp_eff" class="align-center" />
<em>열병합발전기의 통상적인 부하율-효율 그래프. 낮은 부하율에서 효율이 저하됨.<br />출처: <a href="https://doi.org/10.1016/j.apenergy.2015.03.053">“Modeling of non-linear CHP efficiency curves in distributed energy systems”</a></em></p>

<p>반대로 냉방기기의 경우, 정격부하 대비 부분부하에서 COP가 더 높다.</p>

<p><img src="/assets/images/linprogeight/cop.png" alt="cop" class="align-center" />
<em>LG전자의 지열기반 chiller의 부하율별 COP. 일반적인 turbo chiller, 흡수식냉동기도 비슷한 추이를 보임.</em></p>

<p>이번 포스팅에서는, 선형계획법 문제에서 이러한 ‘부분부하’에서의 효율과 COP를 고려하여 설비의 input-output 관계를 보다 더 현실적으로 모델링하는 수식을 설명한다.</p>

<p><br /></p>

<h2 id="발전기의-부분부하-성능을-고려한-수식">발전기의 부분부하 성능을 고려한 수식</h2>

<p>아래 그림은, 정격출력이 100이고 최소부하율이 50%인 가상의 발전기의 연료입력-발전출력 그래프다. 위에서 보인 열병합발전기의 부하율-효율 그래프와는 가로축, 세로축이 다름에 주의한다.</p>

<p><img src="/assets/images/linprogeight/chp.png" alt="chp" class="align-center" />
<em>연료 입력 - 발전 출력 그래프.</em></p>

<p>시점 $t$의 연료 소비량을 $f[t]$, 발전량을 $p[t]$라 하자.
위 검정 그래프는 상수 효율 $\eta$을 가정한 경우로, 절편이 없는 직선 $p[t]=\eta f[t]$상의 선분이다.</p>

<p>그러나 부분부하 성능 저하를 고려 시, 위 빨간 그래프처럼, 음의 절편이 있는 직선상의 선분이 된다. 해당 설비의 기동/정지를 나타내는 이진수 $u[t]$를 다시 도입하면 (기동 시 1, 정지 시 0), 위 빨간 그래프는 $p[t] = \eta f[t] + \psi u[t]$로 표현된다 ($\psi$가 절편).</p>

<p>여기서는 연료입력-발전출력 관계를, 최소부하율과 정격출력 두 지점에서의 연료입력-발전출력이 주어질 때 두 점을 잇는 선분으로 근사하였다. $\eta$와 $\psi$를 계산하면 선형계획법을 적용할 수 있다. (해당 ‘선형’ 근사가 실제 발전기 특성에서 크게 벗어나지 않음이 알려져 있다.)</p>

<p>최소부하율이란, 기기 안정성/수명에 해를 끼치지 않는 선에서 최소로 유지할 수 있는 부하율이다. 마치 자전거가 넘어지지 않고 앞으로 나아가려면 최소한의 속도가 필요한 것에 비유할 수 있다.</p>

<p>설비 정격출력을 $S$, 최소부하율을 $\gamma_{min}$라 할 때, 설비의 출력 범위를 표현하는 제약조건은 아래와 같다.</p>

<p>$ u[t] \gamma_{min} s \leq p[t] \leq u[t] s $</p>

<p>$u[t]=0$이면 (즉 정지상태이면) $p[t]=0$이며, $u[t]=1$이면 (즉 기동상태이면) $ \gamma_{min} s \leq p[t] \leq s $ 가 되어 $p[t]$가 최소부하 출력과 정격출력 사이의 값을 가질 수 있다.</p>

<p><br /></p>

<h2 id="냉방기기의-부분부하-성능을-고려한-수식">냉방기기의 부분부하 성능을 고려한 수식</h2>

<p>아래 그림은, 정격출력(냉방)이 150kW인 가상의 냉방설비의 전기입력-냉방출력 그래프다. 위에서 보인 chiller의 부하율 별 COP를 적용하였다.</p>

<p><img src="/assets/images/linprogeight/chiller.png" alt="chiller" class="align-center" width="70%" />
<em>위 LG전자의 지열기반 chiller와 같은 부하율별 COP를 갖는 150kW(냉방출력)급 chiller의 전기 입력 - 냉방 출력 그래프.</em></p>

<p>냉방기기에 대해서는 보통 부하율 25%, 50%, 75%, 100%에 대한 성능이 주어진다. 즉 4개의 (전기입력,냉방출력) 점이 주어지는데, 4개의 점이 모두 한 선분 위에 있지 않다. 그러므로 더 이상 하나의 선분으로는 표현할 수 없으며, 선형계획을 적용하기 위해서는 3개의 연속된 선분으로 표현되어야 한다.</p>

<p>냉방기기의 (시점 $t$의) 냉방 출력을 $q_{c}[t]$, 전기 입력을 $p_c[t]$라 하자. 그리고 위 그래프의 3개의 선분을 나타내는 일차식들을 각각 $q_c[t]=\alpha_1 + \beta_1 p_c[t]$ (출력기준 부하율 25%~50%), $q_c[t]=\alpha_2 + \beta_2 p_c[t]$ (부하율 50%~75%), $q_c[t]=\alpha_3 + \beta_3 p_c[t]$ (부하율 75%~100%)이라 하자.</p>

<p>그러면 각 시간별로 냉방기기가 가동된다면 위 3개 구간 중 어디에 속하는지 (혹은 가동이 되지 않는지) 여부를 표현하는 이진수 3개의 세트가 있어야 한다. 각각을 $u_1[t]$, $u_2[t]$, $u_3[t]$이라 하자.</p>

<p>또한 전기 입력 변수도 위 3개 구간 각각에 대응하는 3개의 변수 $p_1[t]$, $p_2[t]$, $p_3[t]$으로 두자. 또한 냉방기준 부하율 25%, 50%, 75%, 100%에 대응하는 전기 입력을 각각 $\tilde{p}_1$, $\tilde{p}_2$, $\tilde{p}_3$, $\tilde{p}_{\text{max}}$라 하자. 그러면, 위 그래프는 아래 제약조건들로 표현된다.</p>

<p>$q_c[t] = \alpha_1 u_1[t] + \beta_1 p_1[t] + \alpha_2 u_2[t] + \beta_2 p_2[t] + \alpha_3 u_3[t] + \beta_3 p_3[t] $</p>

<p>$ \tilde{p}_1 u_1[t] \leq p_1[t] \leq \tilde{p}_2 u_1[t] $</p>

<p>$ \tilde{p}_2 u_2[t] \leq p_2[t] \leq \tilde{p}_3 u_2[t] $</p>

<p>$ \tilde{p}_3 u_3[t] \leq p_3[t] \leq \tilde{p}_{\text{max}} u_3[t] $</p>

<p>$ u_1[t] + u_2[t] + u_3[t] \leq 1 $</p>

<p>위 제약을 통해 부분부하 성능 뿐 아니라 기동시의 최소 출력 ($\tilde{p}_1$) 도 반영된다.</p>

<p><br /></p>

<h2 id="시간별-설비별-이진변수에-의한-계산시간-증가-문제">‘시간별/ 설비별’ 이진변수에 의한 계산시간 증가 문제</h2>

<p>위 방법 사용 시 ‘각 시간별/ 설비별’ 이진변수가 사용되므로 이진변수의 총 갯수가 커진다. 고려 대상 발전기 수가 많아지거나 전체 고려 기간이 길어지면, 풀이에 요구되는 시간이 오래 걸리고 심지어는 사실상 풀리지 않는 문제가 될 수도 있다.</p>

<p>이를테면 1년치 자료를 기반으로 용량을 정하는 문제의 경우, 위 이진변수 기반 제약조건들을 그대로 적용하면 이진변수의 총 갯수가 8,760의 몇 배 이상에 달한다. 이를 그대로 푸는 것은 cvxopt의 glpk 모듈 혹은 MATLAB의 optimization toolbox 정도로는 불가능하며, CPLEX/ Gurobi 등 값비싼 상용 solver로도 꽤나 시간이 걸리는 일이다.</p>

<p><br />
이 경우, 아래와 같은 two-stage 기반으로 문제를 푸는 것이 현실적인 접근법이다.</p>

<p>1) 시간별 이진수가 들어가는 조건들을 무시하고 선형계획 문제를 구성해 풀어, 설비 별 용량을 구한다.</p>

<p>2) 위에서 구한 설비 별 용량을 전제로, 일정 기간 (대략 24시간의 몇 배수) 의 최적 스케줄링 및 경제성을 위 이진변수 기반 제약조건들을 적용해 도출한다.</p>

<p>실제로는 1)에서 구한 용량이 전역 최적(global optimum)이 아닐 수 있으므로, 해당 용량에서 약간씩 변화시킨 후 다시 2)의 방법으로 최적 스케줄링을 구해, 더 나은 해가 있는지 탐색해 보는 것이 좋다. 특히 용량이 큰 설비의 대수가 용량변수에 포함되어 있을 경우, 대수를 줄이거나 늘려서 경제성을 원안과 비교해 보는 것이 좋다.</p>

<div class="notice--info">

선형계획법 기반 분산에너지시스템 최적화<br /><br />

1) <a href="/linprogone.html">최소비용 시스템과 시간별 자료의 중요성</a><br />
2) <a href="/linprogtwo.html">배터리의 충/방전 스케줄 결정: 수식</a> <br />
3) <a href="/linprogthree.html">배터리의 충/방전 스케줄 결정: Python 코드 및 결과</a> <br />
4) <a href="/linprogfour.html">태양광과 배터리의 '용량' 결정 (코드 및 결과 포함)</a> <br />
5) <a href="/linprogfive.html">정수 (integer) 변수 도입으로 현실 설명력 증대</a> <br />
6) <a href="/linprogsix.html">공동주택의 '누진제' 전기요금 (단일계약) 수식</a> <br />
7) <a href="/linprogseven.html"> 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</a> <br />
8) <b> '부분'부하 성능 관련 제약들</b> <br />
9) <a href="/linprognine.html"> 출력 조정 관련 제약들</a>

</div>

<p><br />
(선형계획법 시리즈의 지식들은, 필자가 2012년부터 <a href="http://www.besico.co.kr/">(주)블루이코노미전략연구원 (대표: 오시덕 박사)</a>과 함께 선형계획법 기반으로 신재생 및 열병합 에너지 시스템 경제성분석/ 최적 에너지시스템 도출 Tool 개발/ 에너지 정책 효과 분석 관련 프로젝트들을 여러 건 수행하며 축적한 ‘기본 지식’에 해당하는 부분임을 밝힌다.)</p>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="optimalsystem" /><category term="선형계획법" /><category term="부하패턴" /><category term="경제성분석" /><category term="Python" /><summary type="html"><![CDATA[지난 포스팅에서는 설비의 효율과 COP(성능계수)를 상수로 가정했지만, 실제로는 부하율에 따라 효율과 COP가 달라진다. 이를테면 열병합발전기의 경우, 최대 출력(정격 출력)으로 운전할 때 비해 더 낮은 출력으로 ‘부분부하’운전 시 발전효율이 저하됨이 알려져 있다.]]></summary></entry><entry><title type="html">선형계획법 기반 분산에너지시스템 최적화 - 7) 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</title><link href="http://localhost:4000/linprogseven.html" rel="alternate" type="text/html" title="선형계획법 기반 분산에너지시스템 최적화 - 7) 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)" /><published>2023-04-26T00:00:00+09:00</published><updated>2023-04-26T00:00:00+09:00</updated><id>http://localhost:4000/linprogseven</id><content type="html" xml:base="http://localhost:4000/linprogseven.html"><![CDATA[<p>이전 포스팅들에서는 전기 부하만을 다루었으나, 실제로는 냉방/난방/급탕 등 열 부하 또한 에너지 소비에서 상당한 비중을 차지한다. 따라서 ‘전기와 열을 모두’ 공급하는 분산형 에너지시스템의 최적 구성 및 스케줄을 도출할 수 있어야 한다.</p>

<p>이전부터 열병합 발전기/ 히트펌프/ 흡수식 냉동기 등 설비 도입 고려 시, 전기와 열을 동시에 고려하는 문제를 구성하고 풀어야 했다. 또한 2020년대에 들어서는, 점차 증가하는 재생발전의 잉여전력을 열/ 가스 등 타 형태의 에너지로 변환하여 사용/ 저장함으로써 화석연료 절감을 실현한다는 구상이 ‘섹터커플링’이란 이름으로 주목받고 있다.</p>

<p>이번 포스팅에서는 전기와 냉방/난방 부하를 동시에 충족하는 분산에너지 시스템을 설명한다. 우선 관련 설비 각각에 대해 설명 후, 선형계획법 문제를 설명한다.</p>

<p><br /></p>

<h2 id="가장-간단한-케이스-전기로-냉방-공급-연료로-난방-공급">가장 간단한 케이스: 전기로 냉방 공급, 연료로 난방 공급</h2>

<p>가장 간단한 케이스는, 일반 사무용/ 조명/ 기계 부하 및 냉방기기 (에어컨) 가동을 위한 전기는 기존처럼 수전 및 전기를 생산할 수 있는 설비로 공급하고, 난방 부하는 연료를 연소하는 보일러를 통해 공급하는 것이다. 이 경우 냉방 부하는 ‘냉방 부하를 충족시키기 위해 냉방 설비를 가동하는 데 필요한 전기 부하’ 로써, 전기 부하에 포함된다.</p>

<p>보일러는 도시가스 배관망으로부터 공급받은 LNG(액화천연가스) 또는 용기 단위로 구입한 LPG(액화석유가스) 연료를 열에너지로 변환해 난방부하 $ q_{\text{load.h}}[t]$를 충족한다 (아랫첨자 h는 heating). 그러므로 아래와 같이 연료의 에너지 $f_{\text{boiler}}[t]$ 를 실제 활용가능한 열에너지 $q_{\text{boiler.h}}[t]$로 변환 시의 변환계수(효율) $\eta_{\text{boiler.h}}$ 를 고려한 변환 식이 필요하다.</p>

<p>$ q_{\text{boiler.h}}[t] = \eta_{\text{boiler.h}} f_{\text{boiler}}[t] $, $ q_{\text{load.h}}[t]=q_{\text{boiler.h}}[t]$</p>

<p>또한 목적함수에 연료의 요금 $\sum_{t} c_{\text{fuel}}[t]f_{\text{boiler}}[t]$도 추가해야 한다. 도시가스의 경우, <a href="http://www.citygas.or.kr/info/charge.jsp">용도 및 계절별로 요금이 다르다.</a></p>

<p>(주의해야 할 점: 일반적으로 <a href="https://cyber.kgs.or.kr/scu.Scu01Read.ex.do;cyberJSESSIONID=YjLKhs6S49gtFfhwv5XfvHN2C9h9gtSsGJ1F30VrQY9190xt13nr!-1519862351!-1170866958?vocChCd=01&amp;vocKindCd=&amp;pageIndex=5138&amp;hiddenYn=&amp;iTotCnt=53116&amp;bulc=&amp;tc1CD=&amp;searchType=1&amp;searchText=&amp;vocRcptNo=200010120008">보일러 효율을 표시할 때는 보통 ‘저위’발열량 (Lower Heating Value) 기준으로 표시</a>하나, <a href="http://www.citygas.or.kr/info/policydata/read.jsp?reqPageNo=1&amp;no=22">도시가스 공급업체에서 명시하는 열량은 ‘고위’발열량 (Higher Heating Value) 기준으로 기재</a>한다. 그러므로 고위발열량을 저위발열량으로 변환 후 난방부하 충족량 및 요금 계산을 해야 한다.)</p>

<p><br /></p>

<h2 id="전기열-간-섹터-커플링-히트펌프-흡수식-냉동기-열병합-발전">전기/열 간 섹터 커플링: 히트펌프, 흡수식 냉동기, 열병합 발전</h2>

<p>사실 위의 시스템은 섹터’커플링’은 아니다. 수전을 포함한 전기 공급 설비들의 용량 및 스케줄을 결정할 때 난방 부하를 고려하지 않아도 되고, 반대로 보일러의 용량 및 스케줄을 결정할 때 전기 부하를 고려하지 않아도 되기 때문이다.</p>

<p>전기와 냉/난방 부하 및 공급을 동시에 고려해서 설비 별 용량 및 스케줄을 결정해야 하는 시스템은, 전기로 냉방 뿐 아니라 난방까지 하는 히트펌프, 온열을 냉열로 변환하는 흡수식냉동기, 전기와 열을 동시에 생산하는 열병합 발전기 등을 포함한다.</p>

<p><img src="/assets/images/linprogseven/systemfigure.png" alt="systemfigure" class="align-center" />
<em>건물 내 전기/ 냉방/ 난방 에너지를 동시에 공급하는 시스템 예시.</em></p>

<p>해당 설비들은 에너지 분야 종사자가 아닌 독자에게 생소할 수 있으니, 약간 자세히 설명한다.</p>

<p><br />
1) 히트펌프 (Heat pump)</p>

<p>히트펌프는 전기로 구동되어 여름에는 냉방을 하고 겨울에는 난방을 하는 일체형 설비이다. 아래 그림의 천장형 시스템 에어컨을 많이 보았을 것이다. 해당 설비는 대개 하절기 냉방 뿐 아니라 동절기 난방도 가능하다.</p>

<p><img src="/assets/images/linprogseven/heatpump.jpg" alt="heatpump" class="align-center" width="60%" />
<em>천장형 시스템 에어컨. 히트펌프의 일종이다.<br />출처: https://xn–oh5b1bt10b10b34a.com/article/%EC%84%A4%EC%B9%98%EC%82%AC%EB%A1%80/4/12/</em></p>

<p>최근에는 건물 냉/난방용 뿐 아니라, 대규모 히트펌프를 구축해 지역난방 혹은 산업체 대상 열 공급에 이용하며 풍력 발전 단지 등의 잉여 전력을 열로 변환시키는 섹터커플링 아이디어가 유럽을 필두로 구체화되고 있다 (<a href="https://www.keei.re.kr/main.nsf/index.html?open&amp;p=%2Fweb_keei%2Fd_results.nsf%2F0%2FF4BF4589C7680D03492589800008517C&amp;s=%3Fopendocument%26is_popup%3D1%26menucode%3DS3">해당 연구의 22페이지 참고</a>).</p>

<p><br />
2) 흡수식 냉동기 (Absorption chiller)</p>

<p>흡수식 냉동기는 전기가 아니라 고온의 열을 입력받아 냉방을 수행하는 설비다. 히트펌프의 경우 냉방설비 내부에서 압축기를 통해 냉매가 순환하지만, 흡수식냉동기에서는 흡수용액이 증발/응축 과정에 의해 농도가 변하면서 순환되기 때문에 ‘흡수식’냉동기로 불린다. 기기의 규모가 커서, 주로 중/대형 빌딩에 쓰인다.</p>

<p><img src="/assets/images/linprogseven/absorption.jpg" alt="absorption" class="align-center" width="80%" />
<em>흡수식 냉동기 설치 현장.<br />출처: http://www.kmecnews.co.kr/news/articleView.html?idxno=25979</em></p>

<p>흡수식 냉동기는 전기 대신 가스보일러 등으로 생산된 온열을 이용해 냉방을 한다는 측면에서, 건물 입장에서는 전기 기본요금 절감 수단이자, 국가적으로는 하절기 전력 수급 부담 완화 수단이기도 하다. 또한 가스가 덜 사용되는 하절기에 가스를 사용하므로, 하절기 가스 저장 시설 확보 부담 완화에도 기여한다.</p>

<p>그래서 이전부터, <a href="http://www.gasnews.com/news/articleView.html?idxno=107057">가스냉방기기에 대한 설치장려금 등 지원제도</a>가 지속되어 왔다.</p>

<p>참고로 흡수식 냉동기와 비슷하지만 다른 설비인 ‘직화식’ 흡수식 ‘냉온수’기도 있다. 이는 가스를 직접 투입해 여름에는 냉방을, 겨울에는 난방을 단일 설비로 제공하는 기기이다 (국내에서는 직화식 흡수식 냉온수기의 비중이 비교적 높은 것으로 알려져 있다).</p>

<p><br />
3) 열병합 발전기 (Cogeneration)</p>

<p>열병합발전기는 연료를 공급받고 이를 전력으로 변환 후, 발전기에서 나오는 미사용 열에너지(배열) 를 산업용증기/ 건물난방/ 급탕 등에 활용하는 설비이다.</p>

<p>가장 널리 알려진 열병합 발전 설비는 지역난방이다. 도심지 근처의 화력 발전기의 배열을 온수배관망을 통해 일반 수용가에 공급하는 시스템이다.</p>

<p><img src="/assets/images/linprogseven/districtheat.jpg" alt="districtheat" class="align-center" width="90%" />
<em>지역난방 도식도. 출처:한국지역난방공사 사업소개 페이지</em></p>

<p><img src="/assets/images/linprogseven/pajuchp.jpg" alt="pajuchp" class="align-center" width="80%" />
<em>한국지역난방공사 파주 열병합발전소 전경. 파주 내 약 3.9만 세대에 열을 공급한다.<br />출처: https://www.energy-news.co.kr/news/articleView.html?idxno=33801</em></p>

<p>자칫 버려질 수 있는 열에너지를 최대한 활용함으로써, 전기와 열을 더한 종합 에너지 효율을 70% 혹은 그 이상으로 높일 수 있다는 장점이 있다. (배열을 활용하지 않고 전기 생산만 활용할 경우 에너지 효율은 대략 35~45% 정도임)</p>

<p><img src="/assets/images/linprogseven/chpefficiency.png" alt="chpefficiency" class="align-center" />
<em>열병합 설비 활용 시 (왼쪽), 그리고 발전과 열 생산을 개별 수행 시 (오른쪽)의 에너지 흐름. 열병합 설비 활용 시 같은 양의 전기와 열 에너지 공급에 드는 연료 에너지가 더 적다.<br />출처: “The benefits of micro-CHP”, Cogen Europe</em></p>

<p>또한 오염물질 배출을 지역난방 사업자 소유의 단일 배출구에서 관리하므로, 각 건물이 개별적으로 보일러 난방을 하는 경우와 비교해 대기오염 절감이 가능하다는 장점도 있다.</p>

<p>한편 이번 포스팅에서 다루는 건물용 자가 열병합발전기도, 발전기의 배열을 적당한 난방/급탕 에너지로 사용할 수 있어, 열에너지가 많이 필요한 건물 유형인 공동주택/ 병원/ 호텔 등에 도입 시 경제성이 확보될 수 있다.</p>

<p>혹자는 건물에 설치되는 연료전지(PEMFC)를 들어보았을 수 있는데, 이 또한 전기와 함께 열을 생산하고 열을 난방에 활용하는 열병합 시스템이다.</p>

<p>(주의: 이 포스팅에서 설명하는 열병합발전을 ‘복합화력발전’과 혼동하지 않도록 한다. 복합화력발전은 중/대형 가스터빈의 배열을 ‘증기터빈 구동’에 이용해 ‘추가적인 전기 생산’을 하는 방식이다.)</p>

<p><br /></p>

<h2 id="섹터커플링-설비를-포함하는-전기열-공급-시스템의-수식">섹터커플링 설비를 포함하는 전기/열 공급 시스템의 수식</h2>

<p>이제 아래 시스템을 표현하는 선형계획법 수식들을 설명한다.</p>

<p><img src="/assets/images/linprogseven/systemfigure.png" alt="systemfigure" class="align-center" />
<em>건물 내 전기/ 냉방/ 난방 에너지를 동시에 공급하는 시스템 예시. 열병합발전기/ 히트펌프/ 흡수식냉동기를 포함한다.</em></p>

<p>전기부하 $ p_{\text{load}}[t]$는 계통으로부터의 수전$p_{\text{grid}}[t]$와 자가열병합발전기의 발전 $p_{\text{cogen}}[t]$에 의해 공급된다. 이 때 히트펌프를 구동하기 위한 전기 $p_{\text{hpump}}[t]$도 공급되어야 함에 주의한다.</p>

<p>$ p_{\text{load}}[t] = p_{\text{grid}}[t] + p_{\text{cogen}}[t] - p_{\text{hpump}}[t]$</p>

<p>냉방 부하 $q_{\text{load.c}}[t]$ (아래첨자 c는 cooling) 가 있는 기간에는, 냉방 부하가 히트펌프의 냉방 $q_{\text{hpump.c}}[t]$와 흡수식 냉동기의 냉방 $q_{\text{absorp.c}}[t] $로 충족된다.</p>

<p>$ q_{\text{load.c}}[t] = q_{\text{hpump.c}}[t] + q_{\text{absorp.c}}[t] $</p>

<p>냉방 수요가 있는 기간이더라도 온수 등의 일부 난방 수요 $q_{\text{load.h}}[t] $가 존재할 수 있는데, 이는 보일러의 열 $q_{\text{boiler.h}}[t] $와 열병합 배열 $q_{\text{cogen.h}}[t]$로 공급한다.</p>

<p>$ q_{\text{load.h}}[t] = q_{\text{boiler.h}}[t] + q_{\text{cogen.h}}[t] $</p>

<p>냉방 수요가 없는 기간에는, 보일러와 열병합 배열 뿐 아니라 히트펌프도 난방 $q_{\text{hpump.h}}[t]$를 공급한다. 흡수식냉동기는 작동하지 않는다.</p>

<p>$ q_{\text{load.h}}[t] = q_{\text{boiler.h}}[t] + q_{\text{cogen.h}}[t] + q_{\text{hpump.c}}[t] $</p>

<p>보일러와 열병합발전기는 연료 에너지 $f$를 전기/ 열 에너지로 변환한다. 연료 에너지에 변환계수(효율) $\eta$를 곱해야 한다.</p>

<p>$ q_{\text{boiler.h}}[t] = \eta_{\text{boiler.h}}[t] f_{\text{boiler}}[t] $</p>

<p>$ p_{\text{cogen}}[t] = \eta_{\text{cogen.p}}[t] f_{\text{cogen}}[t] $</p>

<p>$ q_{\text{cogen.h}}[t] = \eta_{\text{cogen.h}}[t] f_{\text{cogen}}[t] $</p>

<p>냉방 수요가 있는 기간에 히트펌프와 흡수식냉동기가 각각 전기와 온열을 냉열로 변환할 때 변환 계수를 곱해줘야 하며, 이 경우 변환 계수는 성적계수(Coefficient of Performance, COP)라 한다.</p>

<p>$ q_{\text{hpump.c}}[t] = \text{COP}_{\text{hpump.c}} p_{\text{hpump}}[t] $</p>

<p>$ q_{\text{absorp.c}}[t] = \text{COP}_{\text{absorp.c}} p_{\text{hpump}}[t] $</p>

<p>냉방 수요가 없는 기간에는 히트펌프가 온열을 공급하며, 온열 공급 시의 COP는 일반적으로 냉열 공급시의 COP와 값이 다르다.</p>

<p>$ q_{\text{hpump.h}}[t] = \text{COP}_{\text{hpump.h}} p_{\text{hpump}}[t] $</p>

<p>여기서 COP가 1보다 클 수 있음에 주의한다. 히트펌프와 흡수식냉동기는 ‘연료의 에너지를 변환’하는 것이 아닌, ‘외부로부터 열을 운반’하는 원리로 구동되기 때문이다. 일반적으로 히트펌프의 COP는 3~5 정도 범위에, 흡수식냉동기의 COP는 1.0~1.3 정도 범위에 있다.</p>

<p>(위 수식은 효율/COP가 ‘어떤 상황에서도 변하지 않는 상수라고 가정하고’ 세운 식이다. 실제로는, 부하율(정격출력 대비 실제 출력의 비율)에 따라 효율/ COP가 달라진다. 이러한 ‘부분부하 성능’에 대해서는 다음 포스팅에서 설명한다.)</p>

<p>각 설비 별 출력은 정격 출력 (용량) 내의 범위에 있어야 한다. 용량을 $s$로 나타내면, 해당 제약은 아래와 같다.</p>

<p>$q_{\text{boiler.h}}[t] \leq s_{\text{boiler}}$, $\, p_{\text{cogen}}[t] \leq s_{\text{cogen}}$, $\, q_{\text{hpump.c}}[t] \leq s_{\text{hpump}}$, $\, q_{\text{absorp.c}}[t] \leq s_{\text{absorp}}$</p>

<p>위 식에서 보일러의 용량은 난방출력 기준, 열병합발전기의 용량은 전기 발전 기준, 히트펌프와 흡수식냉동기의 용량은 냉방출력 기준임에 주의한다.</p>

<p>(실제로는 기동 상태에서 ‘최소로 유지해야 하는’ 최소부하율이 있는데, 이 또한 다음 포스팅에서 설명한다.)</p>

<p><br /></p>

<h2 id="시간별-냉방난방-부하-정보-취득의-어려움">‘시간별’ 냉방/난방 부하 정보 취득의 어려움</h2>

<p>냉방/난방 부하를 포함하는 건물을 대상으로 선형계획법 기반의 경제성 분석을 수행하려면, 냉방과 난방의 ‘시간별’ 부하 정보도 구해야 한다.</p>

<p>그런데 전기 사용의 ‘시간’단위 기록은 스마트미터가 있다는 전제 하에 바로 구할 수 있지만, 열 사용의 ‘시간’ 단위 기록은 보통 구하기 어렵다. 대부분의 경우 월별 가스 사용량/요금 자료만 구할 수 있기 때문이다.</p>

<p>그래서 필자가 프로젝트를 수행할 당시에는, 대상 건물의 관리자를 인터뷰해서 열원별 가동시간 정보를 얻은 후 이를 바탕으로 시간별 사용량을 대략적으로 추정하는 것이 최선이었다.</p>

<p>(사실 전기 사용량도, 스마트미터가 없는 건물인 경우 월별 사용량/요금 자료만 얻을 수 있다. 이 경우 역시 관리자를 인터뷰해서 얻은 재실 스케줄 및 기기 가동 등 정보를 바탕으로 대략적인 부하를 추정 후, 시간별 요금제 기반으로 요금 계산 시 총 합이 고지서의 값과 거의 비슷하게 나올 때까지 부하 추정을 수정하여 최종적인 시간별 부하 추정치를 결정하는 것이 최선이다.)</p>

<div class="notice--info">

선형계획법 기반 분산에너지시스템 최적화<br /><br />

1) <a href="/linprogone.html">최소비용 시스템과 시간별 자료의 중요성</a><br />
2) <a href="/linprogtwo.html">배터리의 충/방전 스케줄 결정: 수식</a> <br />
3) <a href="/linprogthree.html">배터리의 충/방전 스케줄 결정: Python 코드 및 결과</a> <br />
4) <a href="/linprogfour.html">태양광과 배터리의 '용량' 결정 (코드 및 결과 포함)</a> <br />
5) <a href="/linprogfive.html">정수 (integer) 변수 도입으로 현실 설명력 증대</a> <br />
6) <a href="/linprogsix.html">공동주택의 '누진제' 전기요금 (단일계약) 수식</a> <br />
7) <b> 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</b> <br />
8) <a href="/linprogeight.html"> '부분'부하 성능 관련 제약들</a> <br />
9) <a href="/linprognine.html"> 출력 조정 관련 제약들</a>
</div>

<p><br />
(선형계획법 시리즈의 지식들은, 필자가 2012년부터 <a href="http://www.besico.co.kr/">(주)블루이코노미전략연구원 (대표: 오시덕 박사)</a>과 함께 선형계획법 기반으로 신재생 및 열병합 에너지 시스템 경제성분석/ 최적 에너지시스템 도출 Tool 개발/ 에너지 정책 효과 분석 관련 프로젝트들을 여러 건 수행하며 축적한 ‘기본 지식’에 해당하는 부분임을 밝힌다.)</p>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="optimalsystem" /><category term="선형계획법" /><category term="부하패턴" /><category term="경제성분석" /><category term="Python" /><summary type="html"><![CDATA[이전 포스팅들에서는 전기 부하만을 다루었으나, 실제로는 냉방/난방/급탕 등 열 부하 또한 에너지 소비에서 상당한 비중을 차지한다. 따라서 ‘전기와 열을 모두’ 공급하는 분산형 에너지시스템의 최적 구성 및 스케줄을 도출할 수 있어야 한다.]]></summary></entry><entry><title type="html">선형계획법 기반 분산에너지시스템 최적화 - 6) 공동주택의 ‘누진제’ 전기요금 (단일계약) 수식</title><link href="http://localhost:4000/linprogsix.html" rel="alternate" type="text/html" title="선형계획법 기반 분산에너지시스템 최적화 - 6) 공동주택의 ‘누진제’ 전기요금 (단일계약) 수식" /><published>2023-04-25T00:00:00+09:00</published><updated>2023-04-25T00:00:00+09:00</updated><id>http://localhost:4000/linprogsix</id><content type="html" xml:base="http://localhost:4000/linprogsix.html"><![CDATA[<p>이전에 건물 내 태양광/배터리 설치 시의 최적 용량/스케줄 도출에 대해 설명했는데, 이는 ‘시간별 요금제를 적용받는 일반용 건물’에 대한 내용이었다. 그런데 주택에서는, ‘누진제’라 불리는, 전기를 많이 쓰면 단가가 올라가 요금이 급증하는 요금 체계를 적용한다.</p>

<p>다들 여름에 집에서 에어컨을 빵빵하게 틀기 부담스러워했던 기억이 있을 것이다. 이는 에어컨 때문에 전기 사용량이 많아지면, 일정 구간부터는 누진제 하에서 높은 kWh당 단가를 적용받아 요금이 급증한다는 것을 어렴풋이나마 알기 때문이다.</p>

<p>이번 포스팅에서는 공동주택의 ‘누진제’ 전기요금 자체에 대한 설명 뿐 아니라, 공동주택 요금제 유형 중 가장 많은 비중을 차지하는 ‘단일계약’을 선형계획법 문제의 목적함수와 제약조건으로 모델링하는 방법을 같이 설명한다.</p>

<p><br /></p>

<h2 id="누진제-전기-사용량-구간별로-증가하는-단가">누진제: 전기 사용량 구간별로 증가하는 단가</h2>

<p>한국전력의 <a href="https://cyber.kepco.co.kr/ckepco/front/jsp/CY/H/C/CYHCHP00206.jsp">‘주택용전력 요금 누진제’</a> 설명을 보면, 누진제의 취지는 에너지 소비 절약과 저소득층 보호이다. 전기를 많이 쓰면 일부 사용량이 높은 단가를 적용받는 사용량 구간에 포함될 것이고, 반대로 전기를 매우 적게 쓰면 낮은 단가를 적용받는 사용량 구간에만 포함될 것이기 때문이다.</p>

<p>주택용 전기요금에는 ‘저압’과 ‘고압’이 있으며, <a href="https://cyber.kepco.co.kr/ckepco/front/jsp/CY/E/E/CYEEHP00101.jsp">구체적인 단가 및 사용량 구간</a>은 아래와 같다. 누진제는 ‘주택’에 대해 적용되므로, 사용량은 ‘1가구’ 기준이다.</p>

<p><img src="/assets/images/linprogsix/table_summer.png" alt="table_summer" class="align-center" />
<img src="/assets/images/linprogsix/table_otherseason.png" alt="table_otherseason" class="align-center" />
<em>주택용 전기요금표. 위쪽 표는 7월/8월에 대해, 아래쪽 표는 나머지 월에 대해 적용됨.</em></p>

<p>위 표 중 고압 요금제에 대해 ‘사용량에 따른 가구당 월 전기요금’을 그래프로 그려보면 아래와 같다.</p>

<p><img src="/assets/images/linprogsix/graph.png" alt="graph" class="align-center" width="80%" />
<em>사용량에 따른 가구당 월 전기요금의 그래프 (고압 기준).</em></p>

<p>사용량이 증가함에 따라 구간이 변경되면서 기울기가 증가함을 볼 수 있다. 이렇듯 ‘많이 쓰면 단가가 높아지기’ 때문에, 누진제는 전기 과소비를 억제하는 효과가 있다.</p>

<p>(참고로 7월/ 8월과 기타계절의 구간 기준이 다르다. 원래는 같았으나, 여름철의 가정 내 냉방기기 사용으로 인한 서민들의 전기요금 부담을 완화하기 위해 정부에서 2019년부터 7월/ 8월의 구간 기준 완화를 상시화하였다.)</p>

<p><br /></p>

<h2 id="아파트의-주택용-전기요금-계약-방식-단일계약과-종합계약">아파트의 주택용 전기요금 계약 방식: 단일계약과 종합계약</h2>

<p>아파트의 경우 기본적으로 위와 같은 누진제 기반 주택용 전기요금을 적용받되, 구체적으로는 아래 3가지 방법 중 하나를 적용받는다.</p>

<div class="notice--info">

아파트의 전기요금 계약방법 (<a href="https://cyber.kepco.co.kr/ckepco/front/jsp/CY/H/C/CYHCHP00207.jsp">한국전력 상세설명 페이지</a>) <br /><br />

1) 호별계약 : 아파트의 독립된 각 1호에 대하여 저압으로 전기를 공급하는 고객에게 적용 <br /><br />

2) 단일계약 : 공동설비 사용량을 포함한 전체 사용전력량을 주택용전력 적용대상 호수로 나누어서 평균사용량을 산출하고 이에 대한 기본요금 및 전력량요금에 주택용전력 적용대상 호수를 곱한 것을 주택용전력 적용대상 전체 기본요금 및 전력량요금으로 하는 방법 <br /><br />

3) 종합계약 : 종합계약 방법이란 아파트 1구내에 고압 이상의 전압으로 전기를 공급하고, 세대별 사용량은 단독주택과 동일하게 주택용 저압요금을 적용하고, 공동설비 사용량은 일반용(갑) 고압요금을 적용하여 요금을 계산하는 방법 
</div>

<p>이 중 가장 빈도가 높은 계약 방법은 ‘단일계약’이다. <a href="https://www.electimes.com/news/articleView.html?idxno=318468">해당 기사</a>에 따르면, 2022년 기준 고압 아파트들의 74.3%가 단일계약을 적용받는다.</p>

<p>비록 위 기사의 주제는 ‘단일계약에서 종합계약으로의 전환 추진’ 이긴 하지만, 종합계약의 확산까지는 시간이 걸릴 것으로 보인다. 종합계약 하에서는 각 가구 별 사용량 및 공용 사용량을 개별적으로 정확히 계측해야 하며, 이를 위해서는 원격검침인프라의 확산이 필요하기 때문이다.</p>

<p>반면 단일계약 하에서는 총 전기 사용량 (가구 별 사용량 뿐 아니라 공용 사용량까지의 합) 만 알면, 이를 세대 수로 나누어 세대별 전기요금을 구할 수 있다. (이 경우 전기를 평균보다 적게 쓴 세대가 불리해지는 공정성 이슈가 발생하지만, 여기서는 논외로 한다.)</p>

<p><br /></p>

<h2 id="단일계약-아파트에-대한-선형계획법의-목적함수-제약조건-구성">단일계약 아파트에 대한 선형계획법의 목적함수/ 제약조건 구성</h2>

<p>단일계약 아파트인 경우, 선형계획법을 적용해서 분산에너지 시스템 도입 시의 경제성 분석을 하기 용이하다. 보통 아파트의 ‘시간별 총 사용 전력’만 주어지고 세대별 사용량은 주어지지 않는데, 단일계약이면 총 사용 전력만으로도 세대별 전기요금을 계산할 수 있기 때문이다.</p>

<p>아파트가 시간 $t$에서 계통으로부터 수전받는 총 전기 에너지를 $p_{\text{grid}}[t]$라 하자 (세대당이 아니라 총 합임에 주의). 이 때 각 월 별 전기요금을 계산하기 위해서는, 각 월에 포함되는 모든 시간의 $p_{\text{grid}}[t]$의 합을, 누진제 구간별 사용량으로 변환해야 한다.</p>

<p>이를테면 1월의 경우 인덱스로 치면 $t=1,2,\cdots,744$에 해당한다 ($744=24 \times 31$). 한편 전력량 요금 계산 시 구간은 3개이므로 (세대당 200kWh 이하/ 200~400kWh/ 400kWh 초과), $m$번째 월의 각 구간에 대응하는 총 전력량을 $p_{0}[m]$, $p_{1}[m]$, $p_{2}[m]$로 둘 수 있다. 이 때, 아파트의 세대 수를 $h$라 하면, 아래 제약조건들이 성립해야 한다.</p>

<p>$ \sum_{t=1}^{744} p_{\text{grid}}[t] = p_{0}[1] + p_{1}[1] + p_{2}[1]$</p>

<p>$ p_{0}[1] \leq 200h$, $ p_{1}[1] \leq 200h$</p>

<p>위에서 $p_{0}[1]$와 $p_{1}[1]$의 상한이 $200$이 아니라 $200h$로, 세대 수 $h$가 곱해졌음에 주의한다. $p_{\text{grid}}[t]$가 ‘아파트 전체’의 전기 사용량이기 때문에 세대 수를 곱해야 한다.</p>

<p>이 때 3개 구간 각각의 전력량 요금 단가를 $c_{0}^{\text{energy}}$, $c_{1}^{\text{energy}}$, $c_{2}^{\text{energy}}$ 라 하면, ‘아파트 전체가 지불하는’ 1월의 총 전력량 요금은 아래와 같이 계산되어 목적함수에 포함될 것이다.</p>

<p>$ c_{0}^{\text{energy}} p_{0}[1] + c_{1}^{\text{energy}} p_{1}[1] + c_{2}^{\text{energy}} p_{2}[1]$</p>

<p><br />
전기요금을 계산하려면 전력량요금 뿐 아니라 기본요금도 반영해야 한다. 기본요금은 ‘다음 구간 진입 여부’에 따라 증가하므로, ‘여부를 가리는’ 조건을 구현하기 위해서는 ‘이진수’ 변수를 추가해야 한다.</p>

<p>$m$월에 대한 이진수 변수 두 개 $b_{1}[m]$, $b_{2}[m]$을 정의하자. 그리고 세대당 전기 사용량이 200kWh를 초과하면 $b_{1}[m]=1$이고 200kWh 이하면 $b_{1}[m]=0$이라 하자. 마찬가지로 세대당 전기 사용량이 400kWh를 초과하면 $b_{2}[m]=1$이고 400kWh 이하면 $b_{2}[m]=0$이라 하자.</p>

<p>그러면 $p_{0}[1]$, $p_{1}[1]$, $p_{2}[1]$의 상한에 대한 제약은, 이진수 변수를 포함해 아래와 같이 바뀐다 (아래에서 $M$은 매우 큰 양수이다).</p>

<p>$ p_{0}[1] \leq 200h$, $ p_{1}[1] \leq 200h b_{1}[1]$, $ p_{2}[1] \leq M b_{2}[1]$</p>

<p>그리고 3개 구간 각각의 세대당 월 기본요금을 $c_{0}^{\text{demand}}$, $c_{1}^{\text{demand}}$, $c_{2}^{\text{demand}}$ 라 하면, ‘아파트 전체가 지불하는’ 1월의 총 기본 요금은 아래와 같이 계산되어 목적함수에 포함될 것이다.</p>

<p>$ \lbrace c_{0}^{\text{demand}} + (c_{1}^{\text{demand}}-c_{0}^{\text{demand}}) b_{1}[1] + (c_{2}^{\text{demand}}-c_{1}^{\text{demand}}) b_{2}[1] \rbrace h$</p>

<p>세대당 전력량이 200~400kWh면 $b_{1}[1]=1$이 되므로 $c_{0}^{\text{demand}}$이 cancel out되어 $c_{1}^{\text{demand}}$만 남는다. 마찬가지로 세대당 전력량이 400kWh를 초과하면 $b_{1}[1]=1$, $b_{2}[1]=1$이 되므로 $c_{1}^{\text{demand}}$도 cancel out되어 $c_{2}^{\text{demand}}$만 남는다. 한편, 위에서 맨 마지막에 세대 수 $h$를 곱함에 주의한다.</p>

<div class="notice--info">

선형계획법 기반 분산에너지시스템 최적화<br /><br />

1) <a href="/linprogone.html">최소비용 시스템과 시간별 자료의 중요성</a><br />
2) <a href="/linprogtwo.html">배터리의 충/방전 스케줄 결정: 수식</a> <br />
3) <a href="/linprogthree.html">배터리의 충/방전 스케줄 결정: Python 코드 및 결과</a> <br />
4) <a href="/linprogfour.html">태양광과 배터리의 '용량' 결정 (코드 및 결과 포함)</a> <br />
5) <a href="/linprogfive.html">정수 (integer) 변수 도입으로 현실 설명력 증대</a> <br />
6) <b>공동주택의 '누진제' 전기요금 (단일계약) 수식</b> <br />
7) <a href="/linprogseven.html"> 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</a> <br />
8) <a href="/linprogeight.html"> '부분'부하 성능 관련 제약들</a> <br />
9) <a href="/linprognine.html"> 출력 조정 관련 제약들</a>

</div>

<p><br />
(선형계획법 시리즈의 지식들은, 필자가 2012년부터 <a href="http://www.besico.co.kr/">(주)블루이코노미전략연구원 (대표: 오시덕 박사)</a>과 함께 선형계획법 기반으로 신재생 및 열병합 에너지 시스템 경제성분석/ 최적 에너지시스템 도출 Tool 개발/ 에너지 정책 효과 분석 관련 프로젝트들을 여러 건 수행하며 축적한 ‘기본 지식’에 해당하는 부분임을 밝힌다.)</p>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="optimalsystem" /><category term="선형계획법" /><category term="부하패턴" /><category term="경제성분석" /><category term="Python" /><summary type="html"><![CDATA[이전에 건물 내 태양광/배터리 설치 시의 최적 용량/스케줄 도출에 대해 설명했는데, 이는 ‘시간별 요금제를 적용받는 일반용 건물’에 대한 내용이었다. 그런데 주택에서는, ‘누진제’라 불리는, 전기를 많이 쓰면 단가가 올라가 요금이 급증하는 요금 체계를 적용한다.]]></summary></entry><entry><title type="html">선형계획법 기반 분산에너지시스템 최적화 - 5) 정수 (integer) 변수 도입으로 현실 설명력 증대</title><link href="http://localhost:4000/linprogfive.html" rel="alternate" type="text/html" title="선형계획법 기반 분산에너지시스템 최적화 - 5) 정수 (integer) 변수 도입으로 현실 설명력 증대" /><published>2023-04-24T00:00:00+09:00</published><updated>2023-04-24T00:00:00+09:00</updated><id>http://localhost:4000/linprogfive</id><content type="html" xml:base="http://localhost:4000/linprogfive.html"><![CDATA[<p>지금까지의 선형계획 관련 포스팅들에서는, 모든 변수들을 ‘음이 아닌 실수’ 라고 가정했다. 그러나, 만약 규격 용량이 정해진 발전기를 도입한다면, ‘이 발전기를 3.5대 도입하는 것이 최적이다’ 라고 보고하는 것은 비현실적이다. 발전기 대수는 3대 또는 4대이기 때문이다.</p>

<p>이런 발전기의 ‘대수’는 정수 (integer) 이기 때문에, 현실적인 결과를 원한다면 최적해에서도 정수로 도출되어야 한다. 이번 포스팅에서는 특정 변수가 정수로 강제되는 선형계획 문제에 대해 설명한다.</p>

<p><br /></p>

<h2 id="정수-변수-예시-풍력-발전기의-대수">정수 변수 예시: 풍력 발전기의 ‘대수’</h2>

<p>정수 변수 사용 예시로, 필자가 <a href="https://doi.org/10.1016/j.apenergy.2018.04.131">Applied Energy에 제1저자로써 게재했던 논문</a>의 최적화 문제를 들고자 한다. <a href="mypaperone">해당 논문에 대해 필자가 이미 설명해놓은 포스팅</a>이 있으니, 참고 바란다.</p>

<p>대상 에너지시스템은 태양광 + 풍력 + 디젤 + ESS로 전기부하를 공급하며 중앙계통과는 분리되어 있다 (녹색섬이라 생각하자).</p>

<p>혹시 재생발전량이 0이더라도, 디젤발전기만으로 부하 충족 자체는 가능하다. 반대로 재생발전량이 너무 많아 부하 충족은 물론 ESS 완충까지 하더라도 전기가 남을 경우 이는 특별한 용도 없이 dump load에서 소비된다, 즉 출력제한(curtail)된다. 이 때 녹색섬이라 불리려면, 전체 전기에너지 수요의 일정 비율은 재생발전으로 충당해야 한다.</p>

<p><img src="/assets/images/mypaperone/islandsystem.png" alt="islandsystem" class="align-center" />
<em>태양광/ 풍력/ 디젤/ ESS로 이루어진 섬 전기 공급 시스템 도식도. 잉여전력을 버릴 수 있음.</em></p>

<p>특정 기간의 시간별 전기부하, 일사량, 풍속을 input 자료로 사용하여, 재생발전기 초기설치비용과 운영기간 내 디젤 연료비의 총 합을 최소화하는 태양광/ 풍력/ ESS 각각의 용량을 도출하는 최적화 문제를 풀어서 결정할 수 있다. 수식은 아래와 같다.</p>

<p>Minimize $c_{\text{pv}} s_{\text{pv}} + c_{\text{wt}} s_{\text{wt}} + c_{\text{batt}} s_{\text{batt}} + c_{\text{diesel}} \sum_{t} p_{\text{diesel}}[t] + \epsilon \sum_t ( p_{\text{disch}}[t] + p_{\text{ch}}[t] )$</p>

<p>Subject to</p>

<p>$p_{\text{load}}[t] = p_{\text{diesel}}[t] + s_{\text{pv}} p_{\text{pv}}[t] + s_{\text{wt}} p_{\text{wt}}[t] + p_{\text{disch}}[t] – p_{\text{ch}}[t] – p_{\text{dump}}[t] \quad \forall t$</p>

<p>$e_{\text{batt}}[t+1] = e_{\text{batt}}[t] + \mu p_{\text{ch}}[t] – p_{\text{disch}} /\mu \quad \forall t$</p>

<p>$ e_{\text{batt}}[t] \leq s_{\text{batt}}  \quad \forall t$</p>

<p>$ p_{\text{ch}}[t] \leq \gamma s_{\text{batt}} \quad \forall t$</p>

<p>$ p_{\text{disch}}[t] \leq \gamma s_{\text{batt}} \quad \forall t$</p>

<p>$ \sum_{t} p_{\text{diesel}}[t] \leq (1-\alpha_{\text{renewable}}) \sum_{t} p_{\text{load}}[t] $</p>

<p>위에서 $c$는 비용, $s$는 용량, $p$는 전력, $e$는 저장된 에너지, $\mu$는 효율, $\alpha$는 규정 비율이며, pv는 태양광, wt는 풍력, batt는 배터리, load는 부하, diesel은 디젤엔진, ch는 충전, disch는 방전, dump는 출력제한이다. $s_{\text{wt}}$는 풍력 발전기의 대수이므로 음이 아닌 정수(nonnegative integer)이며, 나머지는 음이 아닌 실수들이다. 비용은 태양광/ 풍력/ 배터리에 대해서는 단위 용량당 초기투자비, 디젤에 대해서는 연료비이다.</p>

<p>$\epsilon$은 ‘같은 시간에는 충전과 방전 둘 중 하나 이상은 0’이 되게 만드는 데 필요한 penalty term의 계수인데, 이에 대해서는 <a href="https://doi.org/10.1016/j.apenergy.2018.04.131">필자의 논문 설명 포스팅</a>을 참고하기 바란다.</p>

<p>이 문제에서 도출한 태양광/ 풍력/ 배터리 용량은, 디젤 발전기를 통해 공급되는 전기에너지의 비중이 전체의 $1-\alpha_{\text{renewable}}$ 이하가 되게 만드는 용량이다. 이를테면 $\alpha_{\text{renewable}}=0.6$인 경우, 연간 총 전기에너지 수요 중 최대 40%까지만 디젤 발전기로 충당될 수 있다는 제약 하에 시스템 구성을 도출한다.</p>

<p>이 때, 풍력 대수 변수 $s_{\text{wt}}$는 ‘정수로 강제’한다.</p>

<p>(태양광과 배터리의 경우 구성 단위인 모듈 당 용량이 작으므로, $s_{\text{pv}}$와 $s_{\text{batt}}$를 연속변수로 봐도 실제 설치 가능 용량과 큰 차이가 나지 않을 것이라 보았다.)</p>

<p>참고로 풍력 대수 변수 $s_{\text{wt}}$의 계수 $p_{\text{wt}}[t]$는 풍력 ‘1대당’ 시간별 발전량이며, 이는 풍속과 풍력발전의 성능곡선을 통해 계산된 전력에 변환기/ 변압기 효율을 곱한, 즉 부하에 최종적으로 전달되는 교류전력 값이다.</p>

<p>시간별 풍력 발전량 데이터가 이상하지 않은지 확인하기 위해서는, 이전 포스팅에서 언급한 ‘이용률’을 체크해 보아야 한다. 풍력의 이용률은 장소 및 터빈 높이에 따라 그 편차가 크지만, 국내에서는 대략 15~40% 정도이다.</p>

<p><br /></p>

<h2 id="풍력-대수-변수-정수-를-포함하는-문제-코드">풍력 대수 변수 (정수) 를 포함하는 문제 코드</h2>

<p>위 문제를 Python cvxopt로 푸는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">cvxopt</span> <span class="kn">import</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">spmatrix</span><span class="p">,</span> <span class="n">sparse</span><span class="p">,</span> <span class="n">glpk</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="n">penetration</span> <span class="o">=</span> <span class="mf">0.6</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.94</span>
<span class="n">cost_diesel</span><span class="o">=</span> <span class="mi">300</span> <span class="c1"># 디젤발전기로 발전된 전기 1kWh당 투입연료비
</span><span class="n">c_rate_batt</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">penaltycoeff</span> <span class="o">=</span> <span class="mf">0.01</span> <span class="c1"># 동시 충/방전 오류를 막기 위한 penalty term의 계수 (너무 낮으면 오류 생김)
</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="c1"># 화폐가치 하락에 대한 할인율
</span>
<span class="n">initialcost_pv</span> <span class="o">=</span> <span class="mi">3000000</span> <span class="c1"># 태양광 1kW당 초기투자비
</span><span class="n">initialcost_wt</span> <span class="o">=</span> <span class="mi">80000000</span> <span class="c1"># 풍력 1대당 초기투자비
</span><span class="n">initialcost_batt</span> <span class="o">=</span> <span class="mi">900000</span> <span class="c1"># 배터리 1kWh당 초기투자비 (SOC 고려한 실용량 가정)
</span><span class="n">mtncost_pv</span> <span class="o">=</span> <span class="n">initialcost_pv</span> <span class="o">*</span> <span class="mf">0.02</span> <span class="c1"># 태양광 1kW당 유지보수비 (매년 발생) 
</span><span class="n">mtncost_wt</span> <span class="o">=</span> <span class="n">initialcost_wt</span> <span class="o">*</span> <span class="mf">0.02</span> <span class="c1"># 풍력 1대당 유지보수비 (매년 발생)
</span><span class="n">mtncost_batt</span> <span class="o">=</span> <span class="n">initialcost_batt</span> <span class="o">*</span> <span class="mf">0.01</span> <span class="c1"># 배터리 1kWh당 유지보수비 (매년 발생)
</span>

<span class="n">t</span><span class="o">=</span><span class="mi">8760</span>

<span class="n">demand_island</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"load_hourly.txt"</span><span class="p">)</span> 
<span class="n">renewable_output</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">loadtxt</span><span class="p">(</span><span class="s">"renewables_hourly.txt"</span><span class="p">)</span>  
<span class="n">totaldemand</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">demand_island</span><span class="p">))</span>

<span class="n">pvoutput</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">renewable_output</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># 1kW 태양광 패널의 시간별 전기 출력
</span><span class="n">wtoutput</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">renewable_output</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span> <span class="c1"># 대상 규격 풍력터빈 1대의 시간별 전기 출력
</span>
<span class="k">def</span> <span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">spmatrix</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">),</span><span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_ones</span><span class="p">(</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">(</span><span class="nf">matrix</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">block_batt</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="k">return</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span> <span class="o">-</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">size</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>


<span class="n">Aeq_balance</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span> <span class="p">[</span><span class="n">pvoutput</span><span class="p">],[</span><span class="n">wtoutput</span><span class="p">],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">beq_balance</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">(</span><span class="n">demand_island</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">],</span><span class="n">tc</span><span class="o">=</span><span class="s">'d'</span><span class="p">)</span>

<span class="n">Aeq_batterydynamic</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="o">-</span><span class="n">eff_batt</span><span class="o">*</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">/</span><span class="n">eff_batt</span><span class="p">],[</span><span class="nf">block_batt</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">beq_batterydynamic</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumstored</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="o">-</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumstored</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumcharge</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="o">-</span><span class="n">c_rate_batt</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumcharge</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_maximumdischarge</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_eye</span><span class="p">(</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)],[</span><span class="o">-</span><span class="n">c_rate_batt</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)]])</span>
<span class="n">b_maximumdischarge</span> <span class="o">=</span> <span class="nf">block_zeros</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">A_penetration</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([[</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span>
<span class="n">b_penetration</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([(</span><span class="mi">1</span><span class="o">-</span><span class="n">penetration</span><span class="p">)</span><span class="o">*</span><span class="n">totaldemand</span><span class="p">])</span>

<span class="n">lowerbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span> 
<span class="n">upperbounds</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">initialenergy_batt</span><span class="p">])],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)]])</span> 

<span class="n">A_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="nf">block_eye</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b_lowerbound</span> <span class="o">=</span> <span class="o">-</span><span class="n">lowerbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">A_upperbound</span> <span class="o">=</span> <span class="nf">block_eye</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span>
<span class="n">b_upperbound</span> <span class="o">=</span> <span class="n">upperbounds</span><span class="p">.</span><span class="n">T</span>

<span class="n">Aeq</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">Aeq_balance</span><span class="p">,</span><span class="n">Aeq_batterydynamic</span><span class="p">])</span>
<span class="n">beq</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">beq_balance</span><span class="p">,</span><span class="n">beq_batterydynamic</span><span class="p">])</span>

<span class="n">A</span> <span class="o">=</span> <span class="nf">sparse</span><span class="p">([</span><span class="n">A_maximumstored</span><span class="p">,</span> <span class="n">A_maximumcharge</span><span class="p">,</span> <span class="n">A_maximumdischarge</span><span class="p">,</span> <span class="n">A_penetration</span><span class="p">,</span> <span class="n">A_lowerbound</span><span class="p">,</span> <span class="n">A_upperbound</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([</span><span class="n">b_maximumstored</span><span class="p">,</span> <span class="n">b_maximumcharge</span><span class="p">,</span> <span class="n">b_maximumdischarge</span><span class="p">,</span> <span class="n">b_penetration</span><span class="p">,</span> <span class="n">b_lowerbound</span><span class="p">,</span> <span class="n">b_upperbound</span><span class="p">])</span>

<span class="n">npvfactor</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">20</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">)))</span> <span class="c1"># 초항이 (1+r)^{-1}, 마지막항이 (1+r)^{20}인 등비수열의 합
</span><span class="n">costfun_pv</span> <span class="o">=</span> <span class="n">initialcost_pv</span> <span class="o">+</span> <span class="n">mtncost_pv</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 초기투자비 + 매년 유지보수비(npvfactor를 곱해 현가화)
</span><span class="n">costfun_wt</span> <span class="o">=</span> <span class="n">initialcost_wt</span> <span class="o">+</span> <span class="n">mtncost_wt</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 초기투자비 + 매년 유지보수비(npvfactor를 곱해 현가화)
</span><span class="n">costfun_batt</span> <span class="o">=</span> <span class="n">initialcost_batt</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">r</span><span class="p">))</span><span class="o">**</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="n">mtncost_batt</span> <span class="o">*</span> <span class="n">npvfactor</span> <span class="c1"># 초기투자비 + 10년 후 재투자비(현가화) + 매년 유지보수비 (현가화)
</span><span class="n">costfun_diesel</span> <span class="o">=</span> <span class="n">cost_diesel</span> <span class="o">*</span> <span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">npvfactor</span>  <span class="c1"># 전기 사용량 요금 (현가화)
</span>

<span class="n">c</span> <span class="o">=</span> <span class="nf">matrix</span><span class="p">([[</span><span class="n">costfun_diesel</span><span class="p">],[</span><span class="n">penaltycoeff</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="n">penaltycoeff</span><span class="o">*</span><span class="nf">block_ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)],[</span><span class="nf">block_zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">t</span><span class="p">)],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_pv</span><span class="p">])],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_wt</span><span class="p">])],[</span><span class="nf">matrix</span><span class="p">([</span><span class="n">costfun_batt</span><span class="p">])]])</span> <span class="c1"># 이거 sparse로 하면 셧다운되는데 matrix로 하면 잘 됨...왜지..
</span>
<span class="n">idx_pv</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">idx_wt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="c1"># 변수 벡터 x에서 풍력터빈 대수 변수의 인덱스
</span><span class="n">idx_batt</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

<span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="p">(</span><span class="n">status</span><span class="p">,</span><span class="n">x</span><span class="p">)</span><span class="o">=</span><span class="n">glpk</span><span class="p">.</span><span class="nf">ilp</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="n">beq</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="nf">set</span><span class="p">([</span><span class="n">idx_wt</span><span class="p">]))</span> <span class="c1"># 풍력터빈 대수 변수를 정수로 제한
</span><span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>

<span class="n">p_ch</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x</span><span class="p">[(</span><span class="n">t</span><span class="p">):(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)])</span>
<span class="n">p_disch</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">x</span><span class="p">[(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">):(</span><span class="mi">3</span><span class="o">*</span><span class="n">t</span><span class="p">)])</span>
<span class="n">indicator_error</span> <span class="o">=</span> <span class="p">(</span><span class="n">p_ch</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">p_disch</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="k">if</span> <span class="n">indicator_error</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">'경고: 같은 시간에 충전과 방전이 동시에 양수가 되는 오류가 발생했습니다.'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'태양광 {}kW, 풍력 {}기, 배터리 {}kWh입니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">idx_pv</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">idx_wt</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">idx_batt</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="s">'{}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="nf">print</span><span class="p">((</span><span class="n">c</span><span class="o">*</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">penaltycoeff</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">p_ch</span><span class="o">+</span><span class="n">p_disch</span><span class="p">))</span> <span class="c1"># 총 비용 (penalty term의 값 제함)
</span></code></pre></div></div>

<p>위 코드에서 주목할 부분은, $\texttt{glpk.ilp}$ 이다. 정수 변수가 없을 때의 메서드는 $\texttt{glpk.lp}$ 였는데, 마침표 뒤에 $\texttt{i}$가 추가되었다. I는 integer를 의미하며, 이 메서드로 ‘정수’선형계획 (Mixed-integer Linear Programming, MILP) 문제를 푼다.</p>

<p>또한 메서드의 마지막 인수로 $\texttt{ I=set([idx_wt]) }$ 가 추가되었다. 이는 최적화 문제의 모든 변수들을 담는 벡터 $\textbf{x}$ 내에서 정수 변수들의 위치를 담는 리스트이다. 이 문제에서는 $\texttt{idx_wt}$의 값이 43082인데, 이는 $s_{\text{wt}}$가  $\textbf{x}$의 43803번째 원소임을 의미한다 (Python에서는 배열의 인덱스가 0부터 시작하므로).</p>

<p><br /></p>

<h2 id="이진수-도입을-통한-모델-현실-설명력-증가-용량에-비례하지-않는-비용">‘이진수’ 도입을 통한 모델 현실 설명력 증가: 용량에 비례하지 않는 비용</h2>

<p>정수 변수 활용 사례는 이 외에도 많다. 여기서는 최적화 문제의 현실 설명력을 높이기 위한 ‘이진수’ 변수 활용 사례를 설명한다.</p>

<p>지금까지의 분석에서는 초기투자비가 설비 용량에 정비례한다고 암묵적으로 가정했다. 그러나 실제로는 용량에 정비례하지 않는 비용이 존재할 수 있다. 경우에 따라선 이 비용을 경제성 분석에 반영해야 할 수 있다.</p>

<p>이를 테면 위 사례에서, 풍력을 설치하지 않으면 전혀 들지 않지만, 풍력을 한 대라도 설치하면 고정적으로 필요한 유관 비용 $c_{\text{misc}}$가 존재한다고 가정하자. 그리고 일단 풍력을 도입한다면, 이 유관 비용은 풍력 대수가 몇 대이든 비슷하다고 가정하자.</p>

<p>(이는 풍력발전 도입 사업 준비 과정에서의 풍황계측/ 타당성조사/ 인허가취득 관련 soft cost일 수도 있고, 안전 관련 비용일 수도, 부지 관련 공사 비용일 수도 있다. 필자도 사실 정확히 아는 건 아니다만… 아무튼 일반적으로 설비 규모보다는 설비 도입 여부 자체에 크게 좌우되는 비용이 존재할 수 있다.)</p>

<p>즉 $s_{\text{wt}}=0$이면 목적함수에 $c_{\text{misc}}$가 더해지면 안 되지만, $s_{\text{wt}}&gt;0$이면 목적함수에 $c_{\text{misc}}$가 더해져야 한다.</p>

<p><br />
이를 반영하기 위해서는, ‘이진수’ 변수 $b_{\text{wt}} \in \lbrace 0,1 \rbrace$와 ‘매우 큰 양수 계수 $M$’을 도입해 아래 제약을 추가한다.</p>

<p>$ s_{\text{wt}} \leq M b_{\text{wt}} $</p>

<p>만약 $b_{\text{wt}}=0$이면, $s_{\text{wt}} \leq 0$이 되므로 반드시 $s_{\text{wt}} = 0$이다. 반대로 $b_{\text{wt}}=1$이면, $s_{\text{wt}} \leq M$이고 $M$은 매우 큰 양수이므로 사실상 $s_{\text{wt}}$에 대한 추가 제약이 없는 셈이다.</p>

<p>그리고 기존의 목적함수에는 $c_{\text{misc}} b_{\text{wt}}$ 를 더한다. 그러면 풍력발전기가 한 대도 도입되지 않을 경우 목적함수 최소화를 위해 $b_{\text{wt}}=0$이 되어 $c_{\text{misc}}$가 비용에 반영되지 않고, 한 대라도 도입되면 반드시 $b_{\text{wt}}=1$이므로 $c_{\text{misc}}$가 비용에 반영된다.</p>

<p>마지막으로, 변수 $b_{\text{wt}}$를 ‘이진수’로 강제해야 하는 코드를 추가한다. 이는 $\texttt{glpk.ilp}$의 메서드에서, 위 풍력 대수 구하는 문제에서 언급한 $\texttt{ I=set([]) }$를 $\texttt{ B=set([]) }$로, 즉 $\texttt{I}$를 $\texttt{B}$로 바꾸면 된다 (B는 binary를 의미한다).</p>

<p><br /></p>

<h2 id="이진수-도입을-통한-모델-현실-설명력-증가-용량당-단가가-다를-경우">‘이진수’ 도입을 통한 모델 현실 설명력 증가: 용량당 단가가 다를 경우</h2>

<p>이진수 변수 도입은, 용량에 따라 단위용량당 비용을 다르게 적용해야 하는 경우에도 쓸 수 있다.</p>

<p>필자가 이전에 수행했던 프로젝트 중에, ‘태양광 용량이 1000kW 이하면 kW당 단가를 $c_{\text{pv}.1}$로, 1000kW 이상이면 kW당 단가를 $c_{\text{pv}.2}$로 적용’할 것을 요구받은 적이 있다. 1000kW 이상의 대량 발주 시 단가를 상대적으로 낮출 수 있다는 이유였던 것으로 기억한다. 즉 $c_{\text{pv}.1}&gt;c_{\text{pv}.2}$이다.</p>

<p>(이는 용량이 1500kW인 경우 1000kW에 대해서는 단가 $c_{\text{pv}.1}$을, 나머지 500kW에 대해서는 단가 $c_{\text{pv}.2}$를 적용하는 것이 아님에 주의. 1500kW 전부에 대해 단가 $c_{\text{pv}.2}$를 적용하는 것이다.)</p>

<p>이 경우, 우선 태양광 용량 변수도 ‘1000kW 이하인 경우에 대한 변수’ $s_{\text{pv}.1}$과, ‘1000kW 이상인 경우에 대한 변수’ $s_{\text{pv}.2}$ 두 개를 정의한다. 그리고 목적함수에는 $c_{\text{pv}.1} s_{\text{pv}.1} + c_{\text{pv}.2} s_{\text{pv}.2} $ 를 추가한다.</p>

<p>이제 두 용량 변수의 범위를 표현하는 제약조건들을 추가해야 한다. 아래 두 제약조건을 추가하면 될까?</p>

<p>$s_{\text{pv}.1} \leq 1000$, $s_{\text{pv}.2} \geq 1000$</p>

<p>그렇지 않다. 제약조건 $s_{\text{pv}.2} \geq 1000$ 때문에 $s_{\text{pv}.2}$가 반드시 1000kW 이상이 되어야 하기 때문이다. 실제로는 태양광을 아예 도입하지 않거나 1000kW 미만으로 도입하는 경우도 있을 텐데, 그런 경우를 표현할 수 없다.</p>

<p>이 경우에도 이진수 $b$를 도입해야 한다. 이진수 $b$가 0이면 1000kW 이하 도입에 대응하고 (도입 안 하는 경우도 포함), $b$가 1이면 1000kW 이상 도입에 대응한다고 하자. 그러면 ‘매우 큰 양수 계수’를 $M$이라 할 때, 아래 제약조건들을 추가하면 된다.</p>

<p>$s_{\text{pv}.1} \leq 1000 \times (1-b)$, $ 1000 b \leq s_{\text{pv}.2} \leq M b$</p>

<p>$b=0$이면 $s_{\text{pv}.1} \leq 1000$이고 $s_{\text{pv}.2} \leq 0$이 되어, $s_{\text{pv}.1}$만 양수가 되고 그 값은 1000 이하로 제한된다. 반대로 $b=1$이면 $s_{\text{pv}.1} \leq 0$이고 $1000 \leq s_{\text{pv}.2} $가 되어, $s_{\text{pv}.2}$만 양수가 되고 그 값은 1000 이상으로 제한된다.</p>

<p><br /></p>

<p>(이런 식의 이진수 활용 사례는 몇 가지가 더 있다. 특히 추후에 ‘주택의 누진요금제’ 관련 포스팅 및 ‘화석연료를 소비하는 중대형 발전기’의 운전 조건 관련 포스팅 등에서 다시 등장할 예정이다.)</p>

<div class="notice--info">

선형계획법 기반 분산에너지시스템 최적화<br /><br />

1) <a href="/linprogone.html">최소비용 시스템과 시간별 자료의 중요성</a><br />
2) <a href="/linprogtwo.html">배터리의 충/방전 스케줄 결정: 수식</a> <br />
3) <a href="/linprogthree.html">배터리의 충/방전 스케줄 결정: Python 코드 및 결과</a> <br />
4) <a href="/linprogfour.html">태양광과 배터리의 '용량' 결정 (코드 및 결과 포함)</a> <br />
5) <b>정수 (integer) 변수 도입으로 현실 설명력 증대</b> <br />
6) <a href="/linprogsix.html">공동주택의 '누진제' 전기요금 (단일계약) 수식</a> <br />
7) <a href="/linprogseven.html"> 전기 부하와 냉/난방 부하를 동시에 고려 (섹터커플링)</a> <br />
8) <a href="/linprogeight.html"> '부분'부하 성능 관련 제약들</a> <br />
9) <a href="/linprognine.html"> 출력 조정 관련 제약들</a>

</div>

<p><br />
(선형계획법 시리즈의 지식들은, 필자가 2012년부터 <a href="http://www.besico.co.kr/">(주)블루이코노미전략연구원 (대표: 오시덕 박사)</a>과 함께 선형계획법 기반으로 신재생 및 열병합 에너지 시스템 경제성분석/ 최적 에너지시스템 도출 Tool 개발/ 에너지 정책 효과 분석 관련 프로젝트들을 여러 건 수행하며 축적한 ‘기본 지식’에 해당하는 부분임을 밝힌다.)</p>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="optimalsystem" /><category term="선형계획법" /><category term="부하패턴" /><category term="경제성분석" /><category term="Python" /><summary type="html"><![CDATA[지금까지의 선형계획 관련 포스팅들에서는, 모든 변수들을 ‘음이 아닌 실수’ 라고 가정했다. 그러나, 만약 규격 용량이 정해진 발전기를 도입한다면, ‘이 발전기를 3.5대 도입하는 것이 최적이다’ 라고 보고하는 것은 비현실적이다. 발전기 대수는 3대 또는 4대이기 때문이다.]]></summary></entry><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 3) 월별 사용량 크기가 이상한 data point 제거</title><link href="http://localhost:4000/monthlyenergythree.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 3) 월별 사용량 크기가 이상한 data point 제거" /><published>2023-04-23T00:00:00+09:00</published><updated>2023-04-23T00:00:00+09:00</updated><id>http://localhost:4000/monthlyenergythree</id><content type="html" xml:base="http://localhost:4000/monthlyenergythree.html"><![CDATA[<p><a href="/monthlyenergytwo.html">이전 포스팅</a>에서는 건물 월별 에너지 사용량의 ‘추이’가 이상한 data point를 판별하는 방법을 설명했다. 이번 포스팅에서는 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.</p>

<p><br /></p>

<h2 id="에너지-사용량-크기-측면에서의-outlier">에너지 사용량 크기 측면에서의 outlier</h2>
<p>상식적으로, 같은 용도의 건물이라면 크기가 큰 건물일수록 에너지 사용량이 큰 경향이 있을 것이다. 이를테면 서울 내 업무용 건물들의 1월 전기 사용량을 연면적 (모든 층의 바닥면적의 합, 단 주차장이나 공용시설 등은 제외) 에 대해 scatter plot하면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergythree/outliers.png" alt="outliers" class="align-center" width="70%" />
<em>x축이 연면적, y축이 1월 전기 사용량. 위쪽에 outlier들이 보임 (붉은 점들).</em></p>

<p>다소 데이터의 흩어짐(분산)이 크긴 하나, 어쨌든 연면적이 클수록 ‘평균적으로는’ 전기 사용량이 커지는 경향이 있다.</p>

<p><br />
그런데, 위 그림의 붉은 점들은 딱 봐도 ‘크기가 이상한’ data point, 소위 말해서 ‘outlier’이다. 건물 연면적을 고려했을 때 전기 사용량의 값이 지나치게 크다.</p>

<p>이는 측정/기재 오류일 수도 있고, 어쩌면 정말로 저만큼 많은 전기를 쓰는 것일 수도 있다. 그러나 만에 하나 정말로 저렇게 많은 전기를 사용한다고 하더라도, 그런 건물은 일반적이지 않으므로 따로 떼어서 별도의 모델링을 하는 것이 맞다.</p>

<p>즉, ‘일반적인’ 건물들에 대한 통계적 연구 수행을 위해서는 위 outlier들은 제거해야 한다.</p>

<p><br /></p>
<h2 id="outlier-판별-방법">Outlier 판별 방법</h2>
<p>그럼 outlier는 어떻게 판별하나? 데이터의 size가 그렇게 크지 않고 설명변수가 하나라면, 그냥 그래프를 그려서 눈으로 보고 제거할 수도 있을 것이다. 그러나 데이터 size도 커지고 설명변수도 둘 이상이 되면, 눈으로 보기 매우 힘들다 (이를 테면 반응변수를 에너지 사용량으로 하는 회귀모델에 대해, 설명변수가 건물 연면적 뿐 아니라 건물 층수, 사용연수, 재질 등 여러 가지가 될 수 있다.</p>

<p>그러므로 시각화를 필요로 하지 않으면서 outlier를 판별할 수 있는, 이전 포스팅에서처럼 지표(metric)에 기반해서 판별하는 방법이 필요하다.</p>

<p><br />
여기서 생각해 볼 수 있는 것은, 위 그림에서 outlier들이 있을 때와 없을 때 각 경우에 대해 회귀분석을 했을 때의 직선의 기울기이다. 위 그림 기준으로는 빨간 점들이 없을 때 계산된 직선의 기울기에 비해, 빨간 점들이 있을 때 계산된 직선의 기울기가 더 가파를 것이다. 즉 outlier들이 있을 때 구한 회귀계수와 없을 때 구한 회귀계수 간에 유의미한 차이가 있을 것이다.</p>

<p>반대로, 검정 점들 중 몇 개 정도를 없애고 회귀계수를 계산했다고 하자. 그 결과는 아마, 모든 점들이 있을 때의 회귀계수와 별 차이가 없을 것이다.</p>

<p>그렇다면, 각 data point $i$에 대해, $i$가 포함되어 있을 때 구한 회귀계수와 $i$가 제외될 때 구한 회귀계수 간의 표준화된 차이를 모든 data point들 각각에 대해 구한다면, 그 차이가 큰 data point가 outlier일 것임을 짐작할 수 있다.</p>

<p>이러한 ‘특정 점 $i$의 유무에 따른 회귀계수 간 표준화된 차이’를 Cook’s Distance라 한다. 
$m$월의 전기 사용량을 반응변수로 하는 회귀모델에 대해, Cook’s Distance의 수식은 아래와 같다.</p>

<p>\begin{align} 
D_{i}^{elec,m}=\frac{\left({\hat{\beta}}^{elec,m}-{\hat{\beta}}_{-i}^{elec,m}\right)^{\top}X^{\top}X\left({\hat{\beta}}^{elec,m}-{\hat{\beta}}_{-i}^{elec,m}\right)}{k \cdot MSR^{elec,m}} 
\notag
\end{align}</p>

<p>$\hat{\beta}$는 data point $i$를 포함해 모든 data point들이 있을 때 구한 회귀계수이고, $\hat{\beta}_{-i}$는 data point $i$만을 dataset으로부터 뺐을 때 구한 회귀계수이다. $X$는 설명변수 행렬로, $i$번째 행이 $i$번째 data point에 대한 설명변수들로 구성된 행벡터이다 (여기서 설명변수는 연면적, 층수, 사용연도, 재질, …, 그리고 상수항 표현을 위한 1). 분모의 $k$는 설명변수 개수이고, $MSR$은 잔차의 평균제곱합이다.</p>

<p><br />
이 때, 혹자는 계산시간 관련해서 우려를 표할 수 있다. 만약 data point가 수십만 개면, Cook’s Distance들을 계산하기 위해 수십만 번의 회귀분석을 계산해야 되는 것이 아닐까? 그러면 시간이 너무 오래 걸리지 않을까?</p>

<p>다행히도 그렇지 않다. 단 한 번의 회귀분석과 한 번의 행렬 연산으로, 모든 data point 각각에 대한 Cook’s Distance들을 계산할 수 있다. Cook’s Distance의 다른 식은 아래와 같다.</p>

<p>\begin{align} 
D_{i}^{elec,m}=\frac{\hat{\epsilon}_{i}^{elec,m}h_{ii}}{k \cdot MSR^{elec,m}\left(1-h_{ii}\right)^2}
\notag
\end{align}</p>

<p>여기서 $\hat{\epsilon}_{i}^{elec,m}$는 $i$번째 잔차, $h_{ii}$는 hat matrix $X\left(X^{\top} X \right)^{-1}X^{\top}$의 $i$번째 대각성분이다.</p>

<p>(역시 자세한 내용은 <a href="https://product.kyobobook.co.kr/detail/S000002582053">Montgomery의 Introduction to Linear Regression</a>의 7단원을 참고하길 바란다.)</p>

<p><br />
필자가 알기로는 Cook’s D에는 어떤 rule of thumb로써의 수치가 있지는 않은 듯 하다. 사전에 정의한 갯수만큼의 데이터를, Cook’s D가 큰 순서대로 제거하는 것이 현실적인 방법으로 보인다.</p>

<p>단, 주의할 점은, 한 번의 Cook’s D 계산 후 data point 여러 개를 제거하면 안 된다. Cook’s D가 가장 큰 ‘하나의’ point만 제거하고, 다시 모든 point Cook’s D를 계산해서 또 하나를 제거하고 다시 계산하는 과정을 반복해야 한다.</p>

<p>이는 Cook’s D 자체가 ‘하나의’ data point의 유무 간 차이에 대해 정의되기 때문이다.</p>

<p>만약 어떤 dataset에 대해 Cook’s D를 계산했더니 point $i$에 대해 Cook’s D가 가장 크고 $j$에 대해 Cook’s D가 두 번째로 크다고 하자. 이 때 point $j$에 대한 Cook’s D는, point $i$가 dataset에 있다는 가정 하에 계산된다. 그런데 우리는 outlier를 제거해나가야 하므로, Cook’s D가 가장 큰 outlier $i$가 dataset에 있다는 가정 하에 나머지 point들에 대한 outlier 여부를 판단하는 것은 부자연스럽다.</p>

<div class="notice--info">

건축물 별 월별 에너지 사용량 데이터셋<br /><br />

1) <a href="/monthlyenergyone.html">모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화</a><br />
2) <a href="/monthlyenergytwo.html">월별 사용 추이가 이상한 data point 제거</a><br />
3) <b>월별 사용량 크기가 이상한 data point 제거</b>

</div>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="dataset" /><category term="건물 에너지 데이터" /><category term="회귀분석" /><summary type="html"><![CDATA[이전 포스팅에서는 건물 월별 에너지 사용량의 ‘추이’가 이상한 data point를 판별하는 방법을 설명했다. 이번 포스팅에서는 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.]]></summary></entry><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 2) 월별 사용 추이가 이상한 data point 제거</title><link href="http://localhost:4000/monthlyenergytwo.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 2) 월별 사용 추이가 이상한 data point 제거" /><published>2023-04-22T00:00:00+09:00</published><updated>2023-04-22T00:00:00+09:00</updated><id>http://localhost:4000/monthlyenergytwo</id><content type="html" xml:base="http://localhost:4000/monthlyenergytwo.html"><![CDATA[<p>이전 포스팅에서 건물 에너지 관련 연구를 위한, 각 건물의 지번별/월별 전기/도시가스 사용량 데이터와 표제부의 결합을 소개했다. 그렇다면 결합된 데이터를 그대로 쓰면 되는가? 그렇지 않다. 분명히 ‘이상한’ data point들이 존재할 것이기 때문이다. 데이터 기반의 연구개발을 한다면, 이러한 ‘이상한’ data point들을 제거하거나 수정하는 데이터 전처리는 필수이다.</p>

<p><br /></p>

<h2 id="데이터-전처리-종류">데이터 전처리 종류</h2>

<p>가장 먼저 떠올릴 전처리는, 누락이 있는 point 제거이다. 이미 이전 포스팅의 마지막 부분에서 SQLite DB로부터 서울 내 건물들 중 ‘전기 사용량 및 연면적 값의 누락이 없는’ point들만 불러왔다. 여기에 더해, 봄~가을의 도시가스 사용 내역이 있는데 겨울(12, 1, 2월)의 도시가스 사용 내역이 없는 point는 ‘이상한’ point로 보고 제거한다 (상식적으로 도시가스를 쓴다면 겨울에 집중적으로 쓰는 것이 정상이므로).</p>

<p><br />
그 외에 `이상하다’의 기준은, 크게 다음의 두 가지로 볼 수 있다.</p>

<p>1) 12개월 간 월별 에너지 사용량의 추이가 이상함 (전기 사용량 내역을 봤더니 봄/가을 사용량이 여름 사용량보다 월등히 높다든지)</p>

<p>2) 에너지 사용량의 크기(magnitude)가 이상함 (건물은 작은데 비슷한 크기의 타 건물들 대비 에너지 사용량이 지나치게 크다든지)</p>

<p>이러한 ‘이상함’의 이유를 정확히는 알 수 없다. 그러나 이러한 point들은 ‘일반적인’ 건물들에 대한 통계적 에너지 모델링에 도움이 되기는커녕 오히려 해가 될 것이므로, 조치를 취해야 한다.</p>

<p>(사족: 필자가 한 가지 발견했던 것은, 지하철 역사의 경우 사용량의 크기가 동일 면적의 타 건물들 대비 매우 컸다는 것이다. 지하철 운전을 위한 전기 사용이 각 역 건물에 대해 계량되는 것인지… 물론 정확한 이유는 모른다.)</p>

<p>각 건물의 지번별 데이터는 row의 수가 많다. 서울의 경우 데이터 전처리를 해도 만 단위이다. 데이터가 이 정도로 크면, 회귀분석 등을 할 때 모델을 잘 구성했다는 전제 하에 일관성(consistency)이 있다. 즉, 계수추정량이 실제 값에 가까울 확률이 매우 높다. 그러므로 ‘이상한’ data point는 전부 삭제한다.</p>

<p>이번 포스팅에서는 건물 월별 에너지 사용량의 `추이’가 이상한 data point를 판별하는 방법을 설명한다.</p>

<p><br /></p>

<h2 id="건물-월별-에너지-사용량의-추이">건물 월별 에너지 사용량의 ‘추이’</h2>
<p>건물 월별 에너지 사용량의 ‘정상적인’ 추이는 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergytwo/normalpattern.png" alt="normalpattern" class="align-center" />
<em>일반적인 월별 전기 사용량 추이(좌) 와 가스 사용량 추이(우)</em></p>

<p>일반적인 월별 전기 사용량 추이의 경우, 냉방으로 인해 여름의 사용량이 상대적으로 크다. 겨울의 전기 사용량은 봄/가을 대비 약간 크지만 전기난방을 하는 경우 건물에 따라 많이 클 수도 있고, 봄/ 가을과 거의 비슷할 수도 있다. 즉 월별 전기 사용량의 추이는 1~12월 plot 기준으로 중간이 튀어나온 압정 모양 혹은 더블유(W)자 모양을 띤다.</p>

<p>일반적인 월별 가스 사용량 추이의 경우, 난방으로 인해 겨울의 사용량이 매우 크다. 여름의 사용량은 대부분은 매우 작으나, 식당/ 목욕탕 등 비중이 큰 일부 건물에서는 여름에도 봄/ 가을과 비슷한 가스 사용량을 보이기도 한다. 즉 월별 가스 사용량의 추이는 유(U)자 모양을 띤다.</p>

<p><br />
그런데, 이와는 매우 다른 추이를 보이는 data point들이 있다. 예를 들면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergytwo/abnormalpattern.png" alt="abnormalpattern" class="align-center" />
<em>비정상적인 월별 전기 사용량 추이(좌) 와 가스 사용량 추이(우)</em></p>

<p>정확히는, 위 그림은 `각 월별 사용량이 연간 사용량에서 차지하는 비중’을 나타낸 그림이다. 각 월별 전기 사용량을 원소로 하는 12차원 열벡터를 $y_{i}$라 할 때, 위 그림은 $y_{i} / \Vert y_{i} \Vert_{1}$이다.
위 그림에서 보이는 월별 사용량 추이는, 일반적인 추이와 거리가 멀다. 그러므로 해당 data point를 삭제해야 한다.</p>

<p><br /></p>

<h2 id="비정상적인-추이를-보이는-data-point-판별-방법">비정상적인 추이를 보이는 data point 판별 방법</h2>
<p>그러면, 이상한 추이를 보이는 data point들은 어떻게 판별할 수 있을까? 월별 비중 그림을 일일이 다 그려서? 데이터 size (data point의 개수) 가 수천개만 되어도 이는 불가능하다. 각 data point 별로 어떤 지표(metric)를 계산 후 그 지표의 크기로 이상한 point를 판별하는 방법이 필요하다.</p>

<p>위에서 언급한 각 월별 사용량 비중을 나타내는 벡터 $y_{i} / \Vert y_{i} \Vert_{1}$를 $\tilde{y}_{i}$라 하자. 그리고 모든 건물들에 대한 $\tilde{y}_{i}$들을 ‘행벡터들을 쌓는 방식으로’ 결합하여 만든 행렬 $\tilde{Y} = [\tilde{y}_{1},\tilde{y}_{2},\cdots, \tilde{y}_{N}]^{\top}$ 을 생각하자.</p>

<p>이 때, $i$번째 data point에 대해 스칼라 값 $\tilde{y}_{i}^{\top} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{y}_{i}$ 를 계산할 수 있다. 이 값이 큰 경우, $\tilde{y}_{i}$는 월별 사용량 비중 벡터들이 만드는 12차원 공간 내에서 다른 data point들로부터 멀리 떨어져 있는 ‘remote’ point임이 알려져 있다.</p>

<p>구체적으로는 $\tilde{y}_{i}^{\top} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{y}_{i}$는 행렬 $\tilde{Y} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{Y}^{\top}$의 대각성분이다. 만약 $\tilde{y}_{i}$가 어떤 회귀모델의 설명변수 벡터인 경우, 이를 hat matrix라고 부른다. Hat matrix의 대각성분은, data point들의 중심으로부터의 표준화된 거리를 의미한다.</p>

<p>(자세한 내용은 <a href="https://product.kyobobook.co.kr/detail/S000002582053">Montgomery의 Introduction to Linear Regression</a>의 7단원을 참고하길 바란다.)</p>

<p><br />
그러면 이 스칼라 값이 구체적으로 얼마 이상이면 remote point라고 볼 수 있을까? Rule of thumb가 되는 기준은 $2p/N$으로, $p$는 $\tilde{y}_{i}$가 설명변수 벡터라 할 때 설명변수의 수이고 (월별 에너지 사용량 case의 경우 12), $N$은 data point 수이다.</p>

<p>정리하면, ‘이상한’ 월별 전기 사용량 추이를 갖는 data point들은 아래 과정을 거쳐 판별한다.</p>

<p>1) 모든 data point들에 대한 월별 전기 사용량 자료를 월별 전기 사용량의 ‘비중’ 데이터로 변환 후 각 행이 월별 전기 사용량인 12열짜리 행렬 $\tilde{Y}$로써 결합</p>

<p>2) 위에서 설명한 행렬 $\tilde{Y} (\tilde{Y}^{\top} \tilde{Y})^{-1} \tilde{Y}^{\top}$를 계산</p>

<p>3) $i$번째 대각성분이 $24/N$ 이상인 경우 ‘이상한 월별 전기 사용량 추이’를 갖는 data point로 보고 삭제
이는 월별 가스에 대해서도 마찬가지로 수행한다.</p>

<p>(이상한 추이를 갖는 data point들 그림도, 위 과정을 통해 판별한 것이다)</p>

<p>다음 포스팅에서는 건물 월별 에너지 사용량의 ‘크기(magnitude)’가 이상한 data point를 판별하는 방법을 설명한다.</p>

<div class="notice--info">

건축물 별 월별 에너지 사용량 데이터셋<br /><br />

1) <a href="/monthlyenergyone.html">모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화</a><br />
2) <b>월별 사용 추이가 이상한 data point 제거</b><br />
3) <a href="/monthlyenergythree.html">월별 사용량 크기가 이상한 data point 제거</a>

</div>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="dataset" /><category term="건물 에너지 데이터" /><category term="회귀분석" /><summary type="html"><![CDATA[이전 포스팅에서 건물 에너지 관련 연구를 위한, 각 건물의 지번별/월별 전기/도시가스 사용량 데이터와 표제부의 결합을 소개했다. 그렇다면 결합된 데이터를 그대로 쓰면 되는가? 그렇지 않다. 분명히 ‘이상한’ data point들이 존재할 것이기 때문이다. 데이터 기반의 연구개발을 한다면, 이러한 ‘이상한’ data point들을 제거하거나 수정하는 데이터 전처리는 필수이다.]]></summary></entry><entry><title type="html">WSL2 Ubuntu 22.04에 CUDA &amp;amp; cuDNN 설치하기</title><link href="http://localhost:4000/cudadudnn.html" rel="alternate" type="text/html" title="WSL2 Ubuntu 22.04에 CUDA &amp;amp; cuDNN 설치하기" /><published>2023-04-21T00:00:00+09:00</published><updated>2023-04-21T00:00:00+09:00</updated><id>http://localhost:4000/cudadudnn</id><content type="html" xml:base="http://localhost:4000/cudadudnn.html"><![CDATA[<p>이 블로그의 글을 무리 없이 읽을 정도의 독자라면, 복잡한 컴퓨터 환경 구축 때문에 많은 시간을 소비해 본 경험이 있을 것이다. 필자도 마찬가지다. 빠른 딥러닝 연산을 위해 NVIDIA CUDA를 설치하려다가, 계속되는 시행착오에 반나절을 넘게 컴퓨터만 붙잡고 있었다.</p>

<p>이에, 필자가 WSL2 Ubuntu 22.04 환경에 CUDA &amp; cuDNN을 설치하는 데 거쳤던 스텝들을 해당 포스팅으로 남긴다. 필자가 나중에 다른 컴퓨터에 CUDA를 설치하게 될 경우, 이 기록이 필자 본인에게라도 도움이 되길 바란다.</p>

<p><br />
자신의 NVIDIA 그래픽카드 모델명에 맞는 NVIDIA driver를 <a href="https://www.nvidia.co.kr/Download/index.aspx?lang=kr">다운로드 웹페이지</a> 찾아서 윈도우에서 설치.</p>

<p>ubuntu bash에서 $\texttt{nvidia-smi}$ 실행 시, 드라이버 설치 확인 가능.</p>

<p><br />
<a href="https://www.tensorflow.org/install/gpu?hl=ko">Tensorflow 웹페이지</a>에서 호환되는 CUDA 버전 확인 (‘소프트웨어 요구사항’ 항목을 보면, Tensorflow의 경우 CUDA 11.2 지원).</p>

<p><br />
<a href="https://developer.nvidia.com/cuda-11.2.0-download-archive?target_os=Linux&amp;target_arch=x86_64&amp;target_distro=WSLUbuntu&amp;target_version=20&amp;target_type=runfilelocal">CUDA Toolkit Downloads 웹페이지</a>에서 Linux - x86_64 - WSL-Ubuntu - 2.0 - runtime (local) 선택 시 보여주는 명령어를 ubuntu bash에 쳐서 CUDA를 다운로드.</p>

<p>명령어는 아래와 같음.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://developer.download.nvidia.com/compute/cuda/11.2.0/local_installers/cuda_11.2.0_460.27.04_linux.run
sudo sh cuda_11.2.0_460.27.04_linux.run
</code></pre></div></div>

<p><br />
혹시 $\texttt{sudo sh cuda_11.2.0_460.27.04_linux.run}$ 입력 시</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failed to verify gcc version. See log at /var/log/cuda-installer.log for details.
</code></pre></div></div>
<p>라는 gcc 버전 오류가 뜬다면, gcc를 버전 9로 낮춰야 함,
<a href="https://gooopy.tistory.com/134">이 포스트</a>에서 소개하는 명령어들에서 버전 숫자를 8에서 9로만 바꿔서 입력 (버전 8까지는 apt 다운로드 서버에서 없어진 듯함), 명령어는 아래와 같음.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt -y install gcc-9 g++-9
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 9
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 9
</code></pre></div></div>
<p>그리고 다시 $\texttt{sudo sh cuda_11.2.0_460.27.04_linux.run}$ 를 bash에서 실행하면
라이선스 관련 큰 창, 그리고 거기서 accept를 입력하면 설치 옵션 관련 큰 창이 뜰 것임 (미리 terminal 높이를 최대한 높여놓길 권장, 너무 낮으면 안 보임).</p>

<p>선택하고 좀 기다리면 설치됨, 필자의 경우 설치 직후 아래의 메시지가 떴음.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>= Summary =
===========

Driver:   Not Selected
Toolkit:  Installed in /usr/local/cuda-11.2/
Samples:  Installed in /home/ubuntu/, but missing recommended libraries

Please make sure that
 -   PATH includes /usr/local/cuda-11.2/bin
 -   LD_LIBRARY_PATH includes /usr/local/cuda-11.2/lib64, or, add /usr/local/cuda-11.2/lib64 to /etc/ld.so.conf and run ldconfig as root

To uninstall the CUDA Toolkit, run cuda-uninstaller in /usr/local/cuda-11.2/bin
***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 460.00 is required for CUDA 11.2 functionality to work.
To install the driver using this installer, run the following command, replacing &lt;CudaInstaller&gt; with the name of this run file:
    sudo &lt;CudaInstaller&gt;.run --silent --driver

Logfile is /var/log/cuda-installer.log
</code></pre></div></div>

<p><br />
ubuntu bash에 $\texttt{vi /etc/profile}$ 입력 후 vi 에디터에서 $\texttt{i}$ 누르면 편집 가능.</p>

<p>(vi 에디터 명령은 <a href="https://kkalkkalparrot.tistory.com/36">이 포스팅</a> 참고)</p>

<p>etc/profile에 아래 코드 입력 (<a href="https://nirsa.tistory.com/332">이 포스팅 참고</a>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export PATH=$PATH:/usr/local/cuda-11.2/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda-11.2/lib64
export CUDADIR=/usr/local/cuda-11.2
</code></pre></div></div>

<p>입력 후 Esc 눌러 편집 모드에서 나오고 $\texttt{:w}$ 입력 시 저장됨.</p>

<p>그리고 $\texttt{source /etc/profile}$ 입력.</p>

<p>CUDA 설치 버전 확인은 bash에서 $\texttt{nvcc -V}$ 실행.</p>

<p><br />
cuDNN 설치는 <a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">공식 가이드</a> 참고.</p>

<p>가이드의 1.1.3 항목대로 $\texttt{Zlib}$를 다운받기 위해, $\texttt{sudo apt-get install zlib1g}$ 를 bash에서 실행.</p>

<p>가이드의 1.2 항목대로 cudNN을 다운로드 <a href="https://developer.nvidia.com/rdp/cudnn-download">(다운로드 링크).</a></p>

<p>다운받으려면 NVIDIA 계정 필요하므로 없을 경우 생성.</p>

<p>for CUDA 11.x 에 있는 Local Installer for Linux x86_64 (Tar) 를 우선 윈도우즈에서 다운받고,
다운로드 완료되면 ubuntu shell에서 $\texttt{mtn}$으로 접근, 파일 확인 후 $\texttt{home}$ 내 폴더로 복사해 감</p>

<p>이를테면 $\texttt{D:\Downloads}$ 에 받았다고 하면 ubuntu bash에서 아래 명령 실행.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp "/mnt/d/Downloads/cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz" "/home/ubuntu/workspaces"
</code></pre></div></div>
<p>그리고 복사된 파일의 위치에서, 공식 가이드대로 아래 명령들 실행.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar -xvf cudnn-linux-x86_64-8.9.0.131_cuda11-archive.tar.xz
sudo cp cudnn-*-archive/include/cudnn*.h /usr/local/cuda/include
sudo cp -P cudnn-*-archive/lib/libcudnn* /usr/local/cuda/lib64
sudo chmod a+r /usr/local/cuda/include/cudnn*.h /usr/local/cuda/lib64/libcudnn*
</code></pre></div></div>

<p><br />
이후 재부팅한 후 ubuntu에서 tensorflow 쓰는 파이썬 코드 실행 시, 아래와 같은 맥락의 메시지를 본다면 성공임.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I tensorflow/core/common_runtime/gpu/gpu_device.cc:1635] Created device /job:localhost/replica:0/task:0/device:GPU:0 with 2029 MB memory:  -&gt; device: 0, name: NVIDIA GeForce GTX 1650 SUPER, pci bus id: 0000:01:00.0, compute capability: 7.5
</code></pre></div></div>

<p>CUDA 설치 후 GPU 사용 시, Python에서 $\texttt{Tensorflow}$ 라이브러리를 사용할 경우 RNN 모델인 LSTM과 GRU 훈련의 속도가 매우 빨라졌음을 확인함.</p>

<p>만약 tensorflow를 사용하지만 GPU를 사용하지는 않을 경우, Python 기준으로 코드 상단에 아래 코드를 추가함.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
</code></pre></div></div>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="etc" /><category term="딥러닝" /><category term="Python" /><summary type="html"><![CDATA[이 블로그의 글을 무리 없이 읽을 정도의 독자라면, 복잡한 컴퓨터 환경 구축 때문에 많은 시간을 소비해 본 경험이 있을 것이다. 필자도 마찬가지다. 빠른 딥러닝 연산을 위해 NVIDIA CUDA를 설치하려다가, 계속되는 시행착오에 반나절을 넘게 컴퓨터만 붙잡고 있었다.]]></summary></entry><entry><title type="html">건축물 별 월별 에너지 사용량 데이터셋 - 1) 모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화</title><link href="http://localhost:4000/monthlyenergyone.html" rel="alternate" type="text/html" title="건축물 별 월별 에너지 사용량 데이터셋 - 1) 모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/monthlyenergyone</id><content type="html" xml:base="http://localhost:4000/monthlyenergyone.html"><![CDATA[<p>필자의 박사과정 졸업에 결정적인 역할을 했던 데이터셋이 있다. 건축물 별 월별 에너지 사용량 데이터다. 각 지번 주소 단위의 개별 비주거용 건물별로 특정 월에 소비한 전기와 가스의 양을 kWh 단위로 기록한 데이터셋이다.</p>

<p>어떤 건물의 1년 12개월 간 월별 전기 사용량과 가스 사용량은, 대부분 아래 그림과 같은 형태를 띤다.</p>

<p><img src="/assets/images/monthlyenergyone/typicalpattern.png" alt="typicalpattern" class="align-center" width="60%" />
<em>특정 건물의 1월부터 12월까지의 전기 사용량과 가스 사용량 그래프.</em></p>

<p>전기 사용량은 7월/ 8월 즉 여름에 크고, 가스 사용량은 1월/ 2월/ 12월 즉 겨울에 큰 걸 볼 수 있다.</p>

<p><br /></p>

<h2 id="지번별-에너지-사용량-데이터">지번별 에너지 사용량 데이터</h2>
<p>이러한 개별 건물의 월별 에너지 사용량 데이터는, <a href="https://open.eais.go.kr/main/main.do">국토교통부의 건축데이터 민간개방 시스템</a>에서 제공한다.</p>

<p><img src="/assets/images/monthlyenergyone/webpage_monthlyenergy.png" alt="webpage_monthlyenergy" class="align-center" />
<em>건축데이터 민간개방 시스템의 지번별 에너지 사용량 데이터 목록.</em></p>

<p>각각이 수십(가스)~수백(전기) MB의 텍스트 파일이며, 구분자는 $|$ 이다. 이를 엑셀로 열어보면 아래 그림과 같다.</p>

<p><img src="/assets/images/monthlyenergyone/monthly_raw.png" alt="monthly_raw" class="align-center" />
<em>2022년 1월 전기 사용량에 대한 데이터셋, E~J열이 건물 주소, Q열이 2022년 1월의 에너지 사용량이다.</em></p>

<p>해당 데이터셋은 필자의 박사과정 중반기였던 2015년 말에 공개되었다. 필자는 해당 데이터셋을 이용해 공공건축물 신재생에너지 의무화 정책이 민간건물로까지 확대될 경우의 영향을 분석하고 및 도시 단위의 대규모 적용 시 영향을 예측하는 기법에 대한 연구를 수행해 박사학위를 받았고, 이 연구를 소재로 <a href="https://doi.org/10.1016/j.energy.2019.116132">Energy</a>와 <a href="https://doi.org/10.1016/j.apenergy.2020.115489">Applied Energy</a>에 제1저자 논문도 게재했다.</p>

<p>또한 최근에는, 위 데이터셋을 또 이용해 개별 건축물 내 월별 에너지 사용량의 결합확률분포를 모델링하는 연구를 수행하고 외부 발표를 하기도 했다 (<a href="https://rnd.gmdsa.org/building-energy-prediction/">MDSA 기사글</a>).</p>

<p><img src="/assets/images/monthlyenergyone/mdsaseminar.png" alt="mdsaseminar" class="align-center" width="80%" />
<em>2023년 5월 12일 데이터사이언스경영학회에서 발표중인 필자.</em></p>

<p>다만, 이 데이터셋을 제대로 활용하려면 몇 가지 사전 작업을 거쳐야 했다. 먼저 모든 월의 전기/도시가스 사용량들을 통합하고, 각 건축물 지번 별 속성 (각 건물별 연면적/ 용도/ 층수/ 건축연수/ 재질 등) 정보를 담은 데이터셋인 표제부와 결합을 해야 했다. 그리고 누락 데이터, 모양이 이상한 데이터, outlier 등을 제거해야 했다.</p>

<p>이번 포스팅은 에너지 사용량 데이터와 표제부를 Python의 pandas를 이용해 결합하고 SQL DB로 저장했던 과정에 대한 기록이다.</p>

<p><br /></p>

<h2 id="각-월별-에너지-사용량-데이터들의-통합-1년-단위">각 월별 에너지 사용량 데이터들의 통합 (1년 단위)</h2>
<p>지번별 월별 에너지 사용량 데이터는 각 월별로 흩어져 있는데, 먼저 공통된 연도의 월별 사용량 자료들을 Python의 pandas를 이용해 하나로 합쳤다. 2022년 1월의 전기 사용량 데이터 파일의 이름을 $\texttt{elec_202201.txt}$라 할 때, 2022년의 1~12월 전기 사용량과 가스 사용량 데이터들을 하나로 합치는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">settings</span>

<span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="s">'elec_202201'</span><span class="p">,</span><span class="s">'elec_202202'</span><span class="p">,</span><span class="s">'elec_202203'</span><span class="p">,</span><span class="s">'elec_202204'</span><span class="p">,</span><span class="s">'elec_202205'</span><span class="p">,</span><span class="s">'elec_202206'</span><span class="p">,</span><span class="s">'elec_202207'</span><span class="p">,</span><span class="s">'elec_202208'</span><span class="p">,</span><span class="s">'elec_202209'</span><span class="p">,</span><span class="s">'elec_202210'</span><span class="p">,</span><span class="s">'elec_202211'</span><span class="p">,</span><span class="s">'elec_202212'</span><span class="p">,</span>
            <span class="s">'gas_202201'</span><span class="p">,</span><span class="s">'gas_202202'</span><span class="p">,</span><span class="s">'gas_202203'</span><span class="p">,</span><span class="s">'gas_202204'</span><span class="p">,</span><span class="s">'gas_202205'</span><span class="p">,</span><span class="s">'gas_202206'</span><span class="p">,</span><span class="s">'gas_202207'</span><span class="p">,</span><span class="s">'gas_202208'</span><span class="p">,</span><span class="s">'gas_202209'</span><span class="p">,</span><span class="s">'gas_202210'</span><span class="p">,</span><span class="s">'gas_202211'</span><span class="p">,</span><span class="s">'gas_202212'</span><span class="p">]</span>

<span class="n">colname</span> <span class="o">=</span> <span class="p">[</span><span class="s">'useYm'</span><span class="p">,</span><span class="s">'rnum'</span><span class="p">,</span><span class="s">'sigunguCd'</span><span class="p">,</span><span class="s">'bjdongCd'</span><span class="p">,</span><span class="s">'sido'</span><span class="p">,</span><span class="s">'sigungu'</span><span class="p">,</span><span class="s">'bjdong'</span><span class="p">,</span><span class="s">'platGbCd'</span><span class="p">,</span><span class="s">'bun'</span><span class="p">,</span><span class="s">'ji'</span><span class="p">,</span><span class="s">'naRoadCd'</span><span class="p">,</span><span class="s">'naRoad'</span><span class="p">,</span><span class="s">'naUgrndCd'</span><span class="p">,</span><span class="s">'naUgrnd'</span><span class="p">,</span><span class="s">'naMainBun'</span><span class="p">,</span><span class="s">'naSubBun'</span><span class="p">,</span><span class="s">'useQty'</span><span class="p">]</span>

<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">ENERGY_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">{}.txt'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span><span class="n">sep</span><span class="o">=</span><span class="s">'|'</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'cp949'</span><span class="p">,)</span>
    
    <span class="n">df_temp</span><span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">()</span>
    
    <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'sido'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">'sigungu'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"bjdong"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">" "</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"bun"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="o">+</span><span class="s">"-"</span><span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="s">"ji"</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"번지|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'sigunguCd'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'bjdongCd'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'bun'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s">"|"</span><span class="o">+</span><span class="n">data</span><span class="p">[</span><span class="s">'ji'</span><span class="p">].</span><span class="nf">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span> <span class="c1"># 한 개 column만을 outer join 기준으로 하기 위해 코드까지 같이 넣음
</span>    <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="s">'-0'</span><span class="p">,</span><span class="s">''</span><span class="p">)</span> <span class="c1"># ji가 0인 경우 데이터에는 0으로 되어 있으나, 주소에 -0 이 나타나지 않게끔
</span>    <span class="n">df_temp</span><span class="p">[</span><span class="s">'{}'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s">'useQty'</span><span class="p">]</span>
    <span class="n">df_temp</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'address'</span><span class="p">])</span>  <span class="c1"># 주소가 중복인 항들은 전부 제거 (중복인 항들은 에너지 사용량이 모두 동일 수치인 것 확인함)
</span>        
    <span class="nf">if</span><span class="p">(</span><span class="n">count</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df_temp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">df</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">df_temp</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"outer"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"address"</span><span class="p">)</span> <span class="c1"># 한 월에 대해서라도 사용량 있는 주소는 모두 포함하므로 outer
</span>    
    <span class="k">del</span> <span class="n">data</span><span class="p">,</span> <span class="n">df_temp</span>
    
    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    
<span class="c1"># 모든 월에 대해 join되었으므로 주소텍스트와 주소코드를 나눔    
</span><span class="n">df</span><span class="p">[</span><span class="s">'addresstxt'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># 표제부에서 사용하는 주소 string과 같음
</span><span class="n">df</span><span class="p">[</span><span class="s">'sigunguCd'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'bjdongCd'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'bun'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">df</span><span class="p">[</span><span class="s">'ji'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">].</span><span class="nb">str</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s">'|'</span><span class="p">).</span><span class="nb">str</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">del</span> <span class="n">df</span><span class="p">[</span><span class="s">'address'</span><span class="p">]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s">'addresstxt'</span><span class="p">,</span><span class="s">'sigunguCd'</span><span class="p">,</span><span class="s">'bjdongCd'</span><span class="p">,</span><span class="s">'bun'</span><span class="p">,</span><span class="s">'ji'</span><span class="p">,</span><span class="s">'elec_202201'</span><span class="p">,</span><span class="s">'elec_202202'</span><span class="p">,</span><span class="s">'elec_202203'</span><span class="p">,</span><span class="s">'elec_202204'</span><span class="p">,</span><span class="s">'elec_202205'</span><span class="p">,</span><span class="s">'elec_202206'</span><span class="p">,</span><span class="s">'elec_202207'</span><span class="p">,</span><span class="s">'elec_202208'</span><span class="p">,</span><span class="s">'elec_202209'</span><span class="p">,</span><span class="s">'elec_202210'</span><span class="p">,</span><span class="s">'elec_202211'</span><span class="p">,</span><span class="s">'elec_202212'</span><span class="p">,</span><span class="s">'gas_202201'</span><span class="p">,</span><span class="s">'gas_202202'</span><span class="p">,</span><span class="s">'gas_202203'</span><span class="p">,</span><span class="s">'gas_202204'</span><span class="p">,</span><span class="s">'gas_202205'</span><span class="p">,</span><span class="s">'gas_202206'</span><span class="p">,</span><span class="s">'gas_202207'</span><span class="p">,</span><span class="s">'gas_202208'</span><span class="p">,</span><span class="s">'gas_202209'</span><span class="p">,</span><span class="s">'gas_202210'</span><span class="p">,</span><span class="s">'gas_202211'</span><span class="p">,</span><span class="s">'gas_202212'</span><span class="p">]]</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> <span class="c1"># 주소가 중복인 항들은 전부 제거 (중복인 항들은 에너지 사용량이 모두 동일 수치인 것 확인함)
</span>    
<span class="n">df</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>
</code></pre></div></div>

<p>filelist에 각 파일명을 미리 적어놓고, colname에 각 열 이름을 코드 내에서 어떻게 명시할 지 적어놓았다 (각 열에 대한 설명은, 같이 다운받을 수 있는 데이터셋_정의서 파일에 있다). 그리고 모든 데이터들을 반복문을 이용해 순서대로 불러온다.</p>

<p>파일 내 건물 주소명은 기본적으로 시/구/번/지 로 쪼개져 있는데, 표제부에서는 주소명이 합쳐져 있으므로 표제부 주소와 결합할 것을 상정하고 표제부와 같은 포맷이 되게, address 칼럼을 새로 만든다. address 같은 행들은 조사 결과 모두 같은 에너지 사용량 값들을 갖고 있어서, 단순 중복으로 간주하고 $\texttt{drop_duplicates}$로 삭제하였다.</p>

<p>이렇게 address 칼럼을 각 데이터셋에 대해 만들고, 모든 데이터셋을 address 기준으로 outer join해 합친 데이터셋이 df가 되도록 하였다. Outer join을 한 이유는 한 개 데이터셋에라도 있는 건물은 우선 포함시키기 위함이다. 그리고 df에서 필요한 칼럼들만 남긴 후 csv 파일로 저장하였다. .</p>

<p><img src="/assets/images/monthlyenergyone/everymonth.png" alt="everymonth" class="align-center" />
<em>2022년의 모든 월의 전기/가스 사용량들을 통합 후 csv 파일로 저장함.</em></p>

<p>어떤 건물들은 가스 사용량이 모든 월에 대해 없는데, 이는 해당 건물이 도시가스를 공급받지 않기 때문이다 (해당 건물 내 일부 부대시설(음식점 등)이 LPG 가스를 사용하거나 할 수는 있지만, 그 양은 알 수 없다).</p>

<p><br /></p>

<h2 id="에너지-사용량-데이터와-표제부-결합">에너지 사용량 데이터와 표제부 결합</h2>
<p>다음으로, 모든 월의 에너지 사용량 통합 데이터를 표제부와 합치고 SQL DB로 저장한다.</p>

<p><img src="/assets/images/monthlyenergyone/pyoje_web_1.png" alt="pyoje_web_1" class="align-center" />
<img src="/assets/images/monthlyenergyone/pyoje_web_2.png" alt="pyoje_web_2" class="align-center" />
<img src="/assets/images/monthlyenergyone/pyoje_web_3.png" alt="pyoje_web_3" class="align-center" />
<em>표제부에는 각 건물 별 주소/ 면적/ 건폐율/ 용적률/ 용도/ 재질/ 층수/ 사용허가일 등 정보가 있음.</em></p>

<p>대한민국 내 모든 건물들에 대한 표제부 정보를 포함하는 수 GB의 텍스트 파일을 다운받을 수 있다. 각 열의 설명은 같이 다운받을 수 있는 데이터구조 파일에 있다 (그런데 실제 데이터의 순서와 다른 경우도 있어서, 결국 직접 확인해야 했다…).</p>

<p>이 파일의 표제부 데이터를 위에서 만든 csv 파일 내 에너지 사용량 데이터와 합치고, 필요한 칼럼들을 모아서 SQLite DB로 저장하는 코드는 아래와 같다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">settings</span>

<span class="c1"># 각 column의 의미는 pyojedata 폴더의 데이터구조.xls 참고
</span><span class="n">colname</span> <span class="o">=</span> <span class="p">[</span><span class="s">'column_01'</span><span class="p">,</span> <span class="s">'column_02'</span><span class="p">,</span> <span class="s">'column_03'</span><span class="p">,</span> <span class="s">'column_04'</span><span class="p">,</span> <span class="s">'column_05'</span><span class="p">,</span> <span class="s">'addresstxt'</span><span class="p">,</span> <span class="s">'column_07'</span><span class="p">,</span> <span class="s">'bldgname'</span><span class="p">,</span> <span class="s">'sigunguCd'</span><span class="p">,</span> <span class="s">'bjdongCd'</span><span class="p">,</span> <span class="s">'column_11'</span><span class="p">,</span> <span class="s">'bun'</span><span class="p">,</span> <span class="s">'ji'</span><span class="p">,</span> <span class="s">'column_14'</span><span class="p">,</span> <span class="s">'column_15'</span><span class="p">,</span> <span class="s">'column_16'</span><span class="p">,</span> <span class="s">'column_17'</span><span class="p">,</span> <span class="s">'column_18'</span><span class="p">,</span> <span class="s">'column_19'</span><span class="p">,</span> <span class="s">'column_20'</span><span class="p">,</span> <span class="s">'column_21'</span><span class="p">,</span> <span class="s">'column_22'</span><span class="p">,</span> <span class="s">'column_23'</span><span class="p">,</span> <span class="s">'column_24'</span><span class="p">,</span> <span class="s">'column_25'</span><span class="p">,</span> <span class="s">'sitearea'</span><span class="p">,</span> <span class="s">'buildingarea'</span><span class="p">,</span> <span class="s">'coverageratio'</span><span class="p">,</span> <span class="s">'floorarea'</span><span class="p">,</span> <span class="s">'netfloorarea'</span><span class="p">,</span> <span class="s">'voltolotratio'</span><span class="p">,</span> <span class="s">'structureCd'</span><span class="p">,</span> <span class="s">'structure'</span><span class="p">,</span> <span class="s">'structuresub'</span><span class="p">,</span> <span class="s">'principaluseCd'</span><span class="p">,</span> <span class="s">'principaluse'</span><span class="p">,</span> <span class="s">'subuse'</span><span class="p">,</span> <span class="s">'roofCd'</span><span class="p">,</span> <span class="s">'roof'</span><span class="p">,</span> <span class="s">'roofsub'</span><span class="p">,</span> <span class="s">'num_household'</span><span class="p">,</span> <span class="s">'num_gagu'</span><span class="p">,</span> <span class="s">'column_43'</span><span class="p">,</span> <span class="s">'num_level'</span><span class="p">,</span> <span class="s">'num_level_below'</span><span class="p">,</span> <span class="s">'column_46'</span><span class="p">,</span> <span class="s">'column_47'</span><span class="p">,</span> <span class="s">'column_48'</span><span class="p">,</span> <span class="s">'column_49'</span><span class="p">,</span> <span class="s">'totalfloorarea'</span><span class="p">,</span> <span class="s">'column_51'</span><span class="p">,</span> <span class="s">'column_52'</span><span class="p">,</span> <span class="s">'column_53'</span><span class="p">,</span> <span class="s">'column_54'</span><span class="p">,</span> <span class="s">'column_55'</span><span class="p">,</span> <span class="s">'column_56'</span><span class="p">,</span> <span class="s">'column_57'</span><span class="p">,</span> <span class="s">'column_58'</span><span class="p">,</span> <span class="s">'column_59'</span><span class="p">,</span> <span class="s">'column_60'</span><span class="p">,</span> <span class="s">'approvaldate'</span><span class="p">,</span> <span class="s">'column_62'</span><span class="p">,</span> <span class="s">'column_63'</span><span class="p">,</span> <span class="s">'column_64'</span><span class="p">,</span> <span class="s">'column_65'</span><span class="p">,</span> <span class="s">'column_66'</span><span class="p">,</span> <span class="s">'column_67'</span><span class="p">,</span> <span class="s">'efficiencygrade'</span><span class="p">,</span> <span class="s">'efficiencyrate'</span><span class="p">,</span> <span class="s">'efficiencyscore'</span><span class="p">,</span> <span class="s">'greengrade'</span><span class="p">,</span> <span class="s">'greenscore'</span><span class="p">,</span> <span class="s">'column_73'</span><span class="p">,</span> <span class="s">'column_74'</span><span class="p">,</span> <span class="s">'column_75'</span><span class="p">,</span> <span class="s">'column_76'</span><span class="p">,</span> <span class="s">'column_77'</span><span class="p">]</span>

<span class="c1"># 표제부 불러오기
</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">PYOJE_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">pyojetable.txt'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">'|'</span><span class="p">,</span><span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">names</span><span class="o">=</span><span class="n">colname</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'CP949'</span><span class="p">)</span>

<span class="c1"># 미리 netfloorarea에 대해 내림차순 정렬해서, 추후 같은 번지에 여러 건물이 있을 경우 중복제거 후 용도가 netfloorarea가 가장 큰 항목의 용도가 되게 함
</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s">'netfloorarea'</span><span class="p">],</span> <span class="n">ascending</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="c1"># 중복주소들에 대해 값을 합칠 항목들 (연면적, 세대수 등) 을 합치기
</span><span class="n">data_tosum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s">"addresstxt"</span><span class="p">,</span><span class="s">"sitearea"</span><span class="p">,</span><span class="s">"buildingarea"</span><span class="p">,</span><span class="s">"floorarea"</span><span class="p">,</span><span class="s">"netfloorarea"</span><span class="p">,</span><span class="s">"num_household"</span><span class="p">,</span><span class="s">"num_gagu"</span><span class="p">]]</span>
<span class="n">data_tosum</span> <span class="o">=</span> <span class="n">data_tosum</span><span class="p">.</span><span class="nf">groupby</span><span class="p">(</span><span class="s">'addresstxt'</span><span class="p">).</span><span class="nf">sum</span><span class="p">()</span> 

<span class="c1"># 중복주소들에 대해 값을 합치지 않을 항목들은 하나만 남김
</span><span class="n">data_todrop</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s">"addresstxt"</span><span class="p">,</span><span class="s">"structureCd"</span><span class="p">,</span><span class="s">"structure"</span><span class="p">,</span><span class="s">"structuresub"</span><span class="p">,</span><span class="s">"principaluseCd"</span><span class="p">,</span><span class="s">"principaluse"</span><span class="p">,</span><span class="s">"subuse"</span><span class="p">,</span><span class="s">"roofCd"</span><span class="p">,</span><span class="s">"roof"</span><span class="p">,</span><span class="s">"approvaldate"</span><span class="p">,</span><span class="s">"coverageratio"</span><span class="p">,</span><span class="s">"voltolotratio"</span><span class="p">,</span><span class="s">"num_level"</span><span class="p">]]</span>
<span class="n">data_todrop</span> <span class="o">=</span> <span class="n">data_todrop</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> 

<span class="c1"># 표제부 항목들을 outer join으로 합치기
</span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">data_tosum</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">data_todrop</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"outer"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"addresstxt"</span><span class="p">)</span>

<span class="k">del</span> <span class="n">data_tosum</span><span class="p">,</span> <span class="n">data_todrop</span>

<span class="c1"># 월별 에너지 사용량 데이터 불러오기
</span><span class="n">energydata</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">read_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">)</span>

<span class="c1"># 표제부 항목들과 월별 에너지 사용량 데이터를 left join으로 합치기 (건물 속성 정보가 있는 경우에만)
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">left</span> <span class="o">=</span> <span class="n">data</span> <span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">energydata</span><span class="p">,</span> <span class="n">how</span> <span class="o">=</span> <span class="s">"left"</span><span class="p">,</span> <span class="n">on</span> <span class="o">=</span> <span class="s">"addresstxt"</span><span class="p">)</span>

<span class="k">del</span> <span class="n">data</span><span class="p">,</span> <span class="n">energydata</span>

<span class="c1"># pandas df에서 생기는 기본 axis column 필요없으므로 삭제
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">drop</span><span class="p">([</span><span class="s">'Unnamed: 0'</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="s">'columns'</span><span class="p">)</span>

<span class="c1"># addresstxt가 null인 row들 없애기 (SQL에서 addresstxt에 대한 not null 제약 만족하도록)
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s">'addresstxt'</span><span class="p">])</span> 

<span class="c1"># addresstxt가 중복인 경우 하나만 남기고 없애기 (SQL에서 addresstxt에 대한 primary key 제약 만족하도록_
</span><span class="n">resultdata</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="nf">drop_duplicates</span><span class="p">([</span><span class="s">'addresstxt'</span><span class="p">])</span> 
        
<span class="c1"># netfloorarea(용적률산정용연면적, 열인덱스 4)가 floorarea(연면적, 열인덱스 3)보다 큰 경우 잘못된 데이터이므로 수정: 
# 대지면적 * 용적률 이 계산되면서 그 값이 연면적보다 작으면 그 값을 쓰고,
# 대지면적 혹은 용적률이 누락되어 0이 나오거나 그 값이 연면적보다 크면 연면적을 씀
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">resultdata</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]:</span> <span class="c1"># 연면적 &lt; 용적률산정면적 이면
</span>        <span class="k">if</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span> <span class="o">&lt;</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span><span class="o">/</span><span class="mi">100</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">resultdata</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
            


<span class="c1"># CSV 파일로 저장
</span><span class="n">resultdata</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="n">settings</span><span class="p">.</span><span class="n">CSV_ROOT</span><span class="o">+</span><span class="s">'</span><span class="se">\\</span><span class="s">monthlyenergy_2022_pyoje.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>

<span class="c1"># SQLite query 실행
</span><span class="kn">import</span> <span class="n">sqlite3</span>
<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">'db_monthlyenergy_pyoje.db'</span><span class="p">)</span> <span class="c1"># .db 잊어버리지 말 것
</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">cursor</span><span class="p">()</span> 

<span class="k">with</span> <span class="n">conn</span><span class="p">:</span> 
    
    <span class="n">sql_create</span> <span class="o">=</span> <span class="s">"""
    create table monthlyenergy_2022_pyoje
    (addresstxt text primary key not null, /* 주소, primary key로써 고유해야 함 */
     sitearea numeric,  /* 대지면적 [m2] */
     buildingarea numeric, /* 건축면적 [m2] */
     floorarea numeric, /* 연면적 [m2] */
     netfloorarea numeric, /* 용적률산정용연면적 [m2] */
     voltolotratio numeric, /* 용적률 */        
     principaluse text, /* 주용도코드명 */  
     subuse text, /* 기타용도 */ 
     principaluseCd integer, /* 주용도코드 */ 
     coverageratio numeric, /* 건폐율 */
     num_household integer, /* 세대수 */
     num_gagu integer, /* 가구수 */
     structureCd integer, /* 구조코드 */
     structure text, /* 구조코드명 */
     structuresub text, /* 기타구조 */
     roofCd integer, /* 지붕코드 */
     roof text, /* 지붕코드명 */
     roofsub text, /* 기타지붕 */
     num_level integer, /* 지상층수 */
     approvaldate text, /* 사용승인일 */
     sigunguCd integer, /* 시군구코드 */
     bjdongCd integer, /* 법정동코드 */
     bun integer, /* 번 */
     ji integer, /* 지 */
     elec_01 numeric, /* 월별 전기 사용량 [kWh] */
     elec_02 numeric,
     elec_03 numeric,
     elec_04 numeric,
     elec_05 numeric,
     elec_06 numeric,
     elec_07 numeric,
     elec_08 numeric,
     elec_09 numeric,
     elec_10 numeric,
     elec_11 numeric,
     elec_12 numeric,
     gas_01 numeric, /* 월별 가스 사용량 [kWh] */
     gas_02 numeric,
     gas_03 numeric,
     gas_04 numeric,
     gas_05 numeric,
     gas_06 numeric,
     gas_07 numeric,
     gas_08 numeric,
     gas_09 numeric,
     gas_10 numeric,
     gas_11 numeric,
     gas_12 numeric
     )
    """</span>
    
    <span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">sql_create</span><span class="p">)</span>
    
<span class="n">resultdata</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="s">'monthlyenergy_2022_pyoje'</span><span class="p">,</span> <span class="n">conn</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">'replace'</span><span class="p">)</span>
</code></pre></div></div>

<p>에너지 사용량 데이터에서 중복 주소를 제거했기 때문에, 표제부에서도 중복주소는 제거해야 한다 (이 경우 주소가 primary key가 된다).</p>

<p>같은 지번주소 내에 실제로 여러 건물들이 있기도 하는데, 대지면적이나 연면적 (모든 층의 바닥면적들의 합) 등의 칼럼들에 대해서는 모든 건물들의 값을 다 더하면 된다 (이는 코드 내 $\texttt{data_tosum}$ 변수 정의에서 $\texttt{groupby}$와 $\texttt{sum}$으로 구현함).</p>

<p>그러나, 건물용도 (근린생활/ 업무/ 판매/ 의료 등) 또는 층수 등은 합칠 수 없는데, 미리 $\texttt{sort_values}$ 함수를 이용해 연면적 기준으로 내림차순 정렬을 해 놓음으로써 주소 중복 제거 시 건물용도나 층수 등이 가장 연면적이 큰 건물 기준으로 결정되게 했다 (코드 내 $\texttt{data_todrop}$ 변수 정의에서 $\texttt{drop_duplicates}$로 구현함). 참고로 표제부의 여러 칼럼들 중 필요한 칼럼들만 가져오는 것도 여기에 반영되어 있다.</p>

<p>표제부의 주소 중복 제거를 처리한 후, 에너지사용량 csv 파일을 불러오고, 표제부와 에너지사용량을 주소 기준으로 outer join으로 합친다. 그 결과물인 resultdata dataframe을 SQL table로 만드는 create table 쿼리를 sqlite3 패키지와 to_sql 함수를 이용해 실행했다.</p>

<p>서울 소재 건물들에 대해 구성한 SQLite DB의 스크린샷들은 아래와 같다.</p>

<p><img src="/assets/images/monthlyenergyone/sql_1.png" alt="sql_1" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_2.png" alt="sql_2" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_3.png" alt="sql_3" class="align-center" />
<img src="/assets/images/monthlyenergyone/sql_4.png" alt="sql_4" class="align-center" />
<em>2022년의 모든 월의 전기/가스 사용량들을 표제부와 결합하고 SQLite DB로 저장함.</em></p>

<p>필자는 서울 소재 건물들에 대한 연구 수행을 위해, 아래 코드를 통해 전체 SQLite DB로부터 서울 내 건물들 중 전기 사용량 및 연면적 값의 누락이 없는 행들만으로 table을 만들고 이를 별도의 DB 및 table로 저장였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="c1"># SQLite DB로부터 서울 소재이며 월별 전기 및 용적률산정연면적 누락이 없는 데이터들만 df로 불러오기
</span>
<span class="n">your_query</span> <span class="o">=</span> <span class="s">"""
select * from monthlyenergy_2022_pyoje
where addresstxt like '서울특별시%'
and elec_01 not null
and elec_02 not null
and elec_03 not null
and elec_04 not null
and elec_05 not null
and elec_06 not null
and elec_07 not null
and elec_08 not null
and elec_09 not null
and elec_10 not null
and elec_11 not null
and elec_12 not null
and netfloorarea not null
and netfloorarea &gt; 0
"""</span>
<span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="kn">import</span> <span class="n">sqlite3</span>

<span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">"db_monthlyenergy_pyoje.db"</span><span class="p">)</span> <span class="c1"># .db 잊어버리지 말 것
</span>
<span class="n">cur</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">cursor</span><span class="p">()</span>

<span class="k">with</span> <span class="n">conn</span><span class="p">:</span>

    <span class="n">df_result</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">your_query</span><span class="p">).</span><span class="nf">fetchall</span><span class="p">())</span>
    <span class="n">df_result</span><span class="p">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cur</span><span class="p">.</span><span class="n">description</span><span class="p">]</span>  <span class="c1"># add column names to the table
</span>
<span class="n">conn</span><span class="p">.</span><span class="nf">close</span><span class="p">()</span>    

<span class="n">conn_export</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s">"db_monthlyenergy_seoul.db"</span><span class="p">)</span>
<span class="n">df_result</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="s">'seoul_2022'</span><span class="p">,</span> <span class="n">conn_export</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">if_exists</span><span class="o">=</span><span class="s">'append'</span><span class="p">)</span> <span class="c1"># 별도의 SQLite DB로 저장
</span>
<span class="n">df_result</span><span class="p">.</span><span class="nf">to_csv</span><span class="p">(</span><span class="s">'seoul_2022.csv'</span><span class="p">,</span><span class="n">sep</span><span class="o">=</span><span class="s">','</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'utf-8-sig'</span><span class="p">)</span>
</code></pre></div></div>

<div class="notice--info">

건축물 별 월별 에너지 사용량 데이터셋<br /><br />

1) <b>모든 월에 대한 통합 및 표제부와의 결합 후 SQLite DB화</b><br />
2) <a href="/monthlyenergytwo.html">월별 사용 추이가 이상한 data point 제거</a><br />
3) <a href="/monthlyenergythree.html">월별 사용량 크기가 이상한 data point 제거</a>

</div>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="dataset" /><category term="SQL" /><category term="건물 에너지 데이터" /><category term="Python" /><summary type="html"><![CDATA[필자의 박사과정 졸업에 결정적인 역할을 했던 데이터셋이 있다. 건축물 별 월별 에너지 사용량 데이터다. 각 지번 주소 단위의 개별 비주거용 건물별로 특정 월에 소비한 전기와 가스의 양을 kWh 단위로 기록한 데이터셋이다.]]></summary></entry><entry><title type="html">강화학습 기반 마이크로그리드 스케줄링 - 5) TD3/ SAC를 통한 continuous control 도출</title><link href="http://localhost:4000/reinforcefive.html" rel="alternate" type="text/html" title="강화학습 기반 마이크로그리드 스케줄링 - 5) TD3/ SAC를 통한 continuous control 도출" /><published>2023-04-19T00:00:00+09:00</published><updated>2023-04-19T00:00:00+09:00</updated><id>http://localhost:4000/reinforcefive</id><content type="html" xml:base="http://localhost:4000/reinforcefive.html"><![CDATA[<p>Deep Deterministic Policy Gradient (DDPG) 로 도출한 수전/송전의 continuous control이, 놀랍게도(?) Vincent의 마이크로그리드 사례에서는, DQN으로 도출한 3-actions discrete control 대비 더 좋지 않았다 (3개 action들은 각각 1.1kW 수전/ 1.1kW 송전/ idle).</p>

<p><img src="/assets/images/reinforceone/system.png" alt="system" class="align-center" />
<em>Vincent의 연구에서 가정된 마이크로그리드.</em></p>

<p>그렇다면 continuous control 도출을 위해 DDPG 이후에 개발된 더 진보된 방법을 쓴다면 어떨까?</p>

<p>진보된 방법들의 대표 사례들로, <a href="https://arxiv.org/abs/1802.09477">Twin Delayed Deep Deterministic policy gradient (TD3)</a>와 <a href="https://arxiv.org/abs/1812.05905">Soft Actor-Critic (SAC)</a>이 있다.</p>

<p><br /></p>

<h2 id="twin-delayed-ddpg-td3">Twin Delayed DDPG (TD3)</h2>

<p>TD3가 DDPG와 비교해 갖는 차이점은 대략 아래와 같다 (항상 그렇지만 상세한 내용은 논문 원문을 참고하자).</p>

<p>1) critic 신경망 한 개가 아닌 두 개를 사용함. 그리고 $Q(s_{t+1},a_{t+1})$을 두 개의 target critic 신경망 각각에 대해 계산하고 그 중 ‘더 작은 값’을 사용함. 마찬가지로 actor 훈련시의 목적함수 내 $Q(s_{t},a_{t})$ 또한 두 critic 신경망 각각에 대해 계산하고 그 중 ‘더 작은 값’을 사용함. 이를 통해 Q-learning 특유의 overestimation 문제를 경감할 수 있음.<br />
2) $a_{t+1}$을 결정 시 actor의 결과를 그대로 쓰는 게 아니라, clipped noise를 추가하여 smoothing regularization 효과를 얻음.<br />
3) Critic이 두 번 업데이트될 동안 actor는 한 번 업데이트됨, 이러한 `delayed’ policy update를 통해 value estimation의 variance를 줄임.</p>

<p>TD3 훈련 코드는 아래와 같다. 코드 내 주석은 지난 포스팅의 DDPG 코드 대비 다른 부분에 대해서만 추가하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="n">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Conv1D</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">actor_lr</span> <span class="o">=</span> <span class="mf">0.0001</span> 
<span class="n">critic_lr</span> <span class="o">=</span> <span class="mf">0.0002</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
<span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">clippednoise_std</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># clipped noise를 생성하는 평균이 0인 정규분포의 표준편차
</span><span class="n">clippednoise_interval</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="c1"># clipped noise의 구간 설정
</span><span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)</span>
<span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)</span> 

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)</span>
<span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)</span>

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span>

<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Critic</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>          
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_action</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_qval</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_qval</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>    
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_action</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'tanh'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_action</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">):</span>       
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span>

<span class="n">critic_one_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">critic_two_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> <span class="c1"># Critic NN을 2개 사용함
</span><span class="n">critic_two_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span> <span class="c1"># 두 번째 critic NN의 target net
</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">actor_learning</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_target</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>



<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">epsilon</span> <span class="ow">and</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)).</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
   
    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="o">-</span><span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span>
    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span>   
    
    <span class="c1">#p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span>
    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span>
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span>
    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span>



<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">clippednoise_std</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="o">-</span><span class="n">clippednoise_interval</span><span class="p">,</span> <span class="n">clippednoise_interval</span><span class="p">)</span>
    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="nf">actor_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">).</span><span class="nf">numpy</span><span class="p">().</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">noise</span> <span class="c1"># clipped noise 추가 (smoothing 효과 얻음)
</span>    <span class="n">actions_by_target</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">clip</span><span class="p">(</span><span class="n">actions_by_target</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># clipped noise를 추가하더라도 action이 [-1,1] 범위에 들게 제한
</span>    
    <span class="n">Q_values_one_by_target</span> <span class="o">=</span> <span class="nf">critic_one_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_two_by_target</span> <span class="o">=</span> <span class="nf">critic_two_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span> <span class="c1"># 두 번째 critic net을 사용해서 nextstate에 대한 Q-value 계산
</span>    <span class="n">Q_values_min_by_target</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one_by_target</span><span class="p">,</span> <span class="n">Q_values_two_by_target</span><span class="p">)</span> <span class="c1"># 두 Q-value들 중 작은 값을 사용 (over-estimation 문제 완화)
</span>    <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">stop_gradient</span><span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="n">Q_values_min_by_target</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
        <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> 
        <span class="n">loss_critic_one</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Q_values_one</span><span class="p">))</span> 
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_one</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span> 
    <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
        <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">loss_critic_two</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">))</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_two</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">actorupdate</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>    
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> 
            <span class="n">actions_by_learner</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">)</span>
            <span class="n">loss_actor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="o">-</span><span class="n">Q_values_min</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_actor</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">actor_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
        
        <span class="n">actor_weights</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_actor_weights</span> <span class="o">=</span> <span class="n">actor_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">actor_weights</span><span class="p">)):</span>
            <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_actor_weights</span><span class="p">)</span>
        
        <span class="n">critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">critic_one_weights</span><span class="p">)):</span>
            <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_one_weights</span><span class="p">)</span>   
        <span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_two_weights</span><span class="p">)</span>



<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bool_fortrain</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> <span class="c1"># 시작시점
</span>    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span>
        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>  
        <span class="n">epsilon</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">epoch</span> <span class="o">/</span> <span class="mi">50</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">epsilon</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>     

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> 
                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="n">bool_fortrain</span><span class="p">)</span>
                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bool_fortrain</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">bool_fortrain</span>
                
                
    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span> 
        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>
        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span>
            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span>
            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span>
            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">actor_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'actor_trainedmodel_td3.h5'</span><span class="p">)</span>
            <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_one_trainedmodel_td3.h5'</span><span class="p">)</span>
            <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_two_trainedmodel_td3.h5'</span><span class="p">)</span>
                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_td3.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="soft-actor-critic-sac">Soft Actor-Critic (SAC)</h2>

<p>SAC에서는 `stochastic’ actor를 가정한다. 즉 actor는 특정 확률분포로부터 action을 도출한다. $a_{t} \sim \pi_{\phi}(a|s_{t})$ 인 것이다. 보통 Actor의 직접적인 출력은 정규분포의 평균값 그리고 표준편차의 로그값이고, 이로부터 정의되는 정규분포로부터 샘플을 뽑거나 (training) 평균값을 (validation) 뽑는다. 만약 bounded action인 경우 tanh kernel을 추가해서 action을 결정한다. Stochastic actor를 쓰기 때문에, DQN/ DDPG/ TD3에서 그랬던 것처럼 hand-crafted noise를 따로 추가하지 않아도 자동으로 훈련 과정에서 exploration이 된다는 장점이 있다.</p>

<p>그리고 SAC에서는 신경망들을 훈련 시 `최대화’ 대상 목적함수에 entropy term $-\alpha \text{log} \pi_{\phi}(a|s_{t}) $ 이 추가된다 (로그확률값은 actor를 call 할 때 받아옴). 정보이론에서 Entropy는 음의 확률에 로그확률을 곱한 값이고 목적함수는 평균을 의미하므로 앞에 확률값이 생략된 것으로 보면 위 term은 entropy를 의미한다. Entropy가 클수록 해당 확률분포가 균등분포에 가까워지므로, 결과적으로 exploration을 장려하게 된다.</p>

<p>$\alpha$는 temperature parameter로, 클수록 entropy의 최대화에 가중치를 많이 줘서 균등분포에 더 가까워진다. SAC에서는 $\alpha$를 사전에 고정된 값으로 결정하지 않고, $\alpha$가 minimum expected entropy 조건 하의 return 최대화 문제의 dual problem의 Lagrangian multiplier임에 착안해 그 값을 변경해 나간다. 그러므로 $\alpha$의 초기값은 사용자가 결정하지만, 그 값은 훈련을 거치면서 지속적으로 수정된다. (역시 상세 내용은 논문 원문을 참고하자.)</p>

<p>SAC 훈련 코드는 아래와 같다 <a href="https://github.com/shakti365/soft-actor-critic">(코드 작성에 참고한 포스팅).</a> 코드 내 주석은 지난 포스팅의 DDPG 코드 대비 다른 부분에 대해서만 추가하였다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># -*- coding: utf-8 -*-
</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">tensorflow</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="n">tensorflow_probability</span> <span class="k">as</span> <span class="n">tfp</span>
<span class="kn">from</span> <span class="n">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="n">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Conv1D</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1">### hyperparameters
</span>
<span class="n">alpha_lr</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># temperature parameter에 대한 learning rate
</span><span class="n">actor_lr</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">critic_lr</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">tau</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">alpha_initial</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># temperature parameter의 초기값
</span><span class="n">target_entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">tf</span><span class="p">.</span><span class="nf">constant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># 1은 DoF of action
</span><span class="n">rewardscalefactor</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># SAC가 reward scale에 민감하므로 잘 선택해야 함: reward가 너무 낮으면 너무 exploration만 해버리고, reward가 너무 높으면 처음엔 학습이 빨리 되는 것 같아 보이지만 poor local minima로 수렴함이 알려짐
</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">discount_factor</span> <span class="o">=</span> <span class="mf">0.98</span>
<span class="n">period_step_fortrain</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### microgrid system data
</span>
<span class="n">PV_prod_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_train.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>
<span class="n">PV_prod_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'BelgiumPV_prod_test.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>  

<span class="n">load_train</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_train.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span>
<span class="n">load_test</span>  <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">load</span><span class="p">(</span><span class="s">'example_nondeterminist_cons_test.npy'</span><span class="p">)[:</span><span class="mi">96</span><span class="p">]</span> 

<span class="n">prate_h2</span> <span class="o">=</span> <span class="mf">1.1</span>
<span class="n">eff_h2</span> <span class="o">=</span> <span class="mf">0.65</span>

<span class="n">capa_batt</span> <span class="o">=</span> <span class="mi">15</span>
<span class="n">eff_batt</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">initialenergy_batt</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">price_h2</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">cost_loss</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">load_peak</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">pv_peak</span> <span class="o">=</span> <span class="mi">12</span>

<span class="n">inputlen_load</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">inputlen_pv</span> <span class="o">=</span> <span class="mi">24</span>



<span class="c1">### Neural net configuration
</span>
<span class="k">class</span> <span class="nc">Critic</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Critic</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>         
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_action</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_qval</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_action</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_qval</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">input_action</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">Actor</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="nf">super</span><span class="p">(</span><span class="n">Actor</span><span class="p">,</span> <span class="n">self</span><span class="p">).</span><span class="nf">__init__</span><span class="p">()</span>       
        <span class="n">self</span><span class="p">.</span><span class="n">input_load</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">input_pv</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_pv</span><span class="p">],</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span> <span class="o">=</span> <span class="nc">Conv1D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_conv</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span> <span class="o">=</span> <span class="nc">Flatten</span><span class="p">()(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_conv_concat</span><span class="p">)</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">input_others</span> <span class="o">=</span> <span class="nc">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">self</span><span class="p">.</span><span class="n">concat_all</span> <span class="o">=</span> <span class="nf">concatenate</span><span class="p">([</span><span class="n">self</span><span class="p">.</span><span class="n">flatten_conv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">])</span> 
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">concat_all</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'relu'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">output_action_mean</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span> <span class="c1"># 정규분포의 평균
</span>        <span class="n">self</span><span class="p">.</span><span class="n">output_action_stddev</span> <span class="o">=</span> <span class="nc">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">activation</span><span class="o">=</span><span class="s">'linear'</span><span class="p">)(</span><span class="n">self</span><span class="p">.</span><span class="n">hidden_dense_2</span><span class="p">)</span> <span class="c1"># 정규분포의 표준편차
</span>        <span class="n">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="p">.</span><span class="nc">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">input_load</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_pv</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">input_others</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">output_action_mean</span><span class="p">,</span><span class="n">self</span><span class="p">.</span><span class="n">output_action_stddev</span><span class="p">])</span>     
    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>        
        <span class="n">mu</span><span class="p">,</span> <span class="n">logsigma</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">model</span><span class="p">((</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">))</span> <span class="c1"># 정규분포의 평균, 로그표준편차
</span>        <span class="n">sigma</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">logsigma</span><span class="p">)</span> <span class="c1"># 로그표준편차를 표준편차로 변환
</span>        <span class="n">dist</span> <span class="o">=</span> <span class="n">tfp</span><span class="p">.</span><span class="n">distributions</span><span class="p">.</span><span class="nc">Normal</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span> <span class="c1"># 정규분포 정의
</span>        <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span> <span class="c1"># Training 시
</span>            <span class="n">action_temp</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="nf">sample</span><span class="p">()</span> <span class="c1"># 정규분포로부터 임의로 샘플 뽑아서 action 결정 
</span>        <span class="k">else</span><span class="p">:</span> <span class="c1"># Validation 시
</span>            <span class="n">action_temp</span> <span class="o">=</span> <span class="n">mu</span> <span class="c1"># Validation 시에는 mean action으로 (deterministic action)
</span>        <span class="n">action</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">tanh</span><span class="p">(</span><span class="n">action_temp</span><span class="p">)</span> <span class="c1"># tanh activation function을 이용한 bounded action 구현
</span>        <span class="n">logprob_temp</span> <span class="o">=</span> <span class="n">dist</span><span class="p">.</span><span class="nf">log_prob</span><span class="p">(</span><span class="n">action_temp</span><span class="p">)</span>
        <span class="n">logprob</span> <span class="o">=</span> <span class="n">logprob_temp</span> <span class="o">-</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_sum</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">action</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-16</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                         <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># log-probability 반환
</span>        <span class="k">return</span> <span class="n">action</span><span class="p">,</span> <span class="n">logprob</span>
        

<span class="n">critic_one_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">critic_two_learning</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_two_target</span> <span class="o">=</span> <span class="nc">Critic</span><span class="p">()</span>
<span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">critic_lr</span><span class="p">))</span>
<span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span> 

<span class="n">actor_learning</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_target</span> <span class="o">=</span> <span class="nc">Actor</span><span class="p">()</span>
<span class="n">actor_learning</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">actor_lr</span><span class="p">))</span>
<span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">())</span>

<span class="n">alpha</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nc">Variable</span><span class="p">(</span><span class="n">alpha_initial</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span> <span class="c1"># temperature parameter 정의
</span><span class="n">alpha_optimizer</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span><span class="p">.</span><span class="nc">Adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="n">alpha_lr</span><span class="p">)</span>

<span class="n">actor_weight_temp</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
<span class="n">critic_one_weight_temp</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
<span class="n">critic_two_weight_temp</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>


<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="n">replay_buffer</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">(</span><span class="n">maxlen</span><span class="o">=</span><span class="n">buffer_size</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">randint</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">replay_buffer</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">)</span>
    <span class="n">batch</span> <span class="o">=</span> <span class="p">[</span><span class="n">replay_buffer</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">experience</span><span class="p">[</span><span class="n">field_index</span><span class="p">]</span> <span class="k">for</span> <span class="n">experience</span> <span class="ow">in</span> <span class="n">batch</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">field_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span>



<span class="k">def</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">profile_load</span><span class="p">,</span><span class="n">profile_pv</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        
    <span class="n">state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]))</span> <span class="p">)</span>
    
    <span class="n">action</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_load</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="n">inputlen_pv</span><span class="p">:</span><span class="n">hour</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt</span><span class="p">]).</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">.</span><span class="nf">numpy</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> 
        
    <span class="n">p_h2_send</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_h2_receive</span> <span class="o">=</span> <span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p_h2_send</span> <span class="o">=</span> <span class="o">-</span><span class="n">prate_h2</span><span class="o">*</span><span class="n">action</span>
    <span class="n">p_load</span> <span class="o">=</span> <span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">load_peak</span>
    <span class="n">p_pv</span> <span class="o">=</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="p">]</span><span class="o">*</span><span class="n">pv_peak</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">capa_batt</span>
        
    <span class="c1"># p_curtail = 0
</span>    <span class="n">p_loss</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="n">p_net_beforebatt</span> <span class="o">=</span> <span class="n">p_pv</span> <span class="o">-</span> <span class="n">p_load</span> <span class="o">+</span> <span class="n">p_h2_receive</span> <span class="o">-</span> <span class="n">p_h2_send</span>
    
    <span class="k">if</span> <span class="n">p_net_beforebatt</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">capa_batt</span> <span class="o">&gt;=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">*</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">capa_batt</span>
            <span class="c1"># p_curtail = (energy_batt + p_net_beforebatt*eff_batt - capa_batt)/eff_batt 
</span>    <span class="k">else</span><span class="p">:</span> 
        <span class="k">if</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt</span> <span class="o">+</span> <span class="n">p_net_beforebatt</span><span class="o">/</span><span class="n">eff_batt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_loss</span> <span class="o">=</span> <span class="o">-</span><span class="n">p_net_beforebatt</span> <span class="o">-</span> <span class="n">energy_batt</span><span class="o">*</span><span class="n">eff_batt</span>           
    
    <span class="n">reward</span> <span class="o">=</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_send</span><span class="o">*</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">price_h2</span><span class="o">*</span><span class="n">p_h2_receive</span><span class="o">/</span><span class="n">eff_h2</span> <span class="o">-</span> <span class="n">cost_loss</span><span class="o">*</span><span class="n">p_loss</span>
    <span class="n">energy_batt_after</span> <span class="o">=</span> <span class="n">energy_batt_after</span><span class="o">/</span><span class="n">capa_batt</span>
    
    <span class="k">if</span> <span class="n">training</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">profile_load</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_load</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">profile_pv</span><span class="p">[</span><span class="n">hour</span><span class="o">-</span><span class="p">(</span><span class="n">inputlen_pv</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="n">hour</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="n">energy_batt_after</span><span class="p">]))</span> <span class="p">)</span>         
        <span class="n">replay_buffer</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">,</span> <span class="n">reward</span><span class="o">*</span><span class="n">rewardscalefactor</span><span class="p">,</span> <span class="n">next_state</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">energy_batt_after</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span>



<span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    
    <span class="n">states</span><span class="p">,</span> <span class="n">actions</span><span class="p">,</span> <span class="n">rewards</span><span class="p">,</span> <span class="n">next_states</span> <span class="o">=</span> <span class="nf">sample_experiences</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        
    <span class="n">input_load</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> 
    <span class="n">input_pv</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others</span> <span class="o">=</span> <span class="n">states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">input_load_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="n">inputlen_load</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_load</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_pv_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,</span><span class="n">inputlen_load</span><span class="p">:(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">inputlen_pv</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">input_others_next</span> <span class="o">=</span> <span class="n">next_states</span><span class="p">[:,(</span><span class="n">inputlen_load</span><span class="o">+</span><span class="n">inputlen_pv</span><span class="p">)].</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">actions_by_target</span><span class="p">,</span> <span class="n">logprobs_actions_target</span> <span class="o">=</span> <span class="nf">actor_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">)</span><span class="c1"># action 뿐 아니라 로그확률도 불러옴, 로그확률은 entropy term에 사용됨
</span>    
    <span class="n">Q_values_one_by_target</span> <span class="o">=</span> <span class="nf">critic_one_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_two_by_target</span> <span class="o">=</span> <span class="nf">critic_two_target</span><span class="p">(</span><span class="n">input_load_next</span><span class="p">,</span><span class="n">input_pv_next</span><span class="p">,</span><span class="n">input_others_next</span><span class="p">,</span><span class="n">actions_by_target</span><span class="p">)</span>
    <span class="n">Q_values_min_by_target</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one_by_target</span><span class="p">,</span> <span class="n">Q_values_two_by_target</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">stop_gradient</span><span class="p">(</span><span class="n">rewards</span> <span class="o">+</span> <span class="n">discount_factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">Q_values_min_by_target</span> <span class="o">-</span> <span class="n">alpha</span><span class="o">*</span><span class="n">logprobs_actions_target</span><span class="p">))</span> <span class="c1"># entropy term이 추가됨됨
</span>    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="c1">#
</span>        <span class="n">loss_critic_one</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Q_values_one</span><span class="p">))</span> 
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_one</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
        <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions</span><span class="p">.</span><span class="nf">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">loss_critic_two</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">keras</span><span class="p">.</span><span class="n">losses</span><span class="p">.</span><span class="nf">mean_squared_error</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">Q_values_two</span><span class="p">))</span>
    <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_critic_two</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
    <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">actorupdate</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>    
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span>
            <span class="n">actions_by_learner</span><span class="p">,</span> <span class="n">logprobs_actions</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">Q_values_one</span> <span class="o">=</span> <span class="nf">critic_one_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_two</span> <span class="o">=</span> <span class="nf">critic_two_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">,</span><span class="n">actions_by_learner</span><span class="p">)</span>
            <span class="n">Q_values_min</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">math</span><span class="p">.</span><span class="nf">minimum</span><span class="p">(</span><span class="n">Q_values_one</span><span class="p">,</span> <span class="n">Q_values_two</span><span class="p">)</span>
            <span class="n">loss_actor</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">logprobs_actions</span> <span class="o">-</span> <span class="n">Q_values_min</span><span class="p">)</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_actor</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">)</span>
        <span class="n">actor_learning</span><span class="p">.</span><span class="n">optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">))</span>
        
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="nc">GradientTape</span><span class="p">()</span> <span class="k">as</span> <span class="n">tape</span><span class="p">:</span> <span class="c1"># temperature parameter의 업데이트
</span>            <span class="n">actions_by_learner</span><span class="p">,</span> <span class="n">logprobs_actions</span> <span class="o">=</span> <span class="nf">actor_learning</span><span class="p">(</span><span class="n">input_load</span><span class="p">,</span><span class="n">input_pv</span><span class="p">,</span><span class="n">input_others</span><span class="p">)</span>
            <span class="n">loss_alpha</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="nf">reduce_mean</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">logprobs_actions</span><span class="o">+</span><span class="n">target_entropy</span><span class="p">))</span>
        <span class="n">grads</span> <span class="o">=</span> <span class="n">tape</span><span class="p">.</span><span class="nf">gradient</span><span class="p">(</span><span class="n">loss_alpha</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span><span class="p">])</span>
        <span class="n">alpha_optimizer</span><span class="p">.</span><span class="nf">apply_gradients</span><span class="p">(</span><span class="nf">zip</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="p">[</span><span class="n">alpha</span><span class="p">]))</span>
        
        <span class="n">actor_weights</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_actor_weights</span> <span class="o">=</span> <span class="n">actor_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">actor_weights</span><span class="p">)):</span>
            <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_actor_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">actor_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_actor_weights</span><span class="p">)</span>
        
        <span class="n">critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_one_weights</span> <span class="o">=</span> <span class="n">critic_one_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="n">target_critic_two_weights</span> <span class="o">=</span> <span class="n">critic_two_target</span><span class="p">.</span><span class="n">weights</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">critic_one_weights</span><span class="p">)):</span>
            <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_one_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">tau</span><span class="p">)</span> <span class="o">*</span> <span class="n">target_critic_two_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">critic_one_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_one_weights</span><span class="p">)</span>    
        <span class="n">critic_two_target</span><span class="p">.</span><span class="nf">set_weights</span><span class="p">(</span><span class="n">target_critic_two_weights</span><span class="p">)</span>    



<span class="n">profits_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">elapsedtime_test</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">max_return_test</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="p">.</span><span class="n">inf</span>
<span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bool_fortrain</span> <span class="o">=</span> <span class="bp">False</span>


<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
    
    <span class="c1">### Train for each epoch
</span>    
    <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>  
    
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_train</span><span class="p">)</span><span class="o">-</span><span class="mi">25</span><span class="p">):</span>
        <span class="n">count_step_fortrain</span> <span class="o">+=</span> <span class="mi">1</span>      
        <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_train</span><span class="p">,</span><span class="n">PV_prod_train</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>     

        <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">count_step_fortrain</span> <span class="o">&gt;</span> <span class="n">period_step_fortrain</span><span class="p">:</span> 
                <span class="nf">training_step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span><span class="n">actorupdate</span><span class="o">=</span><span class="n">bool_fortrain</span><span class="p">)</span>
                <span class="n">count_step_fortrain</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bool_fortrain</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">bool_fortrain</span>                                   
                <span class="n">actor_weight_temp</span> <span class="o">=</span> <span class="n">actor_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                <span class="n">critic_one_weight_temp</span> <span class="o">=</span> <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                <span class="n">critic_two_temp</span> <span class="o">=</span> <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">get_weights</span><span class="p">()</span>
                    
    <span class="c1">### Validation for each epoch  
</span>    <span class="k">if</span> <span class="n">epoch</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">testcase_actions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">testcase_battenergy</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">epoch_return_test</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">hour</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="n">energy_batt</span> <span class="o">=</span> <span class="n">initialenergy_batt</span>
        
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">load_test</span><span class="p">)</span><span class="o">-</span><span class="mi">24</span><span class="p">):</span>
            <span class="n">energy_batt</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">action</span> <span class="o">=</span> <span class="nf">play_one_step</span><span class="p">(</span><span class="n">load_test</span><span class="p">,</span><span class="n">PV_prod_test</span><span class="p">,</span><span class="n">hour</span><span class="p">,</span><span class="n">energy_batt</span><span class="p">,</span><span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">testcase_actions</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
            <span class="n">testcase_battenergy</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">energy_batt</span><span class="p">)</span>
            <span class="n">epoch_return_test</span> <span class="o">+=</span> <span class="n">reward</span>
            <span class="n">hour</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="n">profits_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">)</span>   
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_profit_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">profits_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
    
        <span class="k">if</span> <span class="n">max_return_test</span> <span class="o">&lt;</span> <span class="n">epoch_return_test</span><span class="p">:</span>
            <span class="n">max_return_test</span> <span class="o">=</span> <span class="n">epoch_return_test</span>
            <span class="n">actor_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'actor_trainedmodel_sac.h5'</span><span class="p">)</span>
            <span class="n">critic_one_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_one_trainedmodel_sac.h5'</span><span class="p">)</span>
            <span class="n">critic_two_learning</span><span class="p">.</span><span class="nf">save_weights</span><span class="p">(</span><span class="s">'critic_two_trainedmodel_sac.h5'</span><span class="p">)</span>
                    
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_actions_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_actions</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
            
            <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_battenergy_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">testcase_battenergy</span><span class="p">:</span>
                        <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
                        
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>   
        <span class="n">elapsedtime_test</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Validation: profit of epoch {} is {}, maximum profit is {}"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span><span class="nf">round</span><span class="p">(</span><span class="n">epoch_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="nf">round</span><span class="p">(</span><span class="n">max_return_test</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'one epoch 수행에 {}초 걸렸습니다'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nf">round</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">'Temperature parameter 값은 {}입니다.'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">.</span><span class="nf">numpy</span><span class="p">()))</span>
        <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="s">'trajectory_time_test_sac.txt'</span><span class="p">,</span> <span class="s">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">elapsedtime_test</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>SAC 훈련에서 주의할 점은, 가끔 $\alpha$가 NaN이 되기도 한다는 것이다. 솔직히 아직은 이유를 모르겠다… 사실 이 부분은 100% 이해를 한 게 아니라서 위 reference page에서 한 방식을 그대로 쓴 것이다. 아무튼 NaN이 되면 더 이상 훈련이 되지 않으니, learning rate를 더 줄이거나 한 후 처음부터 다시 훈련을 시켜야 한다.</p>

<p><br /></p>

<h2 id="td3-sac를-통한-continuous-control-결과">TD3/ SAC를 통한 continuous control 결과</h2>

<p>결과를 보면, TD3 control에서는 낮 송전 기간에 쭉 최대송전에 가깝게 하지 않고 송전량을 줄였다가 다시 늘리는 패턴이 보인다. 한편 SAC control에서는 최대송전과 최대수전을 하는 경우가 거의 없다.</p>

<p><img src="/assets/images/reinforcefive/result_td3sac.png" alt="result_td3sac" class="align-center" />
<em>TD3/ SAC로 도출한 수전/송전 control. LP control과는 차이가 있음.</em></p>

<p>TD3와 SAC으로 도출한 control 적용 시 validation case에 대한 누적 비용은 각각 85유로, 118유로이다. 이는 DDPG control (125유로) 보다는 조금 나은 결과지만, 여전히 DQN control (50유로) 에 뒤진다.</p>

<p>Vincent의 마이크로그리드 사례에서는, 미래를 안다는 가정 하에 도출한 LP solution에서의 action이 (엄밀히는 continuous지만) 거의 discrete에 가까운 모습이다. 그러므로, action을 state의 continuous function으로 근사하는 DDPG/ TD3/ SAC보다는, discrete function으로 근사하는 DQN이 더 나은 것으로 추정된다.</p>

<p>심지어 이는 시뮬레이션으로 계산되는 마이크로그리드의 누적비용 측면에서만 생각한 것이며, 계산 시간까지 고려하면 DQN의 computational efficiency가 DDPG/ TD3/ SAC 대비 훨씬 높다.</p>

<p><br />
실제로 에너지기술연구원에서 히트펌프 제어기를 심층강화학습으로 훈련시킨 연구에서도 (아래 Youtube 영상), SAC 기반 continuous control을 연구과정에서 시도하기는 했으나 최종적으로는 DQN으로 도출한 discrete control을 사용 및 논문화하였다 (히트펌프의 경우 여러 대를 설치 후 매 시간별로 몇 대나 가동할 것이냐를 결정하는 discrete control이 가능하기도 하다).</p>

<!-- Courtesy of embedresponsively.com -->

<div class="responsive-video-container">
    <iframe src="https://www.youtube-nocookie.com/embed/L9Ye1gALFAk" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe>
  </div>

<p><br /></p>

<h2 id="나가며">나가며</h2>

<p>데이터 사이언스에서 ‘Data Generating Process (DGP)에 맞는 방법을 써라’ 라는 격언이 있는데, 이번 사례도 이와 유사한 교훈을 주는 사례인 것 같다.</p>

<p>미래를 모두 안다는 가정 하에 선형계획법으로 얻은 optimal solution에서의 action이 discrete action과 상당히 유사함을, 강화학습 계산 전에 미리 알 수 있었다. 그렇다면 이 문제에 있어 더 맞는 강화학습 방법은 discrete control 방법이며, 굳이 continuous control 방법을 시도해도 discrete 대비 더 나은 결과를 얻지 못하는 것이 놀랍지 않은 것이다.</p>

<p><br />
(사족: 그런데, 사실 Vincent의 마이크로그리드 사례처럼 계통으로부터의 수전/송전 한도가 ‘peak 부하 밑으로’ 제한되어 있는 경우가 결코 흔치는 않을 것이다. 솔직히 말하면, 실제 현실에서 일반적인 case라기보다는, DQN 적용이 용이하도록 어느 정도 꾸며낸 case라는 느낌을 받는다. <br />
실제로는 열병합발전기/ 냉난방설비 등 제어 가능한 설비의 출력을 action으로 두고, 계통으로부터의 수전/송전은 action에 따라 자동으로 결정되는 환경변수들로 두는 것이 더 합리적으로 보인다. 다만 이는 강화학습으로 안정적인 economic control을 도출하기가 쉽지 않아 보이는데, 이에 관련된 논문을 향후 찾아볼 생각이다.)</p>

<div class="notice--info">

강화학습 기반 마이크로그리드 스케줄링<br /><br />

1) <a href="/reinforceone.html">문제의식 및 케이스 소개</a><br />
2) <a href="/reinforcetwo.html">Q-learning 개념</a><br />
3) <a href="/reinforcethree.html">Deep Q-learning을 통한 discrete control 도출</a><br />
4) <a href="/reinforcefour.html">DDPG를 통한 continuous control 도출</a><br />
5) <b>TD3, SAC를 통한 continuous control 도출</b>

</div>]]></content><author><name>Jeonghun Song</name><email>song4energy@gmail.com</email></author><category term="energymanagement" /><category term="강화학습" /><category term="녹색섬" /><category term="Python" /><summary type="html"><![CDATA[Deep Deterministic Policy Gradient (DDPG) 로 도출한 수전/송전의 continuous control이, 놀랍게도(?) Vincent의 마이크로그리드 사례에서는, DQN으로 도출한 3-actions discrete control 대비 더 좋지 않았다 (3개 action들은 각각 1.1kW 수전/ 1.1kW 송전/ idle).]]></summary></entry></feed>